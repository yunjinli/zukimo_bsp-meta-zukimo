From d6ecdce4ccb2287e6fa71a888664a3ef0d31612d Mon Sep 17 00:00:00 2001
From: Stefan Stuerke <stefan.stuerke@dreamchip.de>
Date: Thu, 18 Apr 2024 14:28:07 +0200
Subject: [PATCH 30/34] Add support for DCT Zukimo reset controller

Upstream-Status: Pending
---
 drivers/reset/Kconfig                |   7 +
 drivers/reset/Makefile               |   1 +
 drivers/reset/reset-dct-zukimo-eth.h |  59 ++++++
 drivers/reset/reset-dct-zukimo.c     | 261 +++++++++++++++++++++++++++
 4 files changed, 328 insertions(+)
 create mode 100644 drivers/reset/reset-dct-zukimo-eth.h
 create mode 100644 drivers/reset/reset-dct-zukimo.c

diff --git a/drivers/reset/Kconfig b/drivers/reset/Kconfig
index e52761f03cab..bdece946ff53 100644
--- a/drivers/reset/Kconfig
+++ b/drivers/reset/Kconfig
@@ -66,6 +66,13 @@ config RESET_BRCMSTB_RESCAL
 	  This enables the RESCAL reset controller for SATA, PCIe0, or PCIe1 on
 	  BCM7216.
 
+config RESET_DCT_ZUKIMO
+	tristate "DCT Zukimo reset controller support"
+	depends on ARCH_ZUKIMO || COMPILE_TEST
+	default ARCH_ZUKIMO
+	help
+	  This enables the DCT Zukimo reset controller.
+
 config RESET_HSDK
 	bool "Synopsys HSDK Reset Driver"
 	depends on HAS_IOMEM
diff --git a/drivers/reset/Makefile b/drivers/reset/Makefile
index cf7599645bc6..eb5d9be6959a 100644
--- a/drivers/reset/Makefile
+++ b/drivers/reset/Makefile
@@ -10,6 +10,7 @@ obj-$(CONFIG_RESET_BCM6345) += reset-bcm6345.o
 obj-$(CONFIG_RESET_BERLIN) += reset-berlin.o
 obj-$(CONFIG_RESET_BRCMSTB) += reset-brcmstb.o
 obj-$(CONFIG_RESET_BRCMSTB_RESCAL) += reset-brcmstb-rescal.o
+obj-$(CONFIG_RESET_DCT_ZUKIMO) += reset-dct-zukimo.o
 obj-$(CONFIG_RESET_HSDK) += reset-hsdk.o
 obj-$(CONFIG_RESET_IMX7) += reset-imx7.o
 obj-$(CONFIG_RESET_INTEL_GW) += reset-intel-gw.o
diff --git a/drivers/reset/reset-dct-zukimo-eth.h b/drivers/reset/reset-dct-zukimo-eth.h
new file mode 100644
index 000000000000..f06895ae04b3
--- /dev/null
+++ b/drivers/reset/reset-dct-zukimo-eth.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2024 Dream Chip Technologies
+ *
+ * SPDX-License-Identifier: BSD
+ *
+ * Generated by sig2
+ */
+
+#ifndef __ETH_CRU__
+#define __ETH_CRU__
+
+#define ETH_MODULE_ID_REG 0x00000000
+#define ETH_CLKSEL_REG 0x00000004
+#define ETH_SWRESET_REG 0x00000008
+#define ETH_CLKEN_REG 0x0000000C
+
+/* ETH_MODULE_ID_REG */
+// Vendor ID
+#define DCT_ID_MASK 0xFF000000U
+#define DCT_ID_SHIFT 24U
+// Project Zukimo
+#define PROJECT_ID_MASK 0x00FF0000U
+#define PROJECT_ID_SHIFT 16U
+// Revision
+#define REVISION_MASK 0x0000FF00U
+#define REVISION_SHIFT 8U
+// Module ID
+#define MODULE_ID_MASK 0x000000FFU
+#define MODULE_ID_SHIFT 0U
+
+/* ETH_CLKSEL_REG */
+// (1) Select external 125MHz reference clock input from RGMII PHY.
+// (0) Select internal 125MHz reference clock (clk_gem125) from PLL
+#define CLKSEL_TX_MASK 0x00000001U
+#define CLKSEL_TX_BIT 0
+
+/* ETH_SWRESET_REG */
+// (0) software reset for GEM core clock domains
+#define SW_RESET_GEM_N_MASK 0x00000001U
+#define SW_RESET_GEM_N_BIT 0
+// (0) software reset for GEM RX clock domain
+#define SW_RESET_RX_N_MASK 0x00000002U
+#define SW_RESET_RX_N_BIT 1
+// (0) software reset for GEM TX clock domain
+#define SW_RESET_TX_N_MASK 0x00000004U
+#define SW_RESET_TX_N_BIT 2
+
+/* ETH_CLKEN_REG */
+// (1) clock enable for GEM core clock domains
+#define CLKEN_GEM_MASK 0x00000001U
+#define CLKEN_GEM_BIT 0
+// (1) clock enable for GEM RX clock domain
+#define CLKEN_RX_MASK 0x00000002U
+#define CLKEN_RX_BIT 1
+// (1) clock enable for GEM TX clock domain
+#define CLKEN_TX_MASK 0x00000004U
+#define CLKEN_TX_BIT 2
+
+#endif /* __ETH_CRU__ */
diff --git a/drivers/reset/reset-dct-zukimo.c b/drivers/reset/reset-dct-zukimo.c
new file mode 100644
index 000000000000..5f332279842d
--- /dev/null
+++ b/drivers/reset/reset-dct-zukimo.c
@@ -0,0 +1,261 @@
+/*
+ * reset-dct-zukimo.c, by Dream Chip
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/reset-controller.h>
+#include "reset-dct-zukimo-eth.h"
+
+struct dct_reset_ctrl_devdata {
+	u32 reg_offset_reset;
+	bool reset_active_low;
+	u32 reset_mask;
+	u32 reg_offset_clk_en;
+	bool clk_en_active_low;
+	u32 clk_en_mask;
+	u32 reg_offset_noc_idle;
+	bool noc_idle_active_low;
+	u32 noc_idle_mask;
+	u32 reg_offset_clk_sel;
+	u32 clk_sel_mask;
+	u32 clk_sel_value;
+};
+
+struct dct_reset_ctrl_data {
+	void __iomem *membase;
+	const struct dct_reset_ctrl_devdata *devdata;
+	struct reset_controller_dev	rcdev;
+};
+
+static inline struct dct_reset_ctrl_data *
+to_dct_reset_ctrl_data(struct reset_controller_dev *rcdev)
+{
+	return container_of(rcdev, struct dct_reset_ctrl_data, rcdev);
+}
+
+static int dct_reset_ctrl_assert(struct reset_controller_dev *rcdev,
+			       unsigned long id)
+{
+	struct dct_reset_ctrl_data *data = to_dct_reset_ctrl_data(rcdev);
+	u32 value;
+
+	if (data->devdata->clk_en_mask) {
+		value = readl(data->membase + data->devdata->reg_offset_clk_en);
+		if (data->devdata->clk_en_active_low) {
+			value |= data->devdata->clk_en_mask;
+		} else {
+			value &= ~data->devdata->clk_en_mask;
+		}
+		writel(value, data->membase + data->devdata->reg_offset_clk_en);
+	}
+
+	if (data->devdata->reset_mask) {
+		value = readl(data->membase + data->devdata->reg_offset_reset);
+		if (data->devdata->reset_active_low) {
+			value &= ~data->devdata->reset_mask;
+		} else {
+			value |= data->devdata->reset_mask;
+		}
+		writel(value, data->membase + data->devdata->reg_offset_reset);
+	}
+
+	if (data->devdata->noc_idle_mask) {
+		value = readl(data->membase + data->devdata->reg_offset_noc_idle);
+		if (data->devdata->noc_idle_active_low) {
+			value &= ~data->devdata->noc_idle_mask;
+		} else {
+			value |= data->devdata->noc_idle_mask;
+		}
+		writel(value, data->membase + data->devdata->reg_offset_noc_idle);
+	}
+
+	/* make sure the reset signal is active for at least 20us */
+	usleep_range(20, 100);
+
+	return 0;
+}
+
+static int dct_reset_ctrl_deassert(struct reset_controller_dev *rcdev,
+				 unsigned long id)
+{
+	struct dct_reset_ctrl_data *data = to_dct_reset_ctrl_data(rcdev);
+	u32 value;
+
+	if (data->devdata->noc_idle_mask) {
+		value = readl(data->membase + data->devdata->reg_offset_noc_idle);
+		if (data->devdata->noc_idle_active_low) {
+			value |= data->devdata->noc_idle_mask;
+		} else {
+			value &= ~data->devdata->noc_idle_mask;
+		}
+		writel(value, data->membase + data->devdata->reg_offset_noc_idle);
+	}
+
+	if (data->devdata->reset_mask) {
+		value = readl(data->membase + data->devdata->reg_offset_reset);
+		if (data->devdata->reset_active_low) {
+			value |= data->devdata->reset_mask;
+		} else {
+			value &= ~data->devdata->reset_mask;
+		}
+		writel(value, data->membase + data->devdata->reg_offset_reset);
+	}
+
+	if (data->devdata->clk_sel_mask) {
+		value = readl(data->membase + data->devdata->reg_offset_clk_sel);
+		value &= ~data->devdata->clk_sel_mask;
+		value |= data->devdata->clk_sel_value;
+		writel(value, data->membase + data->devdata->reg_offset_clk_sel);
+	}
+
+	if (data->devdata->clk_en_mask) {
+		value = readl(data->membase + data->devdata->reg_offset_clk_en);
+		if (data->devdata->clk_en_active_low) {
+			value &= ~data->devdata->clk_en_mask;
+		} else {
+			value |= data->devdata->clk_en_mask;
+		}
+		writel(value, data->membase + data->devdata->reg_offset_clk_en);
+	}
+
+	return 0;
+}
+
+static int dct_reset_ctrl_reset(struct reset_controller_dev *rcdev,
+				 unsigned long id)
+{
+	int res;
+
+	res = dct_reset_ctrl_assert(rcdev, id);
+	if (res)
+		return res;
+
+	return dct_reset_ctrl_deassert(rcdev, id);
+}
+
+static int dct_reset_ctrl_status(struct reset_controller_dev *rcdev,
+			       unsigned long id)
+{
+	struct dct_reset_ctrl_data *data = to_dct_reset_ctrl_data(rcdev);
+	u32 value;
+
+	if (data->devdata->reset_mask) {
+		value = readl(data->membase + data->devdata->reg_offset_reset) & data->devdata->reset_mask;
+		if ((data->devdata->reset_active_low) && (value != data->devdata->reset_mask)) {
+			return (int)true;
+		} else if ((!data->devdata->reset_active_low) && (value != 0)) {
+			return (int)true;
+		}
+	}
+
+	if (data->devdata->clk_en_mask) {
+		value = readl(data->membase + data->devdata->reg_offset_clk_en) & data->devdata->clk_en_mask;
+		if ((data->devdata->clk_en_active_low) && (value != data->devdata->clk_en_mask)) {
+			return (int)true;
+		} else if ((!data->devdata->clk_en_active_low) && (value != 0)) {
+			return (int)true;
+		}
+	}
+
+	if (data->devdata->noc_idle_mask) {
+		value = readl(data->membase + data->devdata->reg_offset_noc_idle) & data->devdata->noc_idle_mask;
+		if ((data->devdata->noc_idle_active_low) && (value != data->devdata->noc_idle_mask)) {
+			return (int)true;
+		} else if ((!data->devdata->noc_idle_active_low) && (value != 0)) {
+			return (int)true;
+		}
+	}
+
+	return (int)false;
+}
+
+static const struct reset_control_ops dct_reset_ctrl_ops = {
+	.assert		= dct_reset_ctrl_assert,
+	.deassert	= dct_reset_ctrl_deassert,
+	.reset		= dct_reset_ctrl_reset,
+	.status		= dct_reset_ctrl_status,
+};
+
+static const struct dct_reset_ctrl_devdata dct_eth_cru_mapping = {
+	.reg_offset_reset = ETH_SWRESET_REG,
+	.reset_active_low = true,
+	.reset_mask = SW_RESET_GEM_N_MASK | SW_RESET_RX_N_MASK | SW_RESET_TX_N_MASK,
+	.reg_offset_clk_en = ETH_CLKEN_REG,
+	.clk_en_active_low = false,
+	.clk_en_mask = CLKEN_GEM_MASK | CLKEN_RX_MASK | CLKEN_TX_MASK,
+	.reg_offset_clk_sel = ETH_CLKSEL_REG,
+	.clk_sel_mask = CLKSEL_TX_MASK,
+	.clk_sel_value = 0x0,
+};
+
+static const struct of_device_id dct_reset_ctrl_dt_ids[] = {
+	{ .compatible = "dct,eth-reset-ctrl",
+	  .data = &dct_eth_cru_mapping, },
+	{ /* sentinel */ },
+};
+
+static int dct_reset_ctrl_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	const struct dct_reset_ctrl_devdata *devdata;
+	struct dct_reset_ctrl_data *data;
+	void __iomem *membase;
+	struct resource *res;
+
+	devdata = of_device_get_match_data(dev);
+	if (!devdata) {
+		pr_err("%s: Unable to find of data\n", __func__);
+		return -EINVAL;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	membase = devm_ioremap_resource(dev, res);
+	if (IS_ERR(membase)) {
+		dev_err(dev, "ioremap failed\n");
+		return PTR_ERR(membase);
+	}
+
+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
+	if (!data) {
+		return -ENOMEM;
+	}
+
+	data->membase = membase;
+	data->devdata = devdata;
+	data->rcdev.owner = THIS_MODULE;
+	data->rcdev.nr_resets = 1;
+	data->rcdev.ops = &dct_reset_ctrl_ops;
+	data->rcdev.of_node = dev->of_node;
+
+	return devm_reset_controller_register(dev, &data->rcdev);
+}
+
+static struct platform_driver dct_zukimo_reset_driver = {
+	.probe	= dct_reset_ctrl_probe,
+	.driver = {
+		.name		= "dct_reset_ctrl",
+		.of_match_table	= dct_reset_ctrl_dt_ids,
+	},
+};
+module_platform_driver(dct_zukimo_reset_driver);
+
+MODULE_DESCRIPTION("DCT reset ctrl driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:reset-dct-zukimo");
-- 
2.34.1


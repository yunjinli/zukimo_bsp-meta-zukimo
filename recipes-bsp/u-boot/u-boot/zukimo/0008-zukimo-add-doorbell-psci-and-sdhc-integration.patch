From e2f24a57332e484182275c071301c212b7c6e78d Mon Sep 17 00:00:00 2001
From: Ralph Hempel <ralph.hempel@dreamchip.de>
Date: Fri, 16 Jun 2023 07:34:12 +0200
Subject: [PATCH 08/12] zukimo: add doorbell, psci and sdhc integration

Upstream-Status: Pending

---
 arch/arm/cpu/armv8/u-boot.lds                 |   37 +-
 arch/arm/mach-zukimo/Kconfig                  |    8 +
 arch/arm/mach-zukimo/Makefile                 |   13 +-
 .../mach-zukimo/include/alcatraz_memory_map.h |  201 ++
 .../alcatraz_zukimo_minimal_memory_map.h      |   93 +
 .../arm/mach-zukimo/include/zukimo_doorbell.h |   64 +
 arch/arm/mach-zukimo/include/zukimo_ipc.h     |   66 +
 arch/arm/mach-zukimo/include/zukimo_ipc_fsp.h |  104 ++
 arch/arm/mach-zukimo/include/zukimo_sema.h    |   29 +
 arch/arm/mach-zukimo/zukimo_cache.c           |   25 +
 arch/arm/mach-zukimo/zukimo_doorbell.c        |   96 +
 arch/arm/mach-zukimo/zukimo_ipc.c             |  213 +++
 arch/arm/mach-zukimo/zukimo_psci.c            |   54 +-
 arch/arm/mach-zukimo/zukimo_sema.c            |   71 +
 board/dct/zukimo/Kconfig                      |   30 +
 board/dct/zukimo/zukimo.c                     |    2 +
 board/dct/zukimo/zukimo.env                   |   13 +
 drivers/gpio/Kconfig                          |    6 +
 drivers/gpio/Makefile                         |    1 +
 drivers/gpio/dct_ipc_gpio.c                   |  219 +++
 drivers/mmc/Kconfig                           |   11 +
 drivers/mmc/Makefile                          |    1 +
 drivers/mmc/dct_sdhc.c                        | 1627 +++++++++++++++++
 include/dct/sd4hc_cqrs_regs.h                 |  960 ++++++++++
 include/dct/sd4hc_crs_regs.h                  |   40 +
 include/dct/sd4hc_hrs_regs.h                  |  501 +++++
 include/dct/sd4hc_srs_regs.h                  | 1248 +++++++++++++
 include/dct/sd4phy_ctb_regs.h                 |  100 +
 include/dct/sd4phy_dllphy_regs.h              |  469 +++++
 29 files changed, 6293 insertions(+), 9 deletions(-)
 create mode 100644 arch/arm/mach-zukimo/include/alcatraz_memory_map.h
 create mode 100644 arch/arm/mach-zukimo/include/alcatraz_zukimo_minimal_memory_map.h
 create mode 100644 arch/arm/mach-zukimo/include/zukimo_doorbell.h
 create mode 100644 arch/arm/mach-zukimo/include/zukimo_ipc.h
 create mode 100644 arch/arm/mach-zukimo/include/zukimo_ipc_fsp.h
 create mode 100644 arch/arm/mach-zukimo/include/zukimo_sema.h
 create mode 100644 arch/arm/mach-zukimo/zukimo_cache.c
 create mode 100644 arch/arm/mach-zukimo/zukimo_doorbell.c
 create mode 100644 arch/arm/mach-zukimo/zukimo_ipc.c
 create mode 100644 arch/arm/mach-zukimo/zukimo_sema.c
 create mode 100644 board/dct/zukimo/zukimo.env
 create mode 100644 drivers/gpio/dct_ipc_gpio.c
 create mode 100644 drivers/mmc/dct_sdhc.c
 create mode 100644 include/dct/sd4hc_cqrs_regs.h
 create mode 100644 include/dct/sd4hc_crs_regs.h
 create mode 100644 include/dct/sd4hc_hrs_regs.h
 create mode 100644 include/dct/sd4hc_srs_regs.h
 create mode 100644 include/dct/sd4phy_ctb_regs.h
 create mode 100644 include/dct/sd4phy_dllphy_regs.h

diff --git a/arch/arm/cpu/armv8/u-boot.lds b/arch/arm/cpu/armv8/u-boot.lds
index 43a80a460c..76bb6a6cde 100644
--- a/arch/arm/cpu/armv8/u-boot.lds
+++ b/arch/arm/cpu/armv8/u-boot.lds
@@ -41,6 +41,26 @@ SECTIONS
 		*(.text*)
 	}
 
+#ifdef CONFIG_SYS_HAS_IPC_AREA
+	.__ipc_start :
+	{
+	}
+
+	.__ipc_reserved CONFIG_IPC_AREA_BASE (NOLOAD) :
+		AT(ADDR(.__ipc_start) + SIZEOF(.__ipc_start))
+	{
+        .__ipc_reserved_start = .;
+		. = . + CONFIG_IPC_AREA_SIZE;
+        .__ipc_reserved_end = .;
+	}
+
+	. = LOADADDR(.__ipc_reserved);
+	.__ipc_end : AT(ADDR(.__ipc_end))
+	{
+		LONG(0x1d1071c);	/* Must output something to reset LMA */
+	}
+#endif
+
 #ifdef CONFIG_ARMV8_PSCI
 	.__secure_start :
 #ifndef CONFIG_ARMV8_SECURE_BASE
@@ -71,11 +91,16 @@ SECTIONS
 		*(._secure.data)
 	}
 
-	.secure_stack ADDR(.secure_data) + SIZEOF(.secure_data) (NOLOAD) :
+	.secure_uninitialized ADDR(.secure_data) + SIZEOF(.secure_data) (NOLOAD) : AT(LOADADDR(.secure_data) + SIZEOF(.secure_data))
+	{
+		*(._secure.uninitialized)
+	}
+
+	.secure_stack ADDR(.secure_uninitialized) + SIZEOF(.secure_uninitialized) (NOLOAD) :
 #ifdef __ARMV8_PSCI_STACK_IN_RAM
 		AT(ADDR(.secure_stack))
 #else
-		AT(LOADADDR(.secure_data) + SIZEOF(.secure_data))
+		AT(LOADADDR(.secure_uninitialized) + SIZEOF(.secure_uninitialized))
 #endif
 	{
 		KEEP(*(.__secure_stack_start))
@@ -88,7 +113,7 @@ SECTIONS
 	}
 
 #ifndef __ARMV8_PSCI_STACK_IN_RAM
-	. = LOADADDR(.secure_stack);
+	. = LOADADDR(.secure_uninitialized);
 #endif
 
 	.__secure_end : AT(ADDR(.__secure_end)) {
@@ -150,6 +175,12 @@ SECTIONS
 
 	. = ALIGN(8);
 
+#ifdef CONFIG_SYS_HAS_IPC_AREA
+#ifdef CONFIG_LINK_BSS_AREA_AFTER_IPC_AREA
+    . = .__ipc_reserved_end;
+#endif
+#endif
+
 	.bss_start : {
 		KEEP(*(.__bss_start));
 	}
diff --git a/arch/arm/mach-zukimo/Kconfig b/arch/arm/mach-zukimo/Kconfig
index 3d2c169833..b708dfa94a 100644
--- a/arch/arm/mach-zukimo/Kconfig
+++ b/arch/arm/mach-zukimo/Kconfig
@@ -1,3 +1,10 @@
+#
+# (C) Copyright 2023,
+# Dream Chip Technologies
+#
+# SPDX-License-Identifier: GPL-2.0+
+#
+
 if ARCH_ZUKIMO
 
 choice
@@ -8,6 +15,7 @@ config TARGET_ZUKIMO
 	bool "Dream Chip Technologie's Zukimo board"
 	select DCT_SERIAL
 	select SYS_HAS_ARMV8_SECURE_BASE
+	select SYS_HAS_IPC_AREA
 
 endchoice
 
diff --git a/arch/arm/mach-zukimo/Makefile b/arch/arm/mach-zukimo/Makefile
index 5abefcf6b2..8f762bcd07 100644
--- a/arch/arm/mach-zukimo/Makefile
+++ b/arch/arm/mach-zukimo/Makefile
@@ -1,5 +1,14 @@
 #
-# SPDX-License-Identifier:	GPL-2.0+
+# (C) Copyright 2023,
+# Dream Chip Technologies
 #
+# SPDX-License-Identifier: GPL-2.0+
+#
+
+obj-$(CONFIG_ARMV8_PSCI)	+= lowlevel.o
+obj-$(CONFIG_ARMV8_PSCI)	+= zukimo_doorbell.o
+obj-$(CONFIG_ARMV8_PSCI)	+= zukimo_ipc.o
+obj-$(CONFIG_ARMV8_PSCI)	+= zukimo_psci.o
+obj-$(CONFIG_ARMV8_PSCI)	+= zukimo_sema.o
 
-obj-$(CONFIG_ARMV8_PSCI)	+= lowlevel.o zukimo_psci.o
+obj-y                       += zukimo_cache.o
diff --git a/arch/arm/mach-zukimo/include/alcatraz_memory_map.h b/arch/arm/mach-zukimo/include/alcatraz_memory_map.h
new file mode 100644
index 0000000000..9a42985dbc
--- /dev/null
+++ b/arch/arm/mach-zukimo/include/alcatraz_memory_map.h
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2023 Dream Chip Technologies
+ *
+ * SPDX-License-Identifier: BSD
+ *
+ * Generated by sig2
+ */
+
+#ifndef __ALCATRAZ_MEMORY_MAP__
+#define __ALCATRAZ_MEMORY_MAP__
+
+// Internal R52 access
+#define ATCM_BASE 0x00000000u
+#define ATCM_SIZE 0x00020000u // 128 KB
+
+// Internal R52 access
+#define BTCM_BASE 0x00100000u
+#define BTCM_SIZE 0x00020000u // 128 KB
+
+// Internal R52 access
+#define CTCM_BASE 0x00200000u
+#define CTCM_SIZE 0x00020000u // 128 KB
+
+// External access via AXIS
+#define ATCM_EXT_BASE 0x01000000u
+#define ATCM_EXT_SIZE 0x00020000u // 128 KB
+
+// External access via AXIS
+#define BTCM_EXT_BASE 0x01100000u
+#define BTCM_EXT_SIZE 0x00020000u // 128 KB
+
+// External access via AXIS
+#define CTCM_EXT_BASE 0x01200000u
+#define CTCM_EXT_SIZE 0x00020000u // 128 KB
+
+// Internal FSP memory
+#define SRAM_BASE 0x02000000u
+#define SRAM_SIZE 0x00010000u // 64 KB
+
+// FSP's interrupt controller
+#define FSP_GIC_BASE 0x03000000u
+#define FSP_GIC_SIZE 0x00200000u // 2 MB
+
+// Safety Controller
+#define FSP_SCM_BASE 0x03200000u
+#define FSP_SCM_SIZE 0x00001000u // 4 KB
+
+// Clock & Reset
+#define FSP_CRU_BASE 0x03210000u
+#define FSP_CRU_SIZE 0x00001000u // 4 KB
+
+// SPP-PLL, embedded into FSP_CRU
+#define SPP_SPLL_BASE 0x03210800u
+#define SPP_SPLL_SIZE 0x00000800u // 2 KB
+
+// Timestamp Generator (R/W)
+#define TSCNT_RW_BASE 0x03220000u
+#define TSCNT_RW_SIZE 0x00001000u // 4 KB
+
+// DMA PL330 control (secure)
+#define DMA_SEC_BASE 0x03230000u
+#define DMA_SEC_SIZE 0x00001000u // 4 KB
+
+// DMA startup control
+#define DMA_CTL_BASE 0x03240000u
+#define DMA_CTL_SIZE 0x00001000u // 4 KB
+
+// SRAM control
+#define SRAM_CTL_BASE 0x03250000u
+#define SRAM_CTL_SIZE 0x00001000u // 4 KB
+
+// CryptoCell control (secure)
+#define CC_SEC_BASE 0x03260000u
+#define CC_SEC_SIZE 0x00004000u // 16 KB
+
+// PMBIST Controller
+#define PMC_BASE 0x03270000u
+#define PMC_SIZE 0x00010000u // 64 KB
+
+// SBIST Controller
+#define SBC_BASE 0x03280000u
+#define SBC_SIZE 0x00010000u // 64 KB
+
+// CycptoCell control (public)
+#define CC_PUB_BASE 0x03400000u
+#define CC_PUB_SIZE 0x00001000u // 4 KB
+
+// Timestamp Generator (read-only)
+#define TSCNT_RO_BASE 0x03410000u
+#define TSCNT_RO_SIZE 0x00001000u // 4 KB
+
+// Doorbells Application
+#define DB_APP_BASE 0x03420000u
+#define DB_APP_SIZE 0x00010000u // 64 KB
+
+// Doorbells FSP
+#define DB_FSP_BASE 0x03430000u
+#define DB_FSP_SIZE 0x00010000u // 64 KB
+
+// NOC Service registers (Firewalls)
+#define SERVICE_NOC_BASE 0x034E0000u
+#define SERVICE_NOC_SIZE 0x00010000u // 64 KB
+
+// NOC Service registers (Debug)
+#define DEBUG_NOC_BASE 0x034F0000u
+#define DEBUG_NOC_SIZE 0x00010000u // 64 KB
+
+// SPP OnChip Sensors (PVT)
+#define SPP_SENSORS_BASE 0x03620000u
+#define SPP_SENSORS_SIZE 0x00001000u // 4 KB
+
+// Peripheral GPIO
+#define SPP_GPIO_BASE 0x03630000u
+#define SPP_GPIO_SIZE 0x00001000u // 4 KB
+
+// IO Multiplexing
+#define SPP_IOMUX_BASE 0x03640000u
+#define SPP_IOMUX_SIZE 0x00001000u // 4 KB
+
+// SPI #0 (Cadence)
+#define SPP_SPI0_BASE 0x03650000u
+#define SPP_SPI0_SIZE 0x00000080u // 128 B
+
+// SPI #1 (SPIM_COM)
+#define SPP_SPI1_BASE 0x03660000u
+#define SPP_SPI1_SIZE 0x00001000u // 4 KB
+
+// UART #0
+#define SPP_UART0_BASE 0x03670000u
+#define SPP_UART0_SIZE 0x00000080u // 128 B
+
+// UART #1
+#define SPP_UART1_BASE 0x03680000u
+#define SPP_UART1_SIZE 0x00000080u // 128 B
+
+// I2C #0
+#define SPP_IIC0_BASE 0x03690000u
+#define SPP_IIC0_SIZE 0x00000080u // 128 B
+
+// I2C #1
+#define SPP_IIC1_BASE 0x036A0000u
+#define SPP_IIC1_SIZE 0x00000080u // 128 B
+
+// QSPI Flash: write/read to/from TX/RX FIFO
+#define QSPI_FIFO_BASE 0x03700000u
+#define QSPI_FIFO_SIZE 0x00001000u // 4 KB
+
+// QSPI Flash control
+#define SPP_QSPI_BASE 0x03710000u
+#define SPP_QSPI_SIZE 0x00001000u // 4 KB
+
+// SD4/eMMC Host
+#define SPP_SD4_BASE 0x03720000u
+#define SPP_SD4_SIZE 0x00002000u // 8 KB
+
+// Cadence sd4hc HRS
+#define SPP_SD4_HRS_BASE 0x03720000u
+#define SPP_SD4_HRS_SIZE 0x00000100u // 256 B
+
+// Cadence sd4hc SRS
+#define SPP_SD4_SRS_BASE 0x03720000u
+#define SPP_SD4_SRS_SIZE 0x00000080u // 128 B
+
+// Cadence sd4hc CRS
+#define SPP_SD4_CRS_BASE 0x03720000u
+#define SPP_SD4_CRS_SIZE 0x00000004u // 4 B
+
+// Cadence sd4hc CQRS
+#define SPP_SD4_CQRS_BASE 0x03720000u
+#define SPP_SD4_CQRS_SIZE 0x00000060u // 96 B
+
+// Gigabit Ethernet MAC
+#define SPP_GEM_BASE 0x03730000u
+#define SPP_GEM_SIZE 0x00001000u // 4 KB
+
+// Application CRU access
+#define APP_CRU_BASE 0x03800000u
+#define APP_CRU_SIZE 0x00001000u // 4 KB
+
+// Application PADGFG access
+#define APP_PADCFG_BASE 0x03810000u
+#define APP_PADCFG_SIZE 0x00001000u // 4 KB
+
+// Global Debug Access
+#define EXT_DBG_BASE 0x04000000u
+#define EXT_DBG_SIZE 0x00010000u // 64 KB
+
+// Boot ROM
+#define ROM_BASE 0x08000000u
+#define ROM_SIZE 0x00020000u // 128 KB
+
+// QSPI Flash memory mapped access
+#define SPP_RO_BASE 0x09000000u
+#define SPP_RO_SIZE 0x01000000u // 16 MB
+
+// Zukimo NOC access
+#define ZKI_NOC_BASE 0x10000000u
+#define ZKI_NOC_SIZE 0xF0000000u // 3840 MB
+
+
+#endif /* __ALCATRAZ_MEMORY_MAP__ */
diff --git a/arch/arm/mach-zukimo/include/alcatraz_zukimo_minimal_memory_map.h b/arch/arm/mach-zukimo/include/alcatraz_zukimo_minimal_memory_map.h
new file mode 100644
index 0000000000..314d4437c4
--- /dev/null
+++ b/arch/arm/mach-zukimo/include/alcatraz_zukimo_minimal_memory_map.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2023 Dream Chip Technologies
+ *
+ * SPDX-License-Identifier: BSD
+ *
+ * Generated by sig2
+ */
+
+#ifndef __ALCATRAZ_ZUKIMO_MINIMAL_MEMORY_MAP__
+#define __ALCATRAZ_ZUKIMO_MINIMAL_MEMORY_MAP__
+
+// Zukimo I2C0
+#define ZUK_I2C0_BASE 0x22020000u
+#define ZUK_I2C0_SIZE 0x00001000u // 4 KB
+
+// Zukimo I2C1
+#define ZUK_I2C1_BASE 0x22030000u
+#define ZUK_I2C1_SIZE 0x00001000u // 4 KB
+
+// Zukimo I2C2
+#define ZUK_I2C2_BASE 0x22040000u
+#define ZUK_I2C2_SIZE 0x00001000u // 4 KB
+
+// Zukimo UART0
+#define ZUK_UART0_BASE 0x22080000u
+#define ZUK_UART0_SIZE 0x00001000u // 4 KB
+
+// Zukimo UART1
+#define ZUK_UART1_BASE 0x22090000u
+#define ZUK_UART1_SIZE 0x00001000u // 4 KB
+
+// Zukimo top CRU
+#define ZUK_SCU_BASE 0x03800000u
+#define ZUK_SCU_SIZE 0x00001000u // 4 KB
+
+// Zukimo top PADCFG
+#define ZUK_PADCFG_BASE 0x03810000u
+#define ZUK_PADCFG_SIZE 0x00001000u // 4 KB
+
+// Zukimo Onchip SRAM w/ ECC
+#define ZUK_IMEM_SRAM_BASE 0x10000000u
+#define ZUK_IMEM_SRAM_SIZE 0x00080000u // 512 KB
+
+// Zukimo doorbells APU
+#define ZUK_IMEM_DB_APU_BASE 0x10100000u
+#define ZUK_IMEM_DB_APU_SIZE 0x00010000u // 64 KB
+
+// Zukimo doorbells NPU
+#define ZUK_IMEM_DB_NPU_BASE 0x10110000u
+#define ZUK_IMEM_DB_NPU_SIZE 0x00010000u // 64 KB
+
+// Zukimo doorbells NNA
+#define ZUK_IMEM_DB_NNA_BASE 0x10120000u
+#define ZUK_IMEM_DB_NNA_SIZE 0x00010000u // 64 KB
+
+// Zukimo semaphore
+#define ZUK_IMEM_SEMA_BASE 0x10130000u
+#define ZUK_IMEM_SEMA_SIZE 0x00010000u // 64 KB
+
+// Zukimo Control/Status Area
+#define ZUK_CSA_BASE 0x20000000u
+#define ZUK_CSA_SIZE 0x06000000u // 96 MB
+
+// Zukimo Onchip SRAM Control
+#define ZUK_CSA_IMEM_SRAM_CTRL_BASE 0x20020000u
+#define ZUK_CSA_IMEM_SRAM_CTRL_SIZE 0x00001000u // 4 KB
+
+// Zukimo DDR Controller 0
+#define ZUK_CSA_DDR0_CTRL_BASE 0x24100000u
+#define ZUK_CSA_DDR0_CTRL_SIZE 0x00020000u // 128 KB
+
+// Zukimo DDR Controller 1
+#define ZUK_CSA_DDR1_CTRL_BASE 0x24120000u
+#define ZUK_CSA_DDR1_CTRL_SIZE 0x00020000u // 128 KB
+
+// Zukimo DDR PHY Controller 0
+#define ZUK_CSA_DDR0_PHY_BASE 0x25000000u
+#define ZUK_CSA_DDR0_PHY_SIZE 0x00800000u // 8 MB
+
+// Zukimo DDR PHY Controller 1
+#define ZUK_CSA_DDR1_PHY_BASE 0x25800000u
+#define ZUK_CSA_DDR1_PHY_SIZE 0x00800000u // 8 MB
+
+// Zukimo APU Control
+#define ZUK_APU_SCU_BASE 0x37000000u
+#define ZUK_APU_SCU_SIZE 0x00010000u // 64 KB
+
+// Zukimo DDR RAM (low)
+#define ZUK_DDR_RAM_LOW_BASE 0x80000000u
+#define ZUK_DDR_RAM_LOW_SIZE 0x80000000u // 2 GB
+
+
+#endif /* __ALCATRAZ_ZUKIMO_MINIMAL_MEMORY_MAP__ */
diff --git a/arch/arm/mach-zukimo/include/zukimo_doorbell.h b/arch/arm/mach-zukimo/include/zukimo_doorbell.h
new file mode 100644
index 0000000000..b246969b7f
--- /dev/null
+++ b/arch/arm/mach-zukimo/include/zukimo_doorbell.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2023 Dream Chip Technologies
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/**
+ * @file
+ *
+ * The zukimo_doorbell unit implements doorbell services.
+ */
+
+#ifndef __ZUKIMO_DOORBELL_H__
+#define __ZUKIMO_DOORBELL_H__
+
+#include <common.h>
+#include <alcatraz_memory_map.h>
+
+// number of interrupt groups and interrupts per group
+#define DB_APP_NGROUPS 8
+#define DB_APP_NIRQS 4
+
+#define DB_FSP_NGROUPS 8
+#define DB_FSP_NIRQS 6
+
+// Address offsets inside each interrupt group
+#define ADDR_DB_IRQSETID 0x000
+#define ADDR_DB_IRQCLRID 0x004
+#define ADDR_DB_IRQPRIOID 0x008
+#define ADDR_DB_IRQSETVEC 0x010
+#define ADDR_DB_IRQCLRVEC 0x014
+#define ADDR_DB_IRQSTATVEC 0x018
+
+// Address offsets overflow interrupt registers
+#define ADDR_DB_OVISM_START (0x100)
+#define ADDR_DB_OVRIS_START (0x200)
+#define ADDR_DB_OVMIS_START (0x300)
+#define ADDR_DB_OVCLR_START (0x400)
+
+#define ADDR_DB_OVISM(_base, _group) (_base + ADDR_DB_OVISM_START + 4 * (_group))
+#define ADDR_DB_OVRIS(_base, _group) (_base + ADDR_DB_OVRIS_START + 4 * (_group))
+#define ADDR_DB_OVMIS(_base, _group) (_base + ADDR_DB_OVMIS_START + 4 * (_group))
+#define ADDR_DB_OVCLR(_base, _group) (_base + ADDR_DB_OVCLR_START + 4 * (_group))
+
+// APU interface
+#define DB_APU_GROUP_MISC 0
+#define DB_APU_GROUP_CORE_ON 1
+#define DB_APU_GROUP_CORE_OFF 2
+
+// FSP interface
+#define DB_FSP_GROUP_MISC 0
+#define DB_FSP_GROUP_CORE_ON 1
+#define DB_FSP_GROUP_CORE_OFF 2
+
+uint32_t db_get_groups(const uintptr_t base);
+uint32_t db_get_nirqs(const uintptr_t base);
+
+int db_ring(const uintptr_t base, const uint32_t grp, const uint32_t nirq);
+int db_ring_storm(const uintptr_t base, const uint32_t ngroups, const uint32_t nirqs);
+
+int db_ack_ringer(const uintptr_t base, const uint32_t grp, const uint32_t nirq);
+bool db_test_ringer(const uintptr_t base, const uint32_t grp, const uint32_t nirq);
+
+#endif // __ZUKIMO_DOORBELL_H__
diff --git a/arch/arm/mach-zukimo/include/zukimo_ipc.h b/arch/arm/mach-zukimo/include/zukimo_ipc.h
new file mode 100644
index 0000000000..19e1494cf5
--- /dev/null
+++ b/arch/arm/mach-zukimo/include/zukimo_ipc.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2023 Dream Chip Technologies
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/**
+ * @file
+ *
+ * The dct_ipc unit implements inter process communication services.
+ */
+
+#ifndef __ZUKIMO_IPC_H__
+#define __ZUKIMO_IPC_H__
+
+#include <common.h>
+#include <alcatraz_memory_map.h>
+
+#define IPC_HDR_LEN 12
+#define IPC_DATA_LEN 116
+#define IPC_MSG_LEN (IPC_HDR_LEN + IPC_DATA_LEN)
+
+#define IPC_CMD_NOP 0x00000042
+#define IPC_CMD_ACK 0x80000000
+
+enum IPC_NODE { IPC_FSP, IPC_APU, IPC_MAX_NODES };
+
+struct ipc_db_cfg {
+	uintptr_t base;
+	uint32_t grp;
+	uint32_t nirq;
+};
+
+struct ipc_sema_cfg {
+	uintptr_t base;
+	uint32_t grp;
+	uint32_t nsema;
+	uint32_t nsaid;
+};
+
+struct ipc_header {
+	/** payload size */
+	uint32_t len;
+	/** command */
+	uint32_t cmd;
+	/** error code */
+	uint32_t error;
+};
+
+/*
+ * Only callable within ._secure.text section
+ * */
+int ipc_send(enum IPC_NODE dst, struct ipc_header *msg);
+struct ipc_header *ipc_read(enum IPC_NODE src);
+int ipc_send_receive(enum IPC_NODE dst, struct ipc_header *tx,
+		struct ipc_header *rx, const uint32_t max_rx_data_len);
+
+/*
+ * Callable outside the ._secure.text section
+ * */
+int do_ipc_send(enum IPC_NODE dst, struct ipc_header *msg);
+struct ipc_header *do_ipc_read(enum IPC_NODE src);
+int do_ipc_send_receive(enum IPC_NODE dst, struct ipc_header *tx,
+		struct ipc_header *rx, const uint32_t max_rx_data_len);
+
+#endif // __ZUKIMO_IPC_H__
diff --git a/arch/arm/mach-zukimo/include/zukimo_ipc_fsp.h b/arch/arm/mach-zukimo/include/zukimo_ipc_fsp.h
new file mode 100644
index 0000000000..254704b4dc
--- /dev/null
+++ b/arch/arm/mach-zukimo/include/zukimo_ipc_fsp.h
@@ -0,0 +1,104 @@
+ /*
+ * (C) Copyright 2023,
+ * Dream Chip Technologies
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+/**
+ * @file
+ *
+ * The zukimo_ipc unit implements inter process communication services towards the FSP.
+ */
+
+#ifndef __ZUKIMO_IPC_FSP_H__
+#define __ZUKIMO_IPC_FSP_H__
+
+#include <zukimo_ipc.h>
+
+#define IPC_FSP_APU_CPU_STATE 0x00000001
+#define IPC_FSP_SYSTEM_RESET 0x00000002
+#define IPC_FSP_SYSTEM_POWEROFF 0x00000003
+
+#define IPC_FSP_SPP_GPIO_STATE 0x00000010
+
+#define IPC_FSP_SPP_GPIO_CONFIGURE 0x00000011
+// #define IPC_FSP_SPP_GPIO_GET_RAW          0x00000012
+#define IPC_FSP_SPP_GPIO_SET_MASKED_RAW 0x00000013
+#define IPC_FSP_SPP_GPIO_SET_BITS_RAW 0x00000014
+#define IPC_FSP_SPP_GPIO_CLR_BITS_RAW 0x00000015
+#define IPC_FSP_SPP_GPIO_TOGGLE_BITS 0x00000016
+#define IPC_FSP_SPP_GPIO_GET_RAW 0x00000017
+#define IPC_FSP_SPP_GPIO_GET_CFG 0x00000018
+
+#define IPC_FSP_SD_PIN 0x00000030
+
+struct ipc_fsp_apu_cpu_state {
+	struct ipc_header hdr;
+	uint8_t cpu;
+	uint8_t enable;
+};
+
+struct ipc_fsp_system_reset {
+	struct ipc_header hdr;
+};
+
+struct ipc_fsp_system_poweroff {
+	struct ipc_header hdr;
+};
+
+struct ipc_fsp_spp_gpio_state {
+    struct ipc_header hdr;
+    uint8_t pin;
+    uint8_t enable;
+};
+
+struct ipc_fsp_spp_gpio_configure {
+    struct ipc_header hdr;
+    uint8_t pin;
+    uint32_t flags;
+};
+
+struct ipc_fsp_spp_gpio_set_masked_raw {
+    struct ipc_header hdr;
+    uint32_t mask;
+    uint32_t value;
+};
+
+struct ipc_fsp_spp_gpio_set_bits_raw {
+    struct ipc_header hdr;
+    uint32_t pins;
+};
+
+struct ipc_fsp_spp_gpio_clr_bits_raw {
+    struct ipc_header hdr;
+    uint32_t pins;
+};
+
+struct ipc_fsp_spp_gpio_toggle_bits {
+    struct ipc_header hdr;
+    uint32_t pins;
+};
+
+struct ipc_fsp_sd_pin {
+	struct ipc_header hdr;
+	uint8_t pin;
+	uint8_t enable;
+};
+
+struct ipc_fsp_spp_gpio_get_raw {
+    struct ipc_header hdr;
+    union {
+        uint32_t rx_value;
+    };
+};
+
+struct ipc_fsp_spp_gpio_get_cfg {
+	struct ipc_header hdr;
+	union {
+		uint8_t tx_pin;
+		uint32_t rx_flags;
+	};
+};
+
+#endif // __ZUKIMO_IPC_FSP_H__
diff --git a/arch/arm/mach-zukimo/include/zukimo_sema.h b/arch/arm/mach-zukimo/include/zukimo_sema.h
new file mode 100644
index 0000000000..384a9d17bc
--- /dev/null
+++ b/arch/arm/mach-zukimo/include/zukimo_sema.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2023 Dream Chip Technologies
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/**
+ * @file
+ *
+ * The zukimo_sema unit implements hardware semaphore services.
+ */
+
+#ifndef __ZUKIMO_SEMA_H__
+#define __ZUKIMO_SEMA_H__
+
+#include <common.h>
+#include <alcatraz_memory_map.h>
+
+uint32_t sema_get_groups(const uintptr_t base);
+uint32_t sema_get_nsema(const uintptr_t base);
+
+int sema_lock(const uintptr_t base, const uint32_t grp, const uint32_t nsema);
+int sema_release(const uintptr_t base, const uint32_t grp, const uint32_t nsema);
+int sema_status(const uintptr_t base, const uint32_t grp, const uint32_t nsema);
+
+#define SEMA_FREE 0
+#define SEMA_LOCKED 1
+
+#endif // __ZUKIMO_SEMA_H__
diff --git a/arch/arm/mach-zukimo/zukimo_cache.c b/arch/arm/mach-zukimo/zukimo_cache.c
new file mode 100644
index 0000000000..53fe6e5237
--- /dev/null
+++ b/arch/arm/mach-zukimo/zukimo_cache.c
@@ -0,0 +1,25 @@
+ /*
+ * (C) Copyright 2023,
+ * Dream Chip Technologies
+ * Axel Ludszuweit, <Axel.ludszuweit@dreamchip.de>
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/cache.h>
+#include <cpu_func.h>
+#include <asm/system.h>
+
+#define IPC_MEMORY_ADDR (uint8_t *)(CONFIG_IPC_AREA_BASE)
+#define IPC_MEMORY_SIZE (CONFIG_IPC_AREA_SIZE)
+
+void enable_caches(void)
+{
+#if CONFIG_NR_DRAM_BANKS >= 1
+	icache_enable();
+	dcache_enable();
+	mmu_set_region_dcache_behaviour(IPC_MEMORY_ADDR,
+			IPC_MEMORY_SIZE, DCACHE_OFF);
+#endif
+}
diff --git a/arch/arm/mach-zukimo/zukimo_doorbell.c b/arch/arm/mach-zukimo/zukimo_doorbell.c
new file mode 100644
index 0000000000..446979abcd
--- /dev/null
+++ b/arch/arm/mach-zukimo/zukimo_doorbell.c
@@ -0,0 +1,96 @@
+ /*
+ * (C) Copyright 2023,
+ * Dream Chip Technologies
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <asm/io.h>
+#include <asm/secure.h>
+#include "zukimo_doorbell.h"
+
+// Number of doorbell groups (1..15)
+#define NGROUPS_MASK 0x0000FF00U
+#define NGROUPS_SHIFT 8U
+// Number of interrupts per doorbell group (1..32)
+#define NIRQS_MASK 0x000000FFU
+#define NIRQS_SHIFT 0U
+
+#define ADDR_DB_FEATURE 0x0004
+
+__secure uint32_t db_get_groups(const uintptr_t base)
+{
+	return ((readl(base + ADDR_DB_FEATURE) & NGROUPS_MASK) >> NGROUPS_SHIFT);
+}
+
+__secure uint32_t db_get_nirqs(const uintptr_t base)
+{
+	return ((readl(base + ADDR_DB_FEATURE) & NIRQS_MASK) >> NIRQS_SHIFT);
+}
+
+__secure int db_ring(const uintptr_t base, const uint32_t grp, const uint32_t nirq)
+{
+	uintptr_t grp_addr;
+
+	if (grp > db_get_groups(base) || nirq > db_get_nirqs(base)) {
+		return -1;
+	}
+
+	grp_addr = base + 0x1000 + (0x1000 * grp);
+	writel(BIT(nirq), grp_addr + ADDR_DB_IRQSETVEC);
+
+	while(readl(grp_addr + ADDR_DB_IRQSTATVEC) & BIT(nirq)) {
+		;
+	}
+
+	return 0;
+}
+
+__secure bool db_test_ringer(const uintptr_t base, const uint32_t grp, const uint32_t nirq)
+{
+	uintptr_t grp_addr;
+
+	if (grp > db_get_groups(base) || nirq > db_get_nirqs(base)) {
+		return false;
+	}
+
+	grp_addr = base + 0x1000 + (0x1000 * grp);
+
+	return !!(readl(grp_addr + ADDR_DB_IRQSTATVEC) & BIT(nirq));
+}
+
+__secure int db_ack_ringer(const uintptr_t base, const uint32_t grp, const uint32_t nirq)
+{
+	uintptr_t grp_addr;
+
+	if (grp > db_get_groups(base) || nirq > db_get_nirqs(base)) {
+		return -1;
+	}
+
+	grp_addr = base + 0x1000 + (0x1000 * grp);
+
+	writel(nirq, grp_addr + ADDR_DB_IRQCLRID);
+
+	return 0;
+}
+
+__secure int db_ring_storm(const uintptr_t base, const uint32_t ngroups, const uint32_t nirqs)
+{
+	uintptr_t grp_addr;
+	uint32_t mask;
+	int grp;
+
+	if (ngroups > db_get_groups(base) || nirqs > db_get_nirqs(base)) {
+		return -1;
+	}
+
+	for (grp = 0; grp < ngroups; grp++) {
+		grp_addr = base + 0x1000 + (0x1000 * grp);
+
+		// set all irqs of group with one write (setvec)
+		mask = (1 << nirqs) - 1;
+		writel(mask, grp_addr + ADDR_DB_IRQSETVEC);
+	}
+
+	return 0;
+}
diff --git a/arch/arm/mach-zukimo/zukimo_ipc.c b/arch/arm/mach-zukimo/zukimo_ipc.c
new file mode 100644
index 0000000000..9f2594a024
--- /dev/null
+++ b/arch/arm/mach-zukimo/zukimo_ipc.c
@@ -0,0 +1,213 @@
+ /*
+ * (C) Copyright 2023,
+ * Dream Chip Technologies
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/secure.h>
+
+#include <alcatraz_memory_map.h>
+#include <alcatraz_zukimo_minimal_memory_map.h>
+#include <zukimo_doorbell.h>
+#include <zukimo_ipc.h>
+#include <zukimo_sema.h>
+
+#define ZUK_IPC_FSP_GROUP 0
+#define ZUK_IPC_FSP_NSEMA 0
+
+#define ZUK_IPC_APP_GROUP 1
+#define ZUK_IPC_APP_NSEMA 0
+
+#define IPC_MEMORY (uint8_t *)(CONFIG_IPC_AREA_BASE)
+
+struct ipc_db_cfg db_cfg[IPC_MAX_NODES] __secure_data = {
+	{
+		.base = DB_FSP_BASE,
+		.grp = DB_FSP_GROUP_MISC,
+		.nirq = 0,
+	},
+	{
+		.base = DB_APP_BASE,
+		.grp = DB_APU_GROUP_MISC,
+		.nirq = 0,
+	}
+};
+
+struct ipc_sema_cfg sema_cfg[IPC_MAX_NODES] __secure_data = {
+	{
+		.base = ZUK_IMEM_SEMA_BASE,
+		.grp = ZUK_IPC_FSP_GROUP,
+		.nsema = ZUK_IPC_FSP_NSEMA,
+		.nsaid = 0x00,
+	},
+	{
+		.base = ZUK_IMEM_SEMA_BASE,
+		.grp = ZUK_IPC_APP_GROUP,
+		.nsema = ZUK_IPC_APP_NSEMA,
+		.nsaid = 0x08,
+	}
+};
+
+__secure void memcpy_secure(void* target, void *src, size_t len)
+{
+	uint8_t *s = (uint8_t *) src;
+	uint8_t *t = (uint8_t *) target;
+
+	while (len--) {
+		*t++ = *s++;
+	}
+}
+
+__secure int ipc_send(enum IPC_NODE dst, struct ipc_header *tx)
+{
+	int ret;
+	struct ipc_header *remote;
+	struct ipc_sema_cfg *sema;
+	struct ipc_db_cfg *db;
+	uint32_t cmd, sts, err;
+
+	if (tx == NULL || tx->len > IPC_DATA_LEN || dst >= IPC_MAX_NODES) {
+		return -EINVAL;
+	}
+
+	sema = &sema_cfg[dst];
+	db = &db_cfg[dst];
+
+	sts = sema_status(sema->base, sema->grp, sema->nsema);
+	if (sts & SEMA_LOCKED) {
+		return -EBUSY;
+	}
+
+	ret = sema_lock(sema->base, sema->grp, sema->nsema);
+	if (ret < 0) {
+		return ret;
+	}
+
+	sts = sema_status(sema->base, sema->grp, sema->nsema);
+	if (!(sts & SEMA_LOCKED)) {
+		return -EBUSY;
+	}
+
+	remote = (struct ipc_header *)(IPC_MEMORY + dst * IPC_MSG_LEN);
+	memcpy_secure(remote, tx, sizeof(struct ipc_header) + tx->len);
+	remote->error = 0;
+
+	db_ring(db->base, db->grp, db->nirq);
+
+	cmd = remote->cmd;
+	err = remote->error;
+
+	ret = sema_release(sema->base, sema->grp, sema->nsema);
+	if (ret < 0) {
+		return ret;
+	}
+
+	if (!(cmd & IPC_CMD_ACK)) {
+		ret = -1;
+	}
+
+	return err ? err : ret;
+}
+
+__secure struct ipc_header *ipc_read(enum IPC_NODE src)
+{
+	struct ipc_header *hdr;
+
+	if (src >= IPC_MAX_NODES) {
+		return NULL;
+	}
+
+	hdr = (struct ipc_header *)(IPC_MEMORY + src * IPC_MSG_LEN);
+
+	return hdr;
+}
+
+__secure int ipc_send_receive(enum IPC_NODE dst, struct ipc_header *tx, struct ipc_header *rx,
+		const uint32_t max_rx_data_len)
+{
+	int ret;
+	struct ipc_header *remote;
+	struct ipc_sema_cfg *sema;
+	struct ipc_db_cfg *db;
+	uint32_t cmd, sts, err;
+
+	if (tx == NULL || tx->len > IPC_DATA_LEN || dst >= IPC_MAX_NODES ||
+		max_rx_data_len > IPC_DATA_LEN) {
+		return -EINVAL;
+	}
+
+	sema = &sema_cfg[dst];
+	db = &db_cfg[dst];
+
+	sts = sema_status(sema->base, sema->grp, sema->nsema);
+	if (sts & SEMA_LOCKED) {
+		return -EBUSY;
+	}
+
+	ret = sema_lock(sema->base, sema->grp, sema->nsema);
+	if (ret < 0) {
+		return ret;
+	}
+
+	sts = sema_status(sema->base, sema->grp, sema->nsema);
+	if (!(sts & SEMA_LOCKED)) {
+		return -EBUSY;
+	}
+
+	remote = (struct ipc_header *)(IPC_MEMORY + dst * IPC_MSG_LEN);
+	memcpy_secure(remote, tx, sizeof(struct ipc_header) + tx->len);
+	remote->error = 0;
+
+	db_ring(db->base, db->grp, db->nirq);
+
+	cmd = remote->cmd;
+	err = remote->error;
+	if ((cmd & IPC_CMD_ACK) && rx) {
+		uint32_t rx_len = remote->len;
+		if (err) {
+			rx_len = 0;
+		} else if (remote->len > max_rx_data_len) {
+			rx_len = max_rx_data_len;
+		}
+		memcpy_secure(rx, remote, sizeof(struct ipc_header) + rx_len);
+		rx->len = rx_len;
+	}
+
+	ret = sema_release(sema->base, sema->grp, sema->nsema);
+	if (ret < 0) {
+		return ret;
+	}
+
+	if (!(cmd & IPC_CMD_ACK)) {
+		ret = -1;
+	}
+
+	return err ? err : ret;
+}
+
+/*
+ * The following functions with do_ prefix are copies from the functions
+ * without do_ prefix.
+ * These functions live not in the ._secure.text segment and therefore
+ * exist before ._secure.text is filled by armv8_setup_psci().
+ * Furthermore their addresses are correctly handled after relocation
+ */
+
+int do_ipc_send(enum IPC_NODE dst, struct ipc_header *tx)
+{
+	return(secure_ram_addr(ipc_send)(dst, tx));
+}
+
+struct ipc_header *do_ipc_read(enum IPC_NODE src)
+{
+	return(secure_ram_addr(ipc_read)(src));
+}
+
+int do_ipc_send_receive(enum IPC_NODE dst, struct ipc_header *tx, struct ipc_header *rx,
+		const uint32_t max_rx_data_len)
+{
+	return(secure_ram_addr(ipc_send_receive)(dst, tx, rx, max_rx_data_len));
+}
+
diff --git a/arch/arm/mach-zukimo/zukimo_psci.c b/arch/arm/mach-zukimo/zukimo_psci.c
index 431332035c..61aa7e569b 100644
--- a/arch/arm/mach-zukimo/zukimo_psci.c
+++ b/arch/arm/mach-zukimo/zukimo_psci.c
@@ -12,6 +12,8 @@
 #include <asm/secure.h>
 #include <asm/system.h>
 #include <debug_uart.h>
+#include "zukimo_doorbell.h"
+#include "zukimo_ipc_fsp.h"
 
 //#define DEBUG_PSCI 1
 #if defined(CONFIG_DEBUG_UART) && defined(DEBUG_PSCI)
@@ -51,28 +53,72 @@ void gicv3_rdistif_off(void);
 
 __secure static s32 do_cpu_on_power_on(const u32 cpu)
 {
-	// TODO: add your implementation here
+	int ret;
+	struct ipc_fsp_apu_cpu_state msg = {
+		.hdr.len = sizeof(struct ipc_fsp_apu_cpu_state) - sizeof(struct ipc_header ),
+		.hdr.cmd = IPC_FSP_APU_CPU_STATE,
+		.cpu = cpu,
+		.enable = 1,
+	};
+
+	ret = ipc_send(IPC_FSP, &msg.hdr);
+	if(ret) {
+		psci_ascii_out("ipc_send failed");
+		return ARM_PSCI_RET_INTERNAL_FAILURE;
+	}
 
 	return ARM_PSCI_RET_SUCCESS;
 }
 
 __secure static s32 do_cpu_on_power_off(const u32 cpu)
 {
-	// TODO: add your implementation here
+	int ret;
+	struct ipc_fsp_apu_cpu_state msg = {
+		.hdr.len = sizeof(struct ipc_fsp_apu_cpu_state) - sizeof(struct ipc_header ),
+		.hdr.cmd = IPC_FSP_APU_CPU_STATE,
+		.cpu = cpu,
+		.enable = 0,
+	};
+
+	ret = ipc_send(IPC_FSP, &msg.hdr);
+	if(ret) {
+		psci_ascii_out("ipc_send failed");
+		return ARM_PSCI_RET_INTERNAL_FAILURE;
+	}
 
 	return ARM_PSCI_RET_SUCCESS;
 }
 
 __secure static s32 do_system_reset(void)
 {
-	// TODO: add your implementation here
+	int ret;
+	struct ipc_fsp_system_reset msg = {
+		.hdr.len = 0,
+		.hdr.cmd = IPC_FSP_SYSTEM_RESET,
+	};
+
+	ret = ipc_send(IPC_FSP, &msg.hdr);
+	if(ret) {
+		psci_ascii_out("ipc_send failed");
+		return ARM_PSCI_RET_INTERNAL_FAILURE;
+	}
 
 	return ARM_PSCI_RET_SUCCESS;
 }
 
 __secure static s32 do_system_off(void)
 {
-	// TODO: add your implementation here
+	int ret;
+	struct ipc_fsp_system_poweroff msg = {
+		.hdr.len = 0,
+		.hdr.cmd = IPC_FSP_SYSTEM_POWEROFF,
+	};
+
+	ret = ipc_send(IPC_FSP, &msg.hdr);
+	if(ret) {
+		psci_ascii_out("ipc_send failed");
+		return ARM_PSCI_RET_INTERNAL_FAILURE;
+	}
 
 	return ARM_PSCI_RET_SUCCESS;
 }
diff --git a/arch/arm/mach-zukimo/zukimo_sema.c b/arch/arm/mach-zukimo/zukimo_sema.c
new file mode 100644
index 0000000000..abc9c2e1f5
--- /dev/null
+++ b/arch/arm/mach-zukimo/zukimo_sema.c
@@ -0,0 +1,71 @@
+ /*
+ * (C) Copyright 2023,
+ * Dream Chip Technologies
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#include <asm/io.h>
+#include <asm/secure.h>
+#include "alcatraz_memory_map.h"
+#include "zukimo_sema.h"
+
+// Number of groups (1..15)
+#define NGROUPS_MASK 0x0000FF00U
+#define NGROUPS_SHIFT 8U
+// Number of semaphores per group (1..32)
+#define NSEMA_MASK 0x000000FFU
+#define NSEMA_SHIFT 0U
+
+#define ADDR_SEMA_FEATURE 0x0004
+
+__secure uint32_t sema_get_groups(const uintptr_t base)
+{
+	return ((readl(base + ADDR_SEMA_FEATURE) & NGROUPS_MASK) >> NGROUPS_SHIFT);
+}
+
+__secure uint32_t sema_get_nsema(const uintptr_t base)
+{
+	return ((readl(base + ADDR_SEMA_FEATURE) & NSEMA_MASK) >> NSEMA_SHIFT);
+}
+
+__secure int sema_lock(const uintptr_t base, const uint32_t grp, const uint32_t nsema)
+{
+	uintptr_t sema_addr;
+
+	if (grp > sema_get_groups(base) || nsema > sema_get_nsema(base)) {
+		return -EINVAL;
+	}
+
+	sema_addr = base + 0x1000 + (0x1000 * grp) + 4 * nsema;
+
+	return readl(sema_addr) ? -EBUSY : 0;
+}
+
+__secure int sema_release(const uintptr_t base, const uint32_t grp, const uint32_t nsema)
+{
+	uintptr_t sema_addr;
+
+	if (grp > sema_get_groups(base) || nsema > sema_get_nsema(base)) {
+		return -EINVAL;
+	}
+
+	sema_addr = base + 0x1000 + (0x1000 * grp) + 4 * nsema;
+
+	writel(1, sema_addr);
+
+	return 0;
+}
+
+__secure int sema_status(const uintptr_t base, const uint32_t grp, const uint32_t nsema)
+{
+	uintptr_t sema_addr;
+
+	if (grp > sema_get_groups(base) || nsema > sema_get_nsema(base)) {
+		return -EINVAL;
+	}
+
+	sema_addr = 0x1080 + (0x1000 * grp) + 4 * nsema;
+
+	return readl(base + sema_addr);
+}
diff --git a/board/dct/zukimo/Kconfig b/board/dct/zukimo/Kconfig
index c57a3b21e7..aba3c2571b 100644
--- a/board/dct/zukimo/Kconfig
+++ b/board/dct/zukimo/Kconfig
@@ -1,3 +1,10 @@
+#
+# (C) Copyright 2023,
+# Dream Chip Technologies
+#
+# SPDX-License-Identifier: GPL-2.0+
+#
+
 if TARGET_ZUKIMO
 
 config SYS_BOARD
@@ -12,4 +19,27 @@ config SYS_CONFIG_NAME
 config LNX_KRNL_IMG_TEXT_OFFSET_BASE
     default 0x0
 
+config SYS_HAS_IPC_AREA
+    bool "Reserve shared memory for IPC between APU and Alcatraz"
+    default yes
+
+config IPC_AREA_BASE
+    hex "Address of shared memory for IPC between APU and alcatraz"
+    depends on SYS_HAS_IPC_AREA
+    default 0x10068000
+
+config IPC_AREA_SIZE
+    hex "Size of shared memory for IPC between APU and alcatraz"
+    depends on SYS_HAS_IPC_AREA
+    default 0x8000
+
+config LINK_BSS_AREA_AFTER_IPC_AREA
+    bool "Place BSS section after IPC memory area"
+    depends on SYS_HAS_IPC_AREA
+    help
+        Zukimo platform has a gap in the internal memory which is used for IPC.
+        This option enables locating the bss area after the IPC gap.
+        You might want to try this if the linker starts complaining about overlapping bss and ipc sections.
+        By default the bss section is placed before the IPC gap.
+
 endif
diff --git a/board/dct/zukimo/zukimo.c b/board/dct/zukimo/zukimo.c
index f72b55b6d2..0b770e45d1 100644
--- a/board/dct/zukimo/zukimo.c
+++ b/board/dct/zukimo/zukimo.c
@@ -19,6 +19,7 @@
 #include <dm/platform_data/dct_uart.h>
 #include <asm/armv8/mmu.h>
 #include <asm/system.h>
+#include <asm/secure.h>
 
 static struct mm_region zukimo_mem_map[] = {
 	{
@@ -141,6 +142,7 @@ void *board_fdt_blob_setup(int *err)
 
 void reset_cpu(void)
 {
+    secure_ram_addr(psci_system_reset)();
 }
 
 /*
diff --git a/board/dct/zukimo/zukimo.env b/board/dct/zukimo/zukimo.env
new file mode 100644
index 0000000000..1b1fd97e03
--- /dev/null
+++ b/board/dct/zukimo/zukimo.env
@@ -0,0 +1,13 @@
+ /*
+ * (C) Copyright 2023,
+ * Dream Chip Technologies
+ * Axel Ludszuweit, <Axel.ludszuweit@dreamchip.de>
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+load_kernel=fatload mmc 0 ${kernel_addr_r} IMAGE.BIN
+load_rootfs=fatload mmc 0 ${ramdisk_addr_r} ROOTFS.BIN
+load_dtb=fatload mmc 0 ${fdt_addr_r} DTB.BIN
+bootdelay=5
+
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 7d5ddbdee0..4312d1569b 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -641,4 +641,10 @@ config ADP5585_GPIO
 	help
 	  Support ADP5585 GPIO expander.
 
+config DCT_IPC_GPIO
+    bool "Support for the Dreamchip IPC GPIO driver"
+	depends on DM_GPIO
+    help
+	  Support Dreamchip IPC GPIO driver
+
 endif
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 1e81e36962..f877a087d5 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -73,3 +73,4 @@ obj-$(CONFIG_SLG7XL45106_I2C_GPO)	+= gpio_slg7xl45106.o
 obj-$(CONFIG_$(SPL_TPL_)TURRIS_OMNIA_MCU)	+= turris_omnia_mcu.o
 obj-$(CONFIG_FTGPIO010)		+= ftgpio010.o
 obj-$(CONFIG_ADP5585_GPIO)	+= adp5585_gpio.o
+obj-$(CONFIG_DCT_IPC_GPIO)	+= dct_ipc_gpio.o
diff --git a/drivers/gpio/dct_ipc_gpio.c b/drivers/gpio/dct_ipc_gpio.c
new file mode 100644
index 0000000000..7704bfb53f
--- /dev/null
+++ b/drivers/gpio/dct_ipc_gpio.c
@@ -0,0 +1,219 @@
+/*
+ * (C) Copyright 2023,
+ * Dream Chip Technologies
+ * Axel Ludszuweit, <axel.ludszuweit@dreamchip.de>
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+/* Simple U-Boot driver for the SCT_IPC_GPIO */
+
+#include <zukimo_ipc_fsp.h>
+#include <asm/gpio.h>
+#include <dm.h>
+#include <dt-bindings/gpio/gpio.h>
+
+
+// got from ./zephyr/include/zephyr/drivers/gpio.h
+#define GPIO_OUTPUT_ALCATRAZ (1U << 17)
+#define GPIO_INPUT_ALCATRAZ  (1U << 16)
+
+#define MAX_NR_OF_PINS       32
+
+
+struct dct_ipc_gpio_plat {
+	uint32_t ngpios;
+};
+
+struct dct_ipc_gpio_privdata {
+};
+
+static int dct_ipc_gpio_set_value(struct udevice *dev, unsigned offset,
+                 int value)
+{
+	if (MAX_NR_OF_PINS <= offset) {
+		debug("%s: pin %x >= %x\n",  __func__, offset, MAX_NR_OF_PINS);
+		return -EINVAL;
+	}
+	int rc = 0;
+	const uint32_t pins = 1U << offset;
+	if (value != 0) {
+		struct ipc_fsp_spp_gpio_set_bits_raw gpio_set_bits_raw;
+		memset(&gpio_set_bits_raw, 0x00, sizeof(gpio_set_bits_raw));
+		gpio_set_bits_raw.hdr.cmd = IPC_FSP_SPP_GPIO_SET_BITS_RAW;
+		gpio_set_bits_raw.hdr.len =
+			sizeof(struct ipc_fsp_spp_gpio_set_bits_raw) - sizeof(struct ipc_header);
+		gpio_set_bits_raw.pins = pins;
+		rc = do_ipc_send(IPC_FSP, (struct ipc_header *)&gpio_set_bits_raw);
+	} else {
+		struct ipc_fsp_spp_gpio_clr_bits_raw gpio_clr_bits_raw;
+		memset(&gpio_clr_bits_raw, 0x00, sizeof(gpio_clr_bits_raw));
+		gpio_clr_bits_raw.hdr.cmd = IPC_FSP_SPP_GPIO_CLR_BITS_RAW;
+		gpio_clr_bits_raw.hdr.len =
+			sizeof(struct ipc_fsp_spp_gpio_clr_bits_raw) - sizeof(struct ipc_header);
+		gpio_clr_bits_raw.pins = pins;
+		rc = do_ipc_send(IPC_FSP, (struct ipc_header *)&gpio_clr_bits_raw);
+	}
+
+	return rc;
+}
+
+static int dct_ipc_gpio_get_value(struct udevice *dev, unsigned offset)
+{
+	int rc = (MAX_NR_OF_PINS > offset) ? (0) : (-EINVAL);
+	if (0 == rc) {
+		struct ipc_fsp_spp_gpio_get_raw tx_gpio_get_raw;
+		struct ipc_fsp_spp_gpio_get_raw rx_gpio_get_raw;
+		memset(&tx_gpio_get_raw, 0x00, sizeof(tx_gpio_get_raw));
+		memset(&rx_gpio_get_raw, 0x00, sizeof(rx_gpio_get_raw));
+		tx_gpio_get_raw.hdr.cmd = IPC_FSP_SPP_GPIO_GET_RAW;
+		tx_gpio_get_raw.hdr.len =
+			sizeof(struct ipc_fsp_spp_gpio_get_raw) - sizeof(struct ipc_header);
+		const uint32_t max_rx_data_len = sizeof(rx_gpio_get_raw.rx_value);
+		rc = do_ipc_send_receive(IPC_FSP, (struct ipc_header *)&tx_gpio_get_raw,
+				(struct ipc_header *)&rx_gpio_get_raw, max_rx_data_len);
+		if (0 == rc) {
+			rc = (0 != (rx_gpio_get_raw.rx_value & (1U << offset))) ? (1): (0);
+		}
+	}
+
+	return rc;
+}
+
+static int dct_ipc_gpio_get_function(struct udevice *dev, unsigned offset)
+{
+    int rc = (MAX_NR_OF_PINS > offset) ? 0 : (GPIOF_UNKNOWN);
+    if (0 == rc) {
+        struct ipc_fsp_spp_gpio_get_cfg tx_gpio_get_cfg;
+        struct ipc_fsp_spp_gpio_get_cfg rx_gpio_get_cfg;
+        memset(&tx_gpio_get_cfg, 0x00, sizeof(tx_gpio_get_cfg));
+        memset(&rx_gpio_get_cfg, 0x00, sizeof(rx_gpio_get_cfg));
+        tx_gpio_get_cfg.hdr.cmd = IPC_FSP_SPP_GPIO_GET_CFG;
+        tx_gpio_get_cfg.tx_pin = offset;
+        tx_gpio_get_cfg.hdr.len =
+            sizeof(struct ipc_fsp_spp_gpio_get_cfg) - sizeof(struct ipc_header);
+        const uint32_t max_rx_data_len = sizeof(rx_gpio_get_cfg.rx_flags);
+        rc = do_ipc_send_receive(IPC_FSP, (struct ipc_header *)&tx_gpio_get_cfg,
+                (struct ipc_header *)&rx_gpio_get_cfg, max_rx_data_len);
+		if (0 > rc) {
+			rc = GPIOF_UNKNOWN;
+		} else {
+			switch ((GPIO_INPUT_ALCATRAZ | GPIO_OUTPUT_ALCATRAZ) & rx_gpio_get_cfg.rx_flags) {
+				case GPIO_INPUT_ALCATRAZ:
+					rc = GPIOF_INPUT;
+					break;
+				case GPIO_OUTPUT_ALCATRAZ:
+					rc = GPIOF_OUTPUT;
+					break;
+				default:
+					rc = GPIOF_UNKNOWN;
+					break;
+			}
+		}
+    }
+
+	return rc;
+}
+
+static int dct_ipc_gpio_direction_output(struct udevice *dev, unsigned offset,
+                    int value)
+{
+	if (MAX_NR_OF_PINS <= offset) {
+		debug("%s: pin %x >= %d\n",  __func__, offset, MAX_NR_OF_PINS);
+		return -EINVAL;
+	}
+	int rc = 0;
+	struct ipc_fsp_spp_gpio_configure gpio_configure;
+	memset(&gpio_configure, 0x00, sizeof(gpio_configure));
+	gpio_configure.hdr.cmd = IPC_FSP_SPP_GPIO_CONFIGURE;
+	gpio_configure.hdr.len =
+		sizeof(struct ipc_fsp_spp_gpio_configure) - sizeof(struct ipc_header);
+	gpio_configure.pin = offset;
+	gpio_configure.flags = GPIO_OUTPUT_ALCATRAZ;
+	rc = do_ipc_send(IPC_FSP, (struct ipc_header *)&gpio_configure);
+
+	return 0;
+}
+
+static int dct_ipc_gpio_direction_input(struct udevice *dev, unsigned offset)
+{
+	if (MAX_NR_OF_PINS <= offset) {
+		debug("%s: pin %x >= %x\n",  __func__, offset, MAX_NR_OF_PINS);
+		return -EINVAL;
+	}
+	int rc = 0;
+	struct ipc_fsp_spp_gpio_configure gpio_configure;
+	memset(&gpio_configure, 0x00, sizeof(gpio_configure));
+	gpio_configure.hdr.cmd = IPC_FSP_SPP_GPIO_CONFIGURE;
+	gpio_configure.hdr.len =
+		sizeof(struct ipc_fsp_spp_gpio_configure) - sizeof(struct ipc_header);
+	gpio_configure.pin = offset;
+	gpio_configure.flags = GPIO_INPUT_ALCATRAZ;
+	rc = do_ipc_send(IPC_FSP, (struct ipc_header *)&gpio_configure);
+
+	return 0;
+}
+
+static int dct_ipc_gpio_xlate(struct udevice *dev, struct gpio_desc *desc,
+                 struct ofnode_phandle_args *args)
+{
+	if (2 != args->args_count) {
+		debug("%s: argc: %x != 2\n" , __func__, args->args_count);
+		return -EINVAL;
+	}
+
+	desc->offset = args->args[0];
+	desc->flags = (args->args[1] & GPIO_ACTIVE_LOW) ? GPIO_ACTIVE_LOW : 0;
+
+	if (MAX_NR_OF_PINS <= desc->offset) {
+		debug("%s: desc->offset %x >= %x\n",  __func__, desc->offset, MAX_NR_OF_PINS);
+		return -EINVAL;
+	}
+
+	debug("%s: offset = %x, flags %lx\n", __func__, desc->offset, desc->flags);
+
+    return 0;
+}
+
+static const struct dm_gpio_ops dct_ipc_gpio_ops = {
+    .direction_input = dct_ipc_gpio_direction_input,
+    .direction_output = dct_ipc_gpio_direction_output,
+    .get_value = dct_ipc_gpio_get_value,
+    .set_value = dct_ipc_gpio_set_value,
+    .get_function = dct_ipc_gpio_get_function,
+    .xlate = dct_ipc_gpio_xlate,
+};
+
+static int dct_ipc_gpio_probe(struct udevice *dev)
+{
+	struct gpio_dev_priv* const uc_priv = dev_get_uclass_priv(dev);
+	struct dct_ipc_gpio_plat* const plat = dev_get_plat(dev);
+
+
+	uc_priv->gpio_count = plat->ngpios;
+    return 0;
+}
+
+static int dct_ipc_gpio_of_to_plat(struct udevice *dev)
+{
+	struct dct_ipc_gpio_plat* const plat = dev_get_plat(dev);
+	plat->ngpios = dev_read_u32_default(dev, "ngpios", MAX_NR_OF_PINS);
+    return 0;
+}
+
+static const struct udevice_id dct_ipc_gpio_ids[] = {
+    { .compatible = "dct,dct_ipc_gpio", .data = 0 },
+    { /* sentinel */ }
+};
+
+
+U_BOOT_DRIVER(dct_ipc_gpio) = {
+    .name = "dct_ipc_gpio",
+    .id = UCLASS_GPIO,
+    .ops = &dct_ipc_gpio_ops,
+    .of_match = dct_ipc_gpio_ids,
+    .of_to_plat = dct_ipc_gpio_of_to_plat,
+    .probe = dct_ipc_gpio_probe,
+    .plat_auto  = sizeof(struct dct_ipc_gpio_plat),
+    .priv_auto  = sizeof(struct dct_ipc_gpio_privdata),
+};
diff --git a/drivers/mmc/Kconfig b/drivers/mmc/Kconfig
index 878f867c62..5d4e22a90f 100644
--- a/drivers/mmc/Kconfig
+++ b/drivers/mmc/Kconfig
@@ -565,6 +565,17 @@ config MMC_SDHCI_CADENCE
 
 	  If unsure, say N.
 
+config MMC_DCT_SDHC
+	bool "Support for the Dreamchip SDHC driver"
+	depends on BLK && DM_MMC
+	depends on OF_CONTROL
+	help
+	  This selects the Dreamchip SDHC driver for Cadence IP.
+
+	  If you have a controller with this interface, say Y here.
+
+	  If unsure, say N.
+
 config MMC_SDHCI_AM654
 	bool "SDHCI Controller on TI's Am654 devices"
 	depends on ARCH_K3
diff --git a/drivers/mmc/Makefile b/drivers/mmc/Makefile
index 3dc757108d..45bd576ca7 100644
--- a/drivers/mmc/Makefile
+++ b/drivers/mmc/Makefile
@@ -84,3 +84,4 @@ obj-$(CONFIG_RENESAS_SDHI)		+= tmio-common.o renesas-sdhi.o
 obj-$(CONFIG_MMC_BCM2835)		+= bcm2835_sdhost.o
 obj-$(CONFIG_MMC_MTK)			+= mtk-sd.o
 obj-$(CONFIG_MMC_SDHCI_F_SDH30)		+= f_sdh30.o
+obj-$(CONFIG_MMC_DCT_SDHC) += dct_sdhc.o
diff --git a/drivers/mmc/dct_sdhc.c b/drivers/mmc/dct_sdhc.c
new file mode 100644
index 0000000000..fd6ce6c7a8
--- /dev/null
+++ b/drivers/mmc/dct_sdhc.c
@@ -0,0 +1,1627 @@
+ /*
+ * (C) Copyright 2023,
+ * Dream Chip Technologies
+ * Axel Ludszuweit, <Axel.ludszuweit@dreamchip.de>
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+/* Simple U-Boot driver for the SDHC Cadence IP used in Zukimo*/
+
+#include <common.h>
+//#include <cpu_func.h>
+#include <dm.h>
+#include <errno.h>
+#include <log.h>
+//#include <malloc.h>
+#include <mmc.h>
+#include <sdhci.h>
+//#include <asm/cache.h>
+//#include <linux/bitops.h>
+//#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/compat.h>
+//#include <linux/dma-mapping.h>
+//#include <phys2bus.h>
+//#include <power/regulator.h>
+
+#include <dct/sd4hc_srs_regs.h>
+#include <dct/sd4hc_hrs_regs.h>
+#include <dct/sd4hc_crs_regs.h>
+#include <dct/sd4hc_cqrs_regs.h>
+#include <dct/sd4phy_dllphy_regs.h>
+#include <dct/sd4phy_ctb_regs.h>
+
+// ---------------------------------------------------------
+// ---------------------------------------------------------
+// ------------- Defines -----------------------------------
+// ---------------------------------------------------------
+
+#define SDHCI_SD4HC_HRS(dev)		 ( (Sd4hcHrsRegister_t*)	 (((dct_sdhc_priv_t *)dev_get_priv(dev))->base_addr) )
+#define SDHCI_SD4HC_SRS(dev)		 ( (Sd4hcSrsRegister_t*)	 (((dct_sdhc_priv_t *)dev_get_priv(dev))->base_addr) )
+#define SDHCI_SD4HC_CRS(dev)		 ( (Sd4hcCrsRegister_t*)	 (((dct_sdhc_priv_t *)dev_get_priv(dev))->base_addr) )
+#define SDHCI_SD4HC_CQRS(dev)		 ( (Sd4hcCqrsRegister_t*)	 (((dct_sdhc_priv_t *)dev_get_priv(dev))->base_addr) )
+#define SDHCI_SDPHY_DLL(dev)		 ( (Sd4phyDllphyRegister_t*) (((dct_sdhc_priv_t *)dev_get_priv(dev))->base_addr) )
+#define SDHCI_SDPHY_CTB(dev)		 ( (Sd4phyCtbRegister_t*)	 (((dct_sdhc_priv_t *)dev_get_priv(dev))->base_addr) )
+
+// ---------------------------------------------------------
+
+#define CLR_ALL_IRQ_MASK		    \
+	(SD4HC_SRS_SRS12__CC_MASK	  | \
+	 SD4HC_SRS_SRS12__TC_MASK	  | \
+	 SD4HC_SRS_SRS12__BGE_MASK	  | \
+	 SD4HC_SRS_SRS12__DMAINT_MASK | \
+	 SD4HC_SRS_SRS12__BWR_MASK	  | \
+	 SD4HC_SRS_SRS12__BRR_MASK	  | \
+	 SD4HC_SRS_SRS12__CIN_MASK	  | \
+	 SD4HC_SRS_SRS12__CR_MASK	  | \
+	 SD4HC_SRS_SRS12__ECT_MASK	  | \
+	 SD4HC_SRS_SRS12__ECCRC_MASK  | \
+	 SD4HC_SRS_SRS12__ECEB_MASK   | \
+	 SD4HC_SRS_SRS12__ECI_MASK	  | \
+	 SD4HC_SRS_SRS12__EDT_MASK	  | \
+	 SD4HC_SRS_SRS12__EDCRC_MASK  | \
+	 SD4HC_SRS_SRS12__EDEB_MASK   | \
+	 SD4HC_SRS_SRS12__ECL_MASK	  | \
+	 SD4HC_SRS_SRS12__EAC_MASK	  | \
+	 SD4HC_SRS_SRS12__EADMA_MASK  | \
+	 SD4HC_SRS_SRS12__ERSP_MASK)
+
+// ---------------------------------------------------------
+
+#define CMD_LINE_ERR_MSK          \
+	(SD4HC_SRS_SRS12__ECT_MASK   |\
+	 SD4HC_SRS_SRS12__ECCRC_MASK |\
+	 SD4HC_SRS_SRS12__ECEB_MASK  |\
+	 SD4HC_SRS_SRS12__ECI_MASK)
+
+#define DAT_LINE_ERR_MSK          \
+	(SD4HC_SRS_SRS12__EDT_MASK   |\
+	 SD4HC_SRS_SRS12__EDCRC_MASK |\
+	 SD4HC_SRS_SRS12__EDEB_MASK  |\
+	 SD4HC_SRS_SRS12__ECL_MASK)
+
+#define ERR_MASK                  \
+	(CMD_LINE_ERR_MSK            |\
+	 DAT_LINE_ERR_MSK            |\
+	 SD4HC_SRS_SRS12__EAC_MASK   |\
+	 SD4HC_SRS_SRS12__EADMA_MASK |\
+	 SD4HC_SRS_SRS12__ERSP_MASK)
+
+// ---------------------------------------------------------
+
+#define WAIT_FOR_SDCARD_CMD_COMPLETE_WAIT_MICROSECONDS        1000UL
+#define WAIT_FOR_SDCARD_CMD_COMPLETE_SLEEP_MICROSECONDS         10UL
+
+#define WAIT_FOR_SDCARD_CMD_AVAILABLE_WAIT_MICROSECONDS       5000UL
+#define WAIT_FOR_SDCARD_CMD_AVAILABLE_SLEEP_MICROSECONDS        10UL
+
+#define WAIT_FOR_SDCARD_CMD_COMPLETED_WAIT_MICROSECONDS   10000000UL
+#define WAIT_FOR_SDCARD_CMD_COMPLETED_SLEEP_MICROSECONDS        10UL
+
+#define WAIT_FOR_SDCARD_INHIBIT_WAIT_MICROSECONDS         10000000UL
+#define WAIT_FOR_SDCARD_INHIBIT_SLEEP_MICROSECONDS              10UL
+
+#define WAIT_FOR_SW_RESET_COMPLETE_WAIT_MICROSECONDS          1000UL
+#define WAIT_FOR_SW_RESET_COMPLETE_SLEEP_MICROSECONDS           10UL
+
+#define WAIT_FOR_PHY_RELEASE_WAIT_MICROSECONDS                1000UL
+#define WAIT_FOR_PHY_RELEASE_SLEEP_MICROSECONDS                 10UL
+
+#define WAIT_FOR_INTERNAL_CLOCK_STABLE_WAIT_MICROSECONDS      1000UL
+#define WAIT_FOR_INTERNAL_CLOCK_STABLE_SLEEP_MICROSECONDS       10UL
+
+#define WAIT_FOR_BRE_BWE_WAIT_MICROSECONDS                10000000UL
+#define WAIT_FOR_BRE_BWE_SLEEP_MICROSECONDS                     10UL
+
+#define WAIT_FOR_TRANSFER_COMPLETE_WAIT_MICROSECONDS      10000000UL
+#define WAIT_FOR_TRANSFER_COMPLETE_SLEEP_MICROSECONDS           10UL
+// ---------------------------------------------------------
+
+#define MIN_FREQUENCY                                        400000
+#define MAX_FREQUENCY                                      25000000
+
+// ---------------------------------------------------------
+
+#define CHECK_FUNC(func)											\
+	{																\
+		const int rc = func;										\
+		if (0 != rc) {												\
+			log_err("%s, %d: error %d\n", __FILE__, __LINE__, rc);	\
+			return (rc);											\
+		}															\
+	}
+
+// ---------------------------------------------------------
+// ------------- Types -------------------------------------
+// ---------------------------------------------------------
+
+enum cmd_type_e {
+	CMD_TYPE_NORMAL_CMD = 0,
+	CMD_TYPE_SUSPEND_CMD = 1,
+	CMD_TYPE_RESUME_CMD = 2, // not used
+	CMD_TYPE_ABORT_CMD = 3,
+};
+typedef enum cmd_type_e cmd_type_t;
+
+enum response_type_select_e {
+	RESPONSE_TYPE_SELECT_NO_RESPONSE = 0,
+	RESPONSE_TYPE_SELECT_136BIT_RESPONSE = 1,
+	RESPONSE_TYPE_SELECT_048BIT_RESPONSE = 2,
+	RESPONSE_TYPE_SELECT_048BIT_RESPONSE_WITH_BUSY = 3,
+};
+typedef enum response_type_select_e response_type_select_t;
+
+enum response_type_e {
+	RESPONSE_TYPE_R1_SD_MEMORY = 0,
+	RESPONSE_TYPE_R5_SD_IO = 1,
+};
+typedef enum response_type_e response_type_t;
+
+enum auto_cmd_type_e {
+	AUT0_CMD_DISABLE = 0,
+	AUT0_CMD_12 = 1,
+	AUT0_CMD_23 = 2,
+	AUT0_CMD_AUTO_SELECT = 3,
+};
+typedef enum auto_cmd_type_e auto_cmd_type_t;
+
+enum block_select_type_e {
+	BLOCK_SELECT_TYPE_SINGLE_BLOCK = 0,
+	BLOCK_SELECT_TYPE_MULTI_BLOCK = 1,
+};
+typedef enum block_select_type_e block_select_type_t;
+
+enum data_transfer_direction_s {
+	DATA_TRANSFER_DIRECTION_WRITE = 0,
+	DATA_TRANSFER_DIRECTION_READ = 1,
+};
+typedef enum data_transfer_direction_s data_transfer_direction_t;
+
+struct cmd_transfer_mode_s {
+	uint32_t cmd_idx;
+	cmd_type_t cmd_type;
+	uint32_t data_present_select;
+	uint32_t cmd_index_check_enable;
+	uint32_t cmd_crc_check_enable;
+	uint32_t sub_cmd_flag;
+	response_type_select_t response_type_select;
+	uint32_t response_data[4];
+	uint32_t response_interrupt_disable;
+	uint32_t response_error_check_enable;
+	response_type_t response_type;
+	block_select_type_t block_select;
+	data_transfer_direction_t data_transfer_direction;
+	auto_cmd_type_t auto_cmd;
+	uint32_t block_cnt_enable;
+	uint32_t dma_enable;
+	uint32_t cmd_arg;
+	bool use_irq;
+	bool use_dma;
+	bool high_capacity;
+	uint64_t wait_for_sdcard_cmd_available_wait_us;
+	uint64_t wait_for_sdcard_cmd_available_sleep_us;
+	uint64_t wait_for_sdcard_cmd_completed_wait_us;
+	uint64_t wait_for_sdcard_cmd_completed_sleep_us;
+	uint32_t retries;
+	uint32_t irq_mask;
+};
+typedef struct cmd_transfer_mode_s cmd_transfer_mode_t;
+
+// ---------------------------------------------------------
+
+struct dct_sdhc_plat {
+	struct mmc_config cfg;
+	struct mmc		  mmc;
+};
+typedef struct dct_sdhc_plat dct_sdhc_plat_t;
+
+// ---------------------------------------------------------
+
+struct dct_sdhc_priv {
+	struct mutex        device_mutex;
+	uint32_t            sys_clk_hz;
+	uint32_t            bus_width;
+	bool                use_dma;
+	bool                no_1_8_v;
+	uint32_t            freq_hz;
+	enum mmc_voltage    signal_voltage;
+	enum bus_mode       selected_mode;
+	void __iomem*	    base_addr;
+};
+typedef struct dct_sdhc_priv dct_sdhc_priv_t;
+
+// ---------------------------------------------------------
+// ------------- Forward declarations of static functions  -
+// ---------------------------------------------------------
+//
+
+static void writel_slice(const uint32_t value, uint32_t* const reg,
+		const uint32_t mask, const uint32_t shift);
+static uint32_t readl_slice(const uint32_t* const reg,
+		const uint32_t mask, const uint32_t shift);
+static int enter_critical_section(struct udevice *dev, const uint32_t sleep_us, const uint32_t timeout_us);
+static int leave_critical_section(struct udevice *dev);
+static int dct_sdhc_enable_irqs(const struct udevice *dev, const uint32_t irq_mask);
+static int dct_sdhc_disable_all_irqs(const struct udevice *dev);
+static int dct_sdhc_clr_irqs(const struct udevice *dev, const uint32_t irq_mask);
+static int dct_sdhc_wait_for_irq(const struct udevice *dev,
+		cmd_transfer_mode_t *const cmd_transfer_mode);
+static int dct_sdhc_init_priv(dct_sdhc_priv_t* const priv);
+static int dct_sdhc_init_cmd_transfer_mode(const struct udevice* const dev,
+		cmd_transfer_mode_t *const cmd_transfer_mode);
+static int dct_sdhc_reset_dat_lines(const struct udevice *const dev);
+static int dct_sdhc_reset_cmd_line(const struct udevice *const dev);
+static int dct_sdhc_error_recovery(const struct udevice *const dev);
+static int dct_sdhc_do_send_cmd(const struct udevice* const dev,
+		cmd_transfer_mode_t *const cmd_transfer_mode);
+static int dct_sdhc_card_dma_transfer(const struct udevice *dev,
+		cmd_transfer_mode_t *const cmd_transfer_mode,
+		struct mmc_data *const data);
+static int dct_sdhc_card_pio_transfer(const struct udevice *dev,
+		cmd_transfer_mode_t *const cmd_transfer_mode,
+		struct mmc_data *const data);
+#ifndef __UBOOT__
+static int install_irq_handler(const struct udevice* const dev);
+#endif
+static int init_pins(const struct udevice* const dev);
+static int dct_sdhc_init_data(struct udevice* const dev);
+static int dct_sdhc_reset_host(const struct udevice *const dev);
+static uint32_t dct_sdhc_read_phy_reg(const struct udevice *const dev, volatile const uint32_t* const reg_ptr);
+static void dct_sdhc_write_phy_reg(const struct udevice *const dev, const uint32_t data, volatile uint32_t* const reg_ptr);
+static uint32_t dct_sdhc_read_ctb_reg(const struct udevice *const dev, volatile const uint32_t* const reg_ptr);
+static void dct_sdhc_write_ctb_reg(const struct udevice *const dev, const uint32_t data, volatile uint32_t* const reg_ptr);
+static int dct_sdhc_reset_phy(const struct udevice *const dev, const bool reset);
+static int dct_sdhc_init_phy(const struct udevice *const dev);
+static int dct_sdhc_set_bus_width(const struct udevice *const dev);
+static int dct_sdhc_enable_all_flags(const struct udevice *const dev);
+static int dct_sdhc_set_clk(const struct udevice *dev);
+static int dct_sdhc_set_signal_voltage(struct udevice* const dev);
+static int dct_sdhc_set_bus_mode(struct udevice* const dev);
+static int dct_sdhc_deferred_probe(struct udevice *dev);
+static int dct_sdhc_reinit(struct udevice *dev);
+static int dct_sdhc_send_command(struct udevice *dev, struct mmc_cmd *cmd,
+		struct mmc_data *data);
+static int dct_sdhc_set_ios(struct udevice *dev);
+static int dct_sdhc_get_cd(struct udevice *dev);
+static int dct_sdhc_execute_tuning(struct udevice *dev, uint opcode);
+static int dct_sdhc_wait_dat0(struct udevice *dev, int state,
+		int timeout_us);
+static int dct_sdhc_host_power_cycle(struct udevice *dev);
+static int dct_sdhc_bind(struct udevice *dev);
+static int dct_sdhc_probe(struct udevice *dev);
+static int dct_sdhc_remove(struct udevice *dev);
+static int dct_sdhc_unbind(struct udevice *dev);
+static int dct_sdhc_of_to_plat(struct udevice *dev);
+
+// ---------------------------------------------------------
+// ------------- Helper functions and Utilities ------------
+// ---------------------------------------------------------
+
+static	uint32_t setBits(const uint32_t value, const uint32_t mask, uint32_t shift,
+					  uint32_t value_to_set)
+{
+	return ((value & ~mask) | ((value_to_set << shift) & mask));
+}
+
+// ---------------------------------------------------------
+
+static	uint32_t getBits(const uint32_t value, const uint32_t mask, uint32_t shift)
+{
+	return ((value & mask) >> shift);
+}
+
+
+// ---------------------------------------------------------
+
+static void writel_slice(const uint32_t value, uint32_t* const reg,
+		 const uint32_t mask, const uint32_t shift)
+{
+	writel(setBits(readl(reg), mask, shift, value), reg);
+}
+
+// ---------------------------------------------------------
+
+static uint32_t readl_slice(const uint32_t* const reg,
+		const uint32_t mask, const uint32_t shift)
+{
+	return (getBits(readl(reg), mask, shift));
+}
+
+
+// ---------------------------------------------------------
+
+static int enter_critical_section(struct udevice *dev, const uint32_t sleep_us, const uint32_t timeout_us)
+{
+#ifndef __UBOOT__
+	struct dct_sdhc_priv* const priv  = dev_get_priv(dev);
+	int val = 0;
+	int rc = 0;
+	rc = read_poll_timeout(mutex_trylock, val, (1 == val), sleep_us, timeout_us, &(priv->device_mutex));
+
+	return(rc);
+#else
+	return (0);
+#endif
+}
+
+// ---------------------------------------------------------
+
+static int leave_critical_section(struct udevice *dev)
+{
+#ifndef __UBOOT__
+	struct dct_sdhc_priv* const priv  = dev_get_priv(dev);
+	if (mutex_is_locked(&(priv->device_mutex))) {
+		mutex_unlock(&(priv->device_mutex));
+	}
+#endif
+	return 0;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_enable_irqs(const struct udevice *dev, const uint32_t irq_mask)
+{
+	writel(irq_mask, &(SDHCI_SD4HC_SRS(dev)->srs14));
+	return 0;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_disable_all_irqs(const struct udevice *dev)
+{
+	writel(0, &(SDHCI_SD4HC_SRS(dev)->srs14));
+	return 0;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_clr_irqs(const struct udevice *dev, const uint32_t irq_mask)
+{
+	writel(irq_mask, &(SDHCI_SD4HC_SRS(dev)->srs12));
+	return 0;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_wait_for_irq(const struct udevice *dev,
+				 cmd_transfer_mode_t *const cmd_transfer_mode)
+{
+	int rc;
+#ifndef __UBOOT__
+	if (cmd_transfer_mode->use_irq) {
+		// use IRQ,
+		dct_sdhc_enable_irqs(dev, cmd_transfer_mode->irq_mask);
+		const k_timeout_t timeout = (SDHC_TIMEOUT_FOREVER == cmd_transfer_mode->wait_for_sdcard_cmd_completed_wait_us) ?
+							(K_FOREVER) :
+							(K_MSEC(cmd_transfer_mode->wait_for_sdcard_cmd_completed_wait_us));
+		// wait for notification from IRQ handler
+		rc = k_sem_take(&(CMD_SEM(dev).sem), timeout);
+
+	} else
+#endif
+	{
+		// poll for IRQ
+		// disable all IRQs
+		dct_sdhc_disable_all_irqs(dev);
+		// wait until IRQ status matches irq_mask;
+		uint32_t srs12;
+
+		rc = read_poll_timeout(readl,
+				srs12,
+				(0 != (srs12 & cmd_transfer_mode->irq_mask)),
+				cmd_transfer_mode->wait_for_sdcard_cmd_completed_sleep_us,
+				cmd_transfer_mode->wait_for_sdcard_cmd_completed_wait_us,
+				&(SDHCI_SD4HC_SRS(dev)->srs12));
+	}
+
+	return (rc);
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_init_priv(dct_sdhc_priv_t* const priv)
+{
+	memset(priv, 0x00,sizeof(dct_sdhc_priv_t));
+	mutex_init(&(priv->device_mutex));
+	priv->bus_width      = ~0;
+	priv->signal_voltage = ~0;
+	priv->selected_mode  = ~0;
+	priv->freq_hz        = ~0;
+
+	return 0;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_init_cmd_transfer_mode(const struct udevice* const dev,
+		cmd_transfer_mode_t *const cmd_transfer_mode)
+{
+	if ((NULL == cmd_transfer_mode) || (NULL == dev)) {
+		return -EINVAL;
+	}
+	const struct dct_sdhc_plat* const plat = dev_get_plat(dev);
+	const struct mmc* const mmc = &(plat->mmc);
+
+	memset(cmd_transfer_mode, 0x00, sizeof(cmd_transfer_mode_t));
+	const struct dct_sdhc_priv* const priv = dev_get_priv(dev);
+
+#ifdef __UBOOT__
+	cmd_transfer_mode->use_irq = false; // IRQs are not supported by U-BOOT
+#else
+	cmd_transfer_mode->use_irq = true;
+#endif
+	cmd_transfer_mode->use_dma = priv->use_dma;
+	cmd_transfer_mode->high_capacity = mmc->high_capacity;
+	cmd_transfer_mode->wait_for_sdcard_cmd_available_wait_us = WAIT_FOR_SDCARD_CMD_AVAILABLE_WAIT_MICROSECONDS;
+	cmd_transfer_mode->wait_for_sdcard_cmd_available_sleep_us   = WAIT_FOR_SDCARD_CMD_AVAILABLE_SLEEP_MICROSECONDS;
+	cmd_transfer_mode->wait_for_sdcard_cmd_completed_wait_us = WAIT_FOR_SDCARD_CMD_COMPLETED_WAIT_MICROSECONDS;
+	cmd_transfer_mode->wait_for_sdcard_cmd_completed_sleep_us = WAIT_FOR_SDCARD_CMD_COMPLETED_SLEEP_MICROSECONDS;
+	cmd_transfer_mode->irq_mask   =
+		SD4HC_SRS_SRS14__CC_IE_MASK | SD4HC_SRS_SRS14__TC_IE_MASK |
+		SD4HC_SRS_SRS14__ECT_IE_MASK | SD4HC_SRS_SRS14__ECCRC_IE_MASK |
+		SD4HC_SRS_SRS14__ECEB_IE_MASK | SD4HC_SRS_SRS14__ECI_IE_MASK | SD4HC_SRS_SRS14__EDT_IE_MASK |
+		SD4HC_SRS_SRS14__EDCRC_IE_MASK | SD4HC_SRS_SRS14__EDEB_IE_MASK | SD4HC_SRS_SRS14__ECL_IE_MASK |
+		SD4HC_SRS_SRS14__EAC_IE_MASK | SD4HC_SRS_SRS14__EADMA_IE_MASK | SD4HC_SRS_SRS14__ERSP_IE_MASK;
+	return 0;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_reset_dat_lines(const struct udevice *const dev)
+{
+	writel_slice(1, &(SDHCI_SD4HC_SRS(dev)->srs11), SD4HC_SRS_SRS11__SRDAT_MASK, SD4HC_SRS_SRS11__SRDAT_SHIFT);
+	// wait until DAT line reset is completed
+	uint32_t software_reset_dat_line = 0;
+	int rc = read_poll_timeout(readl_slice,
+			software_reset_dat_line,
+			(0 == software_reset_dat_line),
+			WAIT_FOR_SW_RESET_COMPLETE_SLEEP_MICROSECONDS,
+			WAIT_FOR_SW_RESET_COMPLETE_WAIT_MICROSECONDS,
+			&(SDHCI_SD4HC_SRS(dev)->srs11),
+			SD4HC_SRS_SRS11__SRDAT_MASK,
+			SD4HC_SRS_SRS11__SRDAT_SHIFT);
+	if (0 == rc) {
+		dct_sdhc_clr_irqs(dev, DAT_LINE_ERR_MSK);
+	}
+	return rc;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_reset_cmd_line(const struct udevice *const dev)
+{
+	writel_slice(1, &(SDHCI_SD4HC_SRS(dev)->srs11), SD4HC_SRS_SRS11__SRCMD_MASK, SD4HC_SRS_SRS11__SRCMD_SHIFT);
+	// wait until CMD line reset is completed
+	uint32_t software_reset_cmd_line = 0;
+	int rc = read_poll_timeout(readl_slice,
+			software_reset_cmd_line,
+			(0 == software_reset_cmd_line),
+			WAIT_FOR_SW_RESET_COMPLETE_SLEEP_MICROSECONDS,
+			WAIT_FOR_SW_RESET_COMPLETE_WAIT_MICROSECONDS,
+			&(SDHCI_SD4HC_SRS(dev)->srs11),
+			SD4HC_SRS_SRS11__SRCMD_MASK,
+			SD4HC_SRS_SRS11__SRCMD_SHIFT);
+	if (0 == rc) {
+		dct_sdhc_clr_irqs(dev, CMD_LINE_ERR_MSK);
+	}
+	return rc;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_error_recovery(const struct udevice *const dev)
+{
+	log_debug("Enter %s, %d\n",  __FILE__, __LINE__);
+	int rc = 0;
+
+	uint32_t srs09 = readl(&(SDHCI_SD4HC_SRS(dev)->srs09));
+	uint32_t srs12 = readl(&(SDHCI_SD4HC_SRS(dev)->srs12));
+	// save enabled IRQs
+	const uint32_t enabled_irqs = readl(&(SDHCI_SD4HC_SRS(dev)->srs14));
+	// disable all IRQs
+	dct_sdhc_disable_all_irqs(dev);
+
+	// check if CMD line errors or CMD line usage is inhibited
+	if ((0 != (srs12 & CMD_LINE_ERR_MSK)) || (0 != (srs09 & SD4HC_SRS_SRS09__CICMD_MASK))) {
+		// reset CMD lines
+		if (0 != dct_sdhc_reset_cmd_line(dev)) {
+			rc = -EFAULT;
+		}
+	}
+	// check if DAT line error or DAT line usage is inhibited
+	if (((0 != (srs12 & DAT_LINE_ERR_MSK)) || (0 != (srs09 & SD4HC_SRS_SRS09__CIDAT_MASK)))) {
+		// reset DAT lines
+		if (0 != dct_sdhc_reset_dat_lines(dev)) {
+			rc = -EFAULT;
+		}
+	}
+	if (0 == rc) {
+		uint32_t srs09;
+		rc = read_poll_timeout(readl,
+				srs09,
+				(0 == (srs09 & (SD4HC_SRS_SRS09__CICMD_MASK | SD4HC_SRS_SRS09__CIDAT_MASK))),
+				WAIT_FOR_SDCARD_INHIBIT_SLEEP_MICROSECONDS,
+				WAIT_FOR_SDCARD_INHIBIT_WAIT_MICROSECONDS,
+				&(SDHCI_SD4HC_SRS(dev)->srs09));
+	}
+	// reenable IRQs
+	dct_sdhc_clr_irqs(dev, (SD4HC_SRS_SRS12__TC_MASK | SD4HC_SRS_SRS12__CC_MASK));
+	dct_sdhc_enable_irqs(dev, enabled_irqs);
+	if (0 != rc) {
+		log_err("%s, %d: Error recovery failed, rc = %d\n", __FILE__, __LINE__, rc);
+	}
+	return rc;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_do_send_cmd(const struct udevice* const dev,
+				 cmd_transfer_mode_t *const cmd_transfer_mode)
+{
+	int rc = 0;
+	uint32_t value = 0;
+	uint32_t srs03 = 0;
+
+	srs03 = 0;
+	srs03 = setBits(srs03, SD4HC_SRS_SRS03__CIDX_MASK, SD4HC_SRS_SRS03__CIDX_SHIFT, cmd_transfer_mode->cmd_idx);
+	srs03 = setBits(srs03, SD4HC_SRS_SRS03__CT_MASK, SD4HC_SRS_SRS03__CT_SHIFT, cmd_transfer_mode->cmd_type);
+	srs03 = setBits(srs03, SD4HC_SRS_SRS03__DPS_MASK, SD4HC_SRS_SRS03__DPS_SHIFT,
+			cmd_transfer_mode->data_present_select);
+	srs03 = setBits(srs03, SD4HC_SRS_SRS03__CICE_MASK, SD4HC_SRS_SRS03__CICE_SHIFT,
+			cmd_transfer_mode->cmd_index_check_enable);
+	srs03 = setBits(srs03, SD4HC_SRS_SRS03__CRCCE_MASK, SD4HC_SRS_SRS03__CRCCE_SHIFT,
+			cmd_transfer_mode->cmd_crc_check_enable);
+	srs03 = setBits(srs03, SD4HC_SRS_SRS03__SCF_MASK, SD4HC_SRS_SRS03__SCF_SHIFT, cmd_transfer_mode->sub_cmd_flag);
+	srs03 = setBits(srs03, SD4HC_SRS_SRS03__RTS_MASK, SD4HC_SRS_SRS03__RTS_SHIFT,
+			cmd_transfer_mode->response_type_select);
+	srs03 = setBits(srs03, SD4HC_SRS_SRS03__RID_MASK, SD4HC_SRS_SRS03__RID_SHIFT,
+			cmd_transfer_mode->response_interrupt_disable);
+	srs03 = setBits(srs03, SD4HC_SRS_SRS03__RECE_MASK, SD4HC_SRS_SRS03__RECE_SHIFT,
+			cmd_transfer_mode->response_error_check_enable);
+	srs03 = setBits(srs03, SD4HC_SRS_SRS03__RECT_MASK, SD4HC_SRS_SRS03__RECT_SHIFT, cmd_transfer_mode->response_type);
+	srs03 = setBits(srs03, SD4HC_SRS_SRS03__MSBS_MASK, SD4HC_SRS_SRS03__MSBS_SHIFT, cmd_transfer_mode->block_select);
+	srs03 = setBits(srs03, SD4HC_SRS_SRS03__DTDS_MASK, SD4HC_SRS_SRS03__DTDS_SHIFT,
+			cmd_transfer_mode->data_transfer_direction);
+	srs03 = setBits(srs03, SD4HC_SRS_SRS03__ACE_MASK, SD4HC_SRS_SRS03__ACE_SHIFT, cmd_transfer_mode->auto_cmd);
+	srs03 = setBits(srs03, SD4HC_SRS_SRS03__BCE_MASK, SD4HC_SRS_SRS03__BCE_SHIFT,
+			cmd_transfer_mode->block_cnt_enable);
+	srs03 = setBits(srs03, SD4HC_SRS_SRS03__DMAE_MASK, SD4HC_SRS_SRS03__DMAE_SHIFT, cmd_transfer_mode->dma_enable);
+
+	//CHECK_FUNC(sdhc_cdns_clear_all_flags(dev));
+	/* set command arg */
+	// check if neither cmd nor dat inhibit is set
+	if (0 != ((readl(&(SDHCI_SD4HC_SRS(dev)->srs09))) & (SD4HC_SRS_SRS09__CICMD_MASK | SD4HC_SRS_SRS09__CIDAT_MASK))) {
+		return -EPERM;
+	}
+
+	// clr all IRQs
+	dct_sdhc_disable_all_irqs(dev);
+	dct_sdhc_clr_irqs(dev, CLR_ALL_IRQ_MASK);
+
+	value = 0;
+	value = setBits(value, SD4HC_SRS_SRS02__ARG1_MASK, SD4HC_SRS_SRS02__ARG1_SHIFT, cmd_transfer_mode->cmd_arg);
+	writel(value,  &(SDHCI_SD4HC_SRS(dev)->srs02));
+	writel(srs03,  &(SDHCI_SD4HC_SRS(dev)->srs03));
+	// enable cmd related IRQs and wait for semaphore released by IRQ handler (use_irq)
+	// or poll for require status bits (!use_irq)
+	rc = dct_sdhc_wait_for_irq(dev, cmd_transfer_mode);
+	if (0 == rc) {
+		if (0 != (readl(&(SDHCI_SD4HC_SRS(dev)->srs12)) & cmd_transfer_mode->irq_mask & ERR_MASK)) {
+			rc = -EFAULT;
+		}
+	}
+	memset(cmd_transfer_mode->response_data, 0x00, sizeof(cmd_transfer_mode->response_data));
+	if (0 == rc) {
+		switch (cmd_transfer_mode->response_type_select) {
+			case RESPONSE_TYPE_SELECT_048BIT_RESPONSE:
+			case RESPONSE_TYPE_SELECT_048BIT_RESPONSE_WITH_BUSY:
+				cmd_transfer_mode->response_data[0] = readl_slice(
+					&(SDHCI_SD4HC_SRS(dev)->srs04), SD4HC_SRS_SRS04__RESP0_MASK, SD4HC_SRS_SRS04__RESP0_SHIFT);
+				break;
+			case RESPONSE_TYPE_SELECT_136BIT_RESPONSE: {
+				cmd_transfer_mode->response_data[3] = readl_slice(
+					&(SDHCI_SD4HC_SRS(dev)->srs04), SD4HC_SRS_SRS04__RESP0_MASK, SD4HC_SRS_SRS04__RESP0_SHIFT);
+				cmd_transfer_mode->response_data[2] = readl_slice(
+					&(SDHCI_SD4HC_SRS(dev)->srs05), SD4HC_SRS_SRS05__RESP1_MASK, SD4HC_SRS_SRS05__RESP1_SHIFT);
+				cmd_transfer_mode->response_data[1] = readl_slice(
+					&(SDHCI_SD4HC_SRS(dev)->srs06), SD4HC_SRS_SRS06__RESP2_MASK, SD4HC_SRS_SRS06__RESP2_SHIFT);
+				cmd_transfer_mode->response_data[0] = readl_slice(
+					&(SDHCI_SD4HC_SRS(dev)->srs07), SD4HC_SRS_SRS07__RESP3_MASK, SD4HC_SRS_SRS07__RESP3_SHIFT);
+				for (int idx = 0; idx < 3; ++idx) {
+					cmd_transfer_mode->response_data[idx] =
+						(cmd_transfer_mode->response_data[idx] << 8) & 0xffffff00;
+					cmd_transfer_mode->response_data[idx] |=
+						((cmd_transfer_mode->response_data[idx + 1] >> 24) & 0xff);
+				}
+				cmd_transfer_mode->response_data[3] <<= 8;
+				cmd_transfer_mode->response_data[3] &= 0xffffff00;
+			} break;
+			case RESPONSE_TYPE_SELECT_NO_RESPONSE:
+			default:
+				break;
+		}
+	}
+	return rc;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_card_dma_transfer(const struct udevice *dev,
+					  cmd_transfer_mode_t *const cmd_transfer_mode,
+					  struct mmc_data *const data)
+{
+	int rc = 0;
+	uintptr_t dma_addr = 0;
+
+	if ((0 == data->blocks) || (0 == data->blocksize)) {
+		return -EINVAL;
+	}
+
+	switch (cmd_transfer_mode->data_transfer_direction) {
+		case DATA_TRANSFER_DIRECTION_WRITE:
+			dma_addr = (uintptr_t)data->src;
+			break;
+		case DATA_TRANSFER_DIRECTION_READ:
+			dma_addr = (uintptr_t)data->dest;
+			break;
+		default:
+			return -EINVAL;
+	};
+
+	writel_slice(dma_addr, &(SDHCI_SD4HC_SRS(dev)->srs00), SD4HC_SRS_SRS00__SAAR_MASK, SD4HC_SRS_SRS00__SAAR_SHIFT);
+
+
+	// DMASEL = 0 - SDMA, DMASEL = 2 - ADMA2
+	writel_slice(0, &(SDHCI_SD4HC_SRS(dev)->srs10), SD4HC_SRS_SRS10__DMASEL_MASK, SD4HC_SRS_SRS10__DMASEL_SHIFT);
+
+	// Start transfer - send CMD25 (multiblock write) + CMD12 (abort)
+	cmd_transfer_mode->irq_mask |= SD4HC_SRS_SRS14__DMAINT_IE_MASK;
+	CHECK_FUNC(dct_sdhc_do_send_cmd(dev, cmd_transfer_mode));
+	dct_sdhc_clr_irqs(dev, SD4HC_SRS_SRS12__CC_MASK);
+
+	do {
+		if (0 == (readl(&(SDHCI_SD4HC_SRS(dev)->srs12)) & (SD4HC_SRS_SRS12__DMAINT_MASK | SD4HC_SRS_SRS12__TC_MASK))) {
+			rc = dct_sdhc_wait_for_irq(dev, cmd_transfer_mode);
+		}
+		const uint32_t srs12 = readl(&(SDHCI_SD4HC_SRS(dev)->srs12));
+		if ((0 == rc) && (0 != (srs12 & cmd_transfer_mode->irq_mask & ERR_MASK))) {
+			rc = -EFAULT;
+		}
+		if ((0 == rc) &&
+			(0 != (srs12 & SD4HC_SRS_SRS12__DMAINT_MASK)) &&
+            (0 == (srs12 & SD4HC_SRS_SRS12__TC_MASK))) {
+			// reached boundary but transfer not completed
+			// clear DMA IRQ
+			writel(SD4HC_SRS_SRS12__DMAINT_MASK, &(SDHCI_SD4HC_SRS(dev)->srs12));
+			dma_addr =
+				readl_slice(&(SDHCI_SD4HC_SRS(dev)->srs00), SD4HC_SRS_SRS00__SAAR_MASK, SD4HC_SRS_SRS00__SAAR_SHIFT);
+			writel_slice(dma_addr, &(SDHCI_SD4HC_SRS(dev)->srs00), SD4HC_SRS_SRS00__SAAR_MASK, SD4HC_SRS_SRS00__SAAR_SHIFT);
+		}
+	} while ((0 == (readl(&(SDHCI_SD4HC_SRS(dev)->srs12)) & SD4HC_SRS_SRS12__TC_MASK)) && (0 == rc));
+	// clear TC
+	dct_sdhc_clr_irqs(dev, SD4HC_SRS_SRS12__TC_MASK);
+	return rc;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_card_pio_transfer(const struct udevice *dev,
+					  cmd_transfer_mode_t *const cmd_transfer_mode,
+					  struct mmc_data *const data)
+{
+	int rc = 0;
+    uint32_t tc_flag = 0;
+	uint32_t bre_bwe_mask = 0;
+	uint32_t bre_bwe_shift = 0;
+
+	if ((0 == data->blocks) || (0 == data->blocksize) ||
+			(0 != (data->blocksize & 0x3)) || (0x800 < data->blocksize)) {
+		return -EINVAL;
+	}
+
+	switch (cmd_transfer_mode->data_transfer_direction) {
+		case DATA_TRANSFER_DIRECTION_WRITE:
+			bre_bwe_mask = SD4HC_SRS_SRS09__BWE_MASK;
+			bre_bwe_shift = SD4HC_SRS_SRS09__BWE_SHIFT;
+			break;
+		case DATA_TRANSFER_DIRECTION_READ:
+			bre_bwe_mask = SD4HC_SRS_SRS09__BRE_MASK;
+			bre_bwe_shift = SD4HC_SRS_SRS09__BRE_SHIFT;
+			break;
+		default:
+			return -EINVAL;
+	};
+
+	const uint32_t* wr_buff = (const uint32_t*) data->src;
+	uint32_t* rd_buff = (uint32_t*) data->dest;
+
+	CHECK_FUNC(dct_sdhc_do_send_cmd(dev, cmd_transfer_mode));
+	dct_sdhc_clr_irqs(dev, SD4HC_SRS_SRS12__CC_MASK);
+    for (uint32_t blk_idx = 0; blk_idx < data->blocks; ++blk_idx) {
+        uint32_t ready_flag = 0;
+        // wait for BWE/BRE
+		rc = read_poll_timeout(readl_slice,
+				ready_flag,
+				(0 != ready_flag),
+				WAIT_FOR_BRE_BWE_SLEEP_MICROSECONDS,
+				WAIT_FOR_BRE_BWE_WAIT_MICROSECONDS,
+				&(SDHCI_SD4HC_SRS(dev)->srs09),
+				bre_bwe_mask,
+				bre_bwe_shift);
+		if (0 != rc) {
+			log_err("%s, %d: poll_timeout buffer\n", __FILE__, __LINE__);	\
+			return rc;
+		}
+
+        for (uint32_t buf_idx = 0; buf_idx < (data->blocksize / 4); ++buf_idx) {
+            if (DATA_TRANSFER_DIRECTION_WRITE == cmd_transfer_mode->data_transfer_direction) {
+				writel(setBits(0, SD4HC_SRS_SRS08__BDP_MASK, SD4HC_SRS_SRS08__BDP_SHIFT, wr_buff[buf_idx]),
+						&(SDHCI_SD4HC_SRS(dev)->srs08));
+            } else {
+                rd_buff[buf_idx] = readl_slice(&(SDHCI_SD4HC_SRS(dev)->srs08),
+						SD4HC_SRS_SRS08__BDP_MASK, SD4HC_SRS_SRS08__BDP_SHIFT);
+            }
+        }
+
+        wr_buff += (data->blocksize / 4);
+        rd_buff += (data->blocksize / 4);
+    }
+	// wait for transmission complete
+	rc = read_poll_timeout(readl_slice,
+			tc_flag,
+			(1 == tc_flag),
+			WAIT_FOR_TRANSFER_COMPLETE_SLEEP_MICROSECONDS,
+			WAIT_FOR_TRANSFER_COMPLETE_WAIT_MICROSECONDS,
+			&(SDHCI_SD4HC_SRS(dev)->srs12),
+			SD4HC_SRS_SRS12__TC_MASK,
+			SD4HC_SRS_SRS12__TC_SHIFT);
+	if (0 != rc) {
+		log_err("%s, %d: poll_timeout transfer complete\n", __FILE__, __LINE__);	\
+		return rc;
+	} else {
+		// clr TC IRQ
+		dct_sdhc_clr_irqs(dev, SD4HC_SRS_SRS12__TC_MASK);
+	}
+	return rc;
+}
+
+// ---------------------------------------------------------
+#ifndef __UBOOT__
+static int install_irq_handler(const struct udevice* const dev)
+{
+	return -ENOTSUPP;
+}
+#endif
+// ---------------------------------------------------------
+
+static int init_pins(const struct udevice* const dev)
+{
+	// TODO: not implemented
+	return 0;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_init_data(struct udevice* const dev)
+{
+	CHECK_FUNC(dct_sdhc_init_priv((dct_sdhc_priv_t*)dev_get_priv(dev)));
+	return 0;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_reset_host(const struct udevice *const dev)
+{
+	uint32_t software_reset = 0;
+	int rc = 0;
+
+	// start software reset
+	writel_slice(1, &(SDHCI_SD4HC_HRS(dev)->hrs00), SD4HC_HRS_HRS00__SWR_MASK, SD4HC_HRS_HRS00__SWR_SHIFT);
+	// wait until reset is finished
+	rc = read_poll_timeout(readl_slice,
+			software_reset,
+			(0 == software_reset),
+			WAIT_FOR_PHY_RELEASE_SLEEP_MICROSECONDS,
+			WAIT_FOR_PHY_RELEASE_WAIT_MICROSECONDS,
+			&(SDHCI_SD4HC_HRS(dev)->hrs00),
+			SD4HC_HRS_HRS00__SWR_MASK,
+			SD4HC_HRS_HRS00__SWR_SHIFT);
+
+	return (rc);
+}
+
+// ---------------------------------------------------------
+
+static uint32_t dct_sdhc_read_phy_reg(const struct udevice *const dev, volatile const uint32_t* const reg_ptr)
+{
+	const uint32_t offs = (uintptr_t)(reg_ptr) - (uintptr_t)(SDHCI_SDPHY_DLL(dev));
+	writel_slice(offs, &(SDHCI_SD4HC_HRS(dev)->hrs04), SD4HC_HRS_HRS04__PHYREGADDR_MASK, SD4HC_HRS_HRS04__PHYREGADDR_SHIFT);
+	return (readl_slice(&(SDHCI_SD4HC_HRS(dev)->hrs05), SD4HC_HRS_HRS05__PHYREGDATA_MASK, SD4HC_HRS_HRS05__PHYREGDATA_SHIFT));
+}
+
+// ---------------------------------------------------------
+
+static void dct_sdhc_write_phy_reg(const struct udevice *const dev, const uint32_t data, volatile uint32_t* const reg_ptr)
+{
+	const uint32_t offs = (uintptr_t)(reg_ptr) - (uintptr_t)(SDHCI_SDPHY_DLL(dev));
+	writel_slice(offs, &(SDHCI_SD4HC_HRS(dev)->hrs04), SD4HC_HRS_HRS04__PHYREGADDR_MASK, SD4HC_HRS_HRS04__PHYREGADDR_SHIFT);
+	writel_slice(data, &(SDHCI_SD4HC_HRS(dev)->hrs05), SD4HC_HRS_HRS05__PHYREGDATA_MASK, SD4HC_HRS_HRS05__PHYREGDATA_SHIFT);
+}
+
+// ---------------------------------------------------------
+
+static uint32_t dct_sdhc_read_ctb_reg(const struct udevice *const dev, volatile const uint32_t* const reg_ptr)
+{
+	const uint32_t offs = (uintptr_t)(reg_ptr) - (uintptr_t)(SDHCI_SDPHY_CTB(dev));
+	writel_slice(offs, &(SDHCI_SD4HC_HRS(dev)->hrs04), SD4HC_HRS_HRS04__PHYREGADDR_MASK, SD4HC_HRS_HRS04__PHYREGADDR_SHIFT);
+	return (readl_slice(&(SDHCI_SD4HC_HRS(dev)->hrs05), SD4HC_HRS_HRS05__PHYREGDATA_MASK, SD4HC_HRS_HRS05__PHYREGDATA_SHIFT));
+}
+
+// ---------------------------------------------------------
+
+static void dct_sdhc_write_ctb_reg(const struct udevice *const dev, const uint32_t data, volatile uint32_t* const reg_ptr)
+{
+	const uint32_t offs = (uintptr_t)(reg_ptr) - (uintptr_t)(SDHCI_SDPHY_CTB(dev));
+	writel_slice(offs, &(SDHCI_SD4HC_HRS(dev)->hrs04), SD4HC_HRS_HRS04__PHYREGADDR_MASK, SD4HC_HRS_HRS04__PHYREGADDR_SHIFT);
+	writel_slice(data, &(SDHCI_SD4HC_HRS(dev)->hrs05), SD4HC_HRS_HRS05__PHYREGDATA_MASK, SD4HC_HRS_HRS05__PHYREGDATA_SHIFT);
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_reset_phy(const struct udevice *const dev, const bool reset)
+{
+	int rc = 0;
+	uint32_t phy_init_completed = 0;
+	if (reset) {
+		writel_slice(0, &(SDHCI_SD4HC_HRS(dev)->hrs09), SD4HC_HRS_HRS09__PHY_SW_RESET_MASK, SD4HC_HRS_HRS09__PHY_SW_RESET_SHIFT);
+		rc = 0;
+	} else {
+		writel_slice(1, &(SDHCI_SD4HC_HRS(dev)->hrs09), SD4HC_HRS_HRS09__PHY_SW_RESET_MASK, SD4HC_HRS_HRS09__PHY_SW_RESET_SHIFT);
+		rc = read_poll_timeout(readl_slice,
+				phy_init_completed,
+				(1 == phy_init_completed),
+				WAIT_FOR_PHY_RELEASE_SLEEP_MICROSECONDS,
+				WAIT_FOR_PHY_RELEASE_WAIT_MICROSECONDS,
+				&(SDHCI_SD4HC_HRS(dev)->hrs09),
+				SD4HC_HRS_HRS09__PHY_INIT_COMPLETE_MASK,
+				SD4HC_HRS_HRS09__PHY_INIT_COMPLETE_SHIFT);
+	}
+	return rc;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_init_phy(const struct udevice *const dev)
+{
+	int rc = 0;
+	uint32_t value = 0;
+	volatile uint32_t* reg_ptr = NULL;
+
+	/* assert reset to phy */
+	//CHECK_FUNC(dct_sdhc_reset_phy(dev, true));
+
+	/* PLL Block */
+	value = 0;
+	reg_ptr = &(SDHCI_SDPHY_DLL(dev)->phy_dqs_timing_reg);
+	value = setBits(value, SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_EXT_LPBK_DQS_MASK, SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_EXT_LPBK_DQS_SHIFT, 1);
+	value = setBits(value, SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_LPBK_DQS_MASK, SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_LPBK_DQS_SHIFT, 1);
+	value = setBits(value, SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_PHONY_DQS_MASK, SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_PHONY_DQS_SHIFT, 1);
+	value = setBits(value, SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_PHONY_DQS_CMD_MASK, SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_PHONY_DQS_CMD_SHIFT, 1);
+	dct_sdhc_write_phy_reg(dev, value, reg_ptr);
+
+	value = 0;
+	reg_ptr = &(SDHCI_SDPHY_DLL(dev)->phy_gate_lpbk_ctrl_reg);
+	value = setBits(value, SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__SYNC_METHOD_MASK, SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__SYNC_METHOD_SHIFT, 1);
+	value = setBits(value, SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__RD_DEL_SEL_MASK,  SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__RD_DEL_SEL_SHIFT, 0x34);
+	value = setBits(value, SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__UNDERRUN_SUPPRESS_MASK, SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__UNDERRUN_SUPPRESS_SHIFT, 1);
+	value = setBits(value, SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__GATE_CFG_ALWAYS_ON_MASK, SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__GATE_CFG_ALWAYS_ON_SHIFT, 1);
+	dct_sdhc_write_phy_reg(dev, value, reg_ptr);
+
+	value = 0;
+	reg_ptr = &(SDHCI_SDPHY_DLL(dev)->phy_dll_master_ctrl_reg);
+	value = dct_sdhc_read_phy_reg(dev, reg_ptr);
+	value = setBits(value, SD4PHY_DLLPHY_PHY_DLL_MASTER_CTRL_REG__PARAM_DLL_BYPASS_MODE_MASK, SD4PHY_DLLPHY_PHY_DLL_MASTER_CTRL_REG__PARAM_DLL_BYPASS_MODE_SHIFT, 1);
+	value = setBits(value, SD4PHY_DLLPHY_PHY_DLL_MASTER_CTRL_REG__PARAM_PHASE_DETECT_SEL_MASK, SD4PHY_DLLPHY_PHY_DLL_MASTER_CTRL_REG__PARAM_PHASE_DETECT_SEL_SHIFT, 2);
+	value = setBits(value, SD4PHY_DLLPHY_PHY_DLL_MASTER_CTRL_REG__PARAM_DLL_START_POINT_MASK, SD4PHY_DLLPHY_PHY_DLL_MASTER_CTRL_REG__PARAM_DLL_START_POINT_SHIFT, 4);
+	dct_sdhc_write_phy_reg(dev, value, reg_ptr);
+
+	value = 0;
+	reg_ptr = &(SDHCI_SDPHY_DLL(dev)->phy_dll_slave_ctrl_reg);
+	value = setBits(value, SD4PHY_DLLPHY_PHY_DLL_SLAVE_CTRL_REG__READ_DQS_CMD_DELAY_MASK, SD4PHY_DLLPHY_PHY_DLL_SLAVE_CTRL_REG__READ_DQS_CMD_DELAY_SHIFT, 0);
+	value = setBits(value, SD4PHY_DLLPHY_PHY_DLL_SLAVE_CTRL_REG__CLK_WR_DELAY_MASK, SD4PHY_DLLPHY_PHY_DLL_SLAVE_CTRL_REG__CLK_WR_DELAY_SHIFT, 0);
+	value = setBits(value, SD4PHY_DLLPHY_PHY_DLL_SLAVE_CTRL_REG__READ_DQS_DELAY_MASK, SD4PHY_DLLPHY_PHY_DLL_SLAVE_CTRL_REG__READ_DQS_DELAY_SHIFT, 0);
+	dct_sdhc_write_phy_reg(dev, value, reg_ptr);
+
+	/* Control Timing Block */
+	reg_ptr = &(SDHCI_SDPHY_CTB(dev)->phy_ctrl_reg);
+	value	= dct_sdhc_read_ctb_reg(dev, reg_ptr);
+	value = setBits(value, SD4PHY_CTB_PHY_CTRL_REG__PHONY_DQS_TIMING_MASK, SD4PHY_CTB_PHY_CTRL_REG__PHONY_DQS_TIMING_SHIFT, 0);
+	dct_sdhc_write_ctb_reg(dev, value, reg_ptr);
+
+	/* deassert reset to phy */
+	CHECK_FUNC(dct_sdhc_reset_phy(dev, false));
+
+	value = 0;
+	reg_ptr = &(SDHCI_SDPHY_DLL(dev)->phy_dq_timing_reg);
+	value = setBits(value, SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__IO_MASK_ALWAYS_ON_MASK, SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__IO_MASK_ALWAYS_ON_SHIFT, 0);
+	value = setBits(value, SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__IO_MASK_END_MASK, SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__IO_MASK_END_SHIFT, 0);
+	value = setBits(value, SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__IO_MASK_START_MASK, SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__IO_MASK_START_SHIFT, 0);
+	value = setBits(value, SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__DATA_SELECT_OE_END_MASK, SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__DATA_SELECT_OE_END_SHIFT, 1);
+	dct_sdhc_write_phy_reg(dev, value, reg_ptr);
+
+	value = readl(&(SDHCI_SD4HC_HRS(dev)->hrs09));
+	value = setBits(value, SD4HC_HRS_HRS09__RDDATA_EN_MASK, SD4HC_HRS_HRS09__RDDATA_EN_SHIFT, 1);
+	value = setBits(value, SD4HC_HRS_HRS09__RDCMD_EN_MASK, SD4HC_HRS_HRS09__RDCMD_EN_SHIFT, 1);
+	value = setBits(value, SD4HC_HRS_HRS09__EXTENDED_WR_MODE_MASK, SD4HC_HRS_HRS09__EXTENDED_WR_MODE_SHIFT, 1);
+	value = setBits(value, SD4HC_HRS_HRS09__EXTENDED_RD_MODE_MASK, SD4HC_HRS_HRS09__EXTENDED_RD_MODE_SHIFT, 1);
+	writel(value, &(SDHCI_SD4HC_HRS(dev)->hrs09));
+
+	writel_slice(2, &(SDHCI_SD4HC_HRS(dev)->hrs10), SD4HC_HRS_HRS10__HCSDCLKADJ_MASK, SD4HC_HRS_HRS10__HCSDCLKADJ_SHIFT);
+
+	value = 0;
+	value = setBits(value, SD4HC_HRS_HRS16__WRDATA1_SDCLK_DLY_MASK, SD4HC_HRS_HRS16__WRDATA1_SDCLK_DLY_SHIFT, 0);
+	value = setBits(value, SD4HC_HRS_HRS16__WRDATA0_SDCLK_DLY_MASK, SD4HC_HRS_HRS16__WRDATA0_SDCLK_DLY_SHIFT, 0);
+	value = setBits(value, SD4HC_HRS_HRS16__WRCMD1_SDCLK_DLY_MASK, SD4HC_HRS_HRS16__WRCMD1_SDCLK_DLY_SHIFT, 0);
+	value = setBits(value, SD4HC_HRS_HRS16__WRCMD0_SDCLK_DLY_MASK, SD4HC_HRS_HRS16__WRCMD0_SDCLK_DLY_SHIFT, 0);
+	value = setBits(value, SD4HC_HRS_HRS16__WRDATA1_DLY_MASK, SD4HC_HRS_HRS16__WRDATA1_DLY_SHIFT, 0);
+	value = setBits(value, SD4HC_HRS_HRS16__WRDATA0_DLY_MASK, SD4HC_HRS_HRS16__WRDATA0_DLY_SHIFT, 1);
+	value = setBits(value, SD4HC_HRS_HRS16__WRCMD1_DLY_MASK, SD4HC_HRS_HRS16__WRCMD1_DLY_SHIFT, 0);
+	value = setBits(value, SD4HC_HRS_HRS16__WRCMD0_DLY_MASK, SD4HC_HRS_HRS16__WRCMD0_DLY_SHIFT, 1);
+	writel(value, &(SDHCI_SD4HC_HRS(dev)->hrs16));
+
+	value = 0;
+	value = setBits(value, SD4HC_HRS_HRS07__RW_COMPENSATE_MASK, SD4HC_HRS_HRS07__RW_COMPENSATE_SHIFT, 9);
+	value = setBits(value, SD4HC_HRS_HRS07__IDELAY_VAL_MASK, SD4HC_HRS_HRS07__IDELAY_VAL_SHIFT, 0);
+	writel(value, &(SDHCI_SD4HC_HRS(dev)->hrs07));
+
+	return rc;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_set_bus_width(const struct udevice *const dev)
+{
+	int rc = 0;
+	struct dct_sdhc_priv* const priv  = dev_get_priv(dev);
+	const struct mmc* const mmc = mmc_get_mmc_dev(dev);
+
+	if ((0 != mmc->bus_width) && (mmc->bus_width != priv->bus_width)) {
+		uint32_t bw;
+		switch(mmc->bus_width) {
+			case 1:
+				bw = 0;
+				rc = 0;
+				break;
+			case 4:
+				bw = 1;
+				rc = 0;
+				break;
+			default:
+				log_err("Bus width %u not supported\n", mmc->bus_width);
+				rc = -ENOTSUPP;
+		}
+		if (0 == rc) {
+			writel_slice(bw, &(SDHCI_SD4HC_SRS(dev)->srs10), SD4HC_SRS_SRS10__DTW_MASK, SD4HC_SRS_SRS10__DTW_SHIFT);
+			priv->bus_width = mmc->bus_width;
+		}
+	}
+
+	return rc;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_enable_all_flags(const struct udevice *const dev)
+{
+	int rc = 0;
+	uint32_t value = readl(&(SDHCI_SD4HC_SRS(dev)->srs13));
+	value = setBits(value, SD4HC_SRS_SRS13__CC_SE_MASK, SD4HC_SRS_SRS13__CC_SE_SHIFT, 1);
+	value = setBits(value, SD4HC_SRS_SRS13__TC_SE_MASK, SD4HC_SRS_SRS13__TC_SE_SHIFT, 1);
+	value = setBits(value, SD4HC_SRS_SRS13__BGE_SE_MASK, SD4HC_SRS_SRS13__BGE_SE_SHIFT, 1);
+	value = setBits(value, SD4HC_SRS_SRS13__DMAINT_SE_MASK, SD4HC_SRS_SRS13__DMAINT_SE_SHIFT, 1);
+	value = setBits(value, SD4HC_SRS_SRS13__BWR_SE_MASK, SD4HC_SRS_SRS13__BWR_SE_SHIFT, 1);
+	value = setBits(value, SD4HC_SRS_SRS13__BRR_SE_MASK, SD4HC_SRS_SRS13__BRR_SE_SHIFT, 1);
+	value = setBits(value, SD4HC_SRS_SRS13__CIN_SE_MASK, SD4HC_SRS_SRS13__CIN_SE_SHIFT, 1);
+	value = setBits(value, SD4HC_SRS_SRS13__CR_SE_MASK, SD4HC_SRS_SRS13__CR_SE_SHIFT, 1);
+	// TODO: check, disabled because simulation doesnt pull up lines
+	value = setBits(value, SD4HC_SRS_SRS13__CINT_SE_MASK, SD4HC_SRS_SRS13__CINT_SE_SHIFT, 1);
+
+	value = setBits(value, SD4HC_SRS_SRS13__FXE_SE_MASK, SD4HC_SRS_SRS13__FXE_SE_SHIFT, 1);
+	value = setBits(value, SD4HC_SRS_SRS13__CQINT_SE_MASK, SD4HC_SRS_SRS13__CQINT_SE_SHIFT, 1);
+	value = setBits(value, SD4HC_SRS_SRS13__ECT_SE_MASK, SD4HC_SRS_SRS13__ECT_SE_SHIFT, 1);
+	value = setBits(value, SD4HC_SRS_SRS13__ECCRC_SE_MASK, SD4HC_SRS_SRS13__ECCRC_SE_SHIFT, 1);
+	value = setBits(value, SD4HC_SRS_SRS13__ECEB_SE_MASK, SD4HC_SRS_SRS13__ECEB_SE_SHIFT, 1);
+	value = setBits(value, SD4HC_SRS_SRS13__ECI_SE_MASK, SD4HC_SRS_SRS13__ECI_SE_SHIFT, 1);
+	value = setBits(value, SD4HC_SRS_SRS13__EDT_SE_MASK, SD4HC_SRS_SRS13__EDT_SE_SHIFT, 1);
+	value = setBits(value, SD4HC_SRS_SRS13__EDCRC_SE_MASK, SD4HC_SRS_SRS13__EDCRC_SE_SHIFT, 1);
+	value = setBits(value, SD4HC_SRS_SRS13__EDEB_SE_MASK, SD4HC_SRS_SRS13__EDEB_SE_SHIFT, 1);
+	value = setBits(value, SD4HC_SRS_SRS13__ECL_SE_MASK, SD4HC_SRS_SRS13__ECL_SE_SHIFT, 1);
+	value = setBits(value, SD4HC_SRS_SRS13__EAC_SE_MASK, SD4HC_SRS_SRS13__EAC_SE_SHIFT, 1);
+	value = setBits(value, SD4HC_SRS_SRS13__EADMA_SE_MASK, SD4HC_SRS_SRS13__EADMA_SE_SHIFT, 1);
+	value = setBits(value, SD4HC_SRS_SRS13__ERSP_SE_MASK, SD4HC_SRS_SRS13__ERSP_SE_SHIFT, 1);
+	writel(value, &(SDHCI_SD4HC_SRS(dev)->srs13));
+
+	return rc;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_set_clk(const struct udevice *dev)
+{
+	struct dct_sdhc_priv* const priv  = dev_get_priv(dev);
+	const struct mmc* const mmc = mmc_get_mmc_dev(dev);
+	int rc = 0;
+	uint32_t value = 0;
+
+	if (mmc->clock != priv->freq_hz) {
+		/* disable sdclk */
+		writel_slice(0, &(SDHCI_SD4HC_SRS(dev)->srs11) , SD4HC_SRS_SRS11__SDCE_MASK, SD4HC_SRS_SRS11__SDCE_SHIFT);
+
+		if (0 == mmc->clock) {
+			priv->freq_hz = mmc->clock;
+			return (0);
+		};
+
+		uint32_t sdclk_div = 0;
+		uint32_t divider = priv->sys_clk_hz / mmc->clock;
+		if (0 == divider) {
+			sdclk_div = 0;
+		} else {
+			sdclk_div = divider / 2;
+		}
+
+		/* set sdclock divider */
+		uint32_t sdclk_div_low = sdclk_div & (SD4HC_SRS_SRS11__SDCFSL_MASK >> SD4HC_SRS_SRS11__SDCFSL_SHIFT);
+		uint32_t sdclk_div_high = (sdclk_div >> 8) & (SD4HC_SRS_SRS11__SDCFSH_MASK >> SD4HC_SRS_SRS11__SDCFSH_SHIFT);
+		value = readl(&(SDHCI_SD4HC_SRS(dev)->srs11));
+		value = setBits(value, SD4HC_SRS_SRS11__SDCE_MASK, SD4HC_SRS_SRS11__SDCE_SHIFT, 0);
+		value = setBits(value, SD4HC_SRS_SRS11__SDCFSL_MASK, SD4HC_SRS_SRS11__SDCFSL_SHIFT, sdclk_div_low);
+		value = setBits(value, SD4HC_SRS_SRS11__SDCFSH_MASK, SD4HC_SRS_SRS11__SDCFSH_SHIFT, sdclk_div_high);
+		value = setBits(value, SD4HC_SRS_SRS11__DTCV_MASK, SD4HC_SRS_SRS11__DTCV_SHIFT, 0xe);
+		value = setBits(value, SD4HC_SRS_SRS11__ICE_MASK, SD4HC_SRS_SRS11__ICE_SHIFT, 1);
+		writel(value, &(SDHCI_SD4HC_SRS(dev)->srs11));
+
+		// wait for stable clock
+
+		uint32_t internal_clock_stable;
+		rc = read_poll_timeout(readl_slice,
+				internal_clock_stable,
+				(1 == internal_clock_stable),
+				WAIT_FOR_INTERNAL_CLOCK_STABLE_SLEEP_MICROSECONDS,
+				WAIT_FOR_INTERNAL_CLOCK_STABLE_WAIT_MICROSECONDS,
+				&(SDHCI_SD4HC_SRS(dev)->srs11),
+				SD4HC_SRS_SRS11__ICS_MASK,
+				SD4HC_SRS_SRS11__ICS_SHIFT);
+		if (0 != rc) {
+			log_err("set SD clock to %u Hz failed\n", mmc->clock);
+			return rc;
+		}
+		log_debug("set SD clock to %u Hz\n", mmc->clock);
+		CHECK_FUNC(dct_sdhc_reset_phy(dev, true));
+		writel_slice((0 < sdclk_div) ? (1) : (0), &(SDHCI_SD4HC_HRS(dev)->hrs09),
+				SD4HC_HRS_HRS09__EXTENDED_WR_MODE_MASK, SD4HC_HRS_HRS09__EXTENDED_WR_MODE_SHIFT);
+		CHECK_FUNC(dct_sdhc_reset_phy(dev, false));
+
+		if (0 == rc) {
+			priv->freq_hz = mmc->clock;
+		}
+	}
+
+	if ((0 != mmc->clock) && !mmc->clk_disable) {
+		/* enable sdclk */
+		writel_slice(1, &(SDHCI_SD4HC_SRS(dev)->srs11), SD4HC_SRS_SRS11__SDCE_MASK, SD4HC_SRS_SRS11__SDCE_SHIFT);
+	} else {
+		/* disable sdclk */
+		writel_slice(0, &(SDHCI_SD4HC_SRS(dev)->srs11), SD4HC_SRS_SRS11__SDCE_MASK, SD4HC_SRS_SRS11__SDCE_SHIFT);
+	}
+
+	return rc;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_set_signal_voltage(struct udevice* const dev)
+{
+	// TODO: not implemented
+	int rc = 0;
+	struct dct_sdhc_priv* const priv  = dev_get_priv(dev);
+	const struct mmc* const mmc = mmc_get_mmc_dev(dev);
+
+	if (mmc->signal_voltage != priv->signal_voltage) {
+		bool set_voltage = false;
+		switch(mmc->signal_voltage) {
+			case MMC_SIGNAL_VOLTAGE_180:
+				writel_slice(1, &(SDHCI_SD4HC_SRS(dev)->srs15), SD4HC_SRS_SRS15__V18SE_MASK, SD4HC_SRS_SRS15__V18SE_SHIFT);
+				set_voltage = true;
+				break;
+			case MMC_SIGNAL_VOLTAGE_330:
+				writel_slice(0, &(SDHCI_SD4HC_SRS(dev)->srs15), SD4HC_SRS_SRS15__V18SE_MASK, SD4HC_SRS_SRS15__V18SE_SHIFT);
+				set_voltage = true;
+				break;
+			case MMC_SIGNAL_VOLTAGE_000:
+			case MMC_SIGNAL_VOLTAGE_120:
+				// ignore without error
+				log_debug("Signal voltage not supported, ignored\n");
+				break;
+			default:
+				rc = -ENOTSUPP;
+				log_err("Signal voltage not supported\n");
+		}
+		if (set_voltage) {
+			priv->signal_voltage = mmc->signal_voltage;
+		}
+	}
+	return rc;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_set_bus_mode(struct udevice* const dev)
+{
+	int rc = 0;
+	struct dct_sdhc_priv* const priv  = dev_get_priv(dev);
+	const struct mmc* const mmc = mmc_get_mmc_dev(dev);
+
+	if (mmc->selected_mode != priv->selected_mode) {
+		// see Cadence SD/eMMC Host Controller IP User Guide
+        // Table 15. Speed mode selection, page 14
+        uint32_t hrs06_emm = 0;
+        uint32_t srs10_hse = 0;
+        uint32_t srs15_ums = 0;
+
+		switch (mmc->selected_mode) {
+			case MMC_LEGACY:
+				break;
+			case SD_HS:
+				srs10_hse = 1;
+				break;
+			case UHS_SDR12:
+				srs15_ums = 0x0;
+				break;
+			case UHS_SDR25:
+				srs15_ums = 0x1;
+				break;
+			case UHS_SDR50:
+				srs15_ums = 0x2;
+				break;
+			case UHS_SDR104:
+				srs15_ums = 0x3;
+				break;
+			case MMC_HS_200:
+				srs15_ums = 0x4;
+				rc = -ENOTSUPP;
+				break;
+			case  MMC_HS_400:
+				hrs06_emm = 0x5;
+				rc = -ENOTSUPP;
+				break;
+			default:
+				rc = -ENOTSUPP;
+		}
+		if (0 == rc) {
+			writel_slice(hrs06_emm, &(SDHCI_SD4HC_HRS(dev)->hrs06), SD4HC_HRS_HRS06__EMM_MASK, SD4HC_HRS_HRS06__EMM_SHIFT);
+			writel_slice(srs15_ums, &(SDHCI_SD4HC_SRS(dev)->srs15), SD4HC_SRS_SRS15__UMS_MASK, SD4HC_SRS_SRS15__UMS_SHIFT);
+			writel_slice(srs10_hse, &(SDHCI_SD4HC_SRS(dev)->srs10), SD4HC_SRS_SRS10__HSE_MASK, SD4HC_SRS_SRS10__HSE_SHIFT);
+
+			priv->selected_mode = mmc->selected_mode;
+		}
+	}
+	return rc;
+}
+
+// ---------------------------------------------------------
+// ------------- MMC API functions -------------------------
+// ---------------------------------------------------------
+
+static int dct_sdhc_deferred_probe(struct udevice *dev)
+{
+	log_debug("Enter %s, %d\n",  __FILE__, __LINE__);
+	// TODO: not implemented
+	return 0;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_reinit(struct udevice *dev)
+{
+	log_debug("Enter %s, %d\n",  __FILE__, __LINE__);
+	// enable all flags
+	CHECK_FUNC(dct_sdhc_enable_all_flags(dev));
+	return 0;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_send_command(struct udevice *dev, struct mmc_cmd *cmd,
+		struct mmc_data *data)
+{
+	log_debug("Enter %s, %d\n",  __FILE__, __LINE__);
+	int rc = 0;
+#if 0
+	if (MMC_CMD_STOP_TRANSMISSION == cmd->cmdidx) {
+		// CMD12 will be send automatically by Cadence IP in
+		// case of multi block transmission
+		return 0;
+	}
+#endif
+	cmd_transfer_mode_t cmd_transfer_mode;
+
+	CHECK_FUNC(dct_sdhc_init_cmd_transfer_mode(dev, &cmd_transfer_mode));
+
+	cmd_transfer_mode.cmd_idx = cmd->cmdidx;
+	cmd_transfer_mode.cmd_arg = cmd->cmdarg;
+	if ((MMC_CMD_STOP_TRANSMISSION == cmd->cmdidx) ||(52 == cmd->cmdidx)) {
+		cmd_transfer_mode.cmd_type = CMD_TYPE_ABORT_CMD;
+	} else {
+		cmd_transfer_mode.cmd_type = CMD_TYPE_NORMAL_CMD;
+	}
+	cmd_transfer_mode.data_present_select = 0;
+	cmd_transfer_mode.sub_cmd_flag = 0;
+	cmd_transfer_mode.response_interrupt_disable = 0;
+	cmd_transfer_mode.response_error_check_enable = 0;
+	cmd_transfer_mode.block_select = BLOCK_SELECT_TYPE_SINGLE_BLOCK;
+	cmd_transfer_mode.data_transfer_direction = DATA_TRANSFER_DIRECTION_WRITE;
+	cmd_transfer_mode.auto_cmd = AUT0_CMD_DISABLE;
+	cmd_transfer_mode.block_cnt_enable = 0;
+	cmd_transfer_mode.dma_enable = 0;
+
+	if (MMC_RSP_136 & cmd->resp_type) {
+		cmd_transfer_mode.response_type_select = RESPONSE_TYPE_SELECT_136BIT_RESPONSE;
+	} else if (MMC_RSP_BUSY & cmd->resp_type) {
+		cmd_transfer_mode.response_type_select = RESPONSE_TYPE_SELECT_048BIT_RESPONSE_WITH_BUSY;
+		cmd_transfer_mode.irq_mask &= ~(SD4HC_SRS_SRS14__ECT_IE_MASK | SD4HC_SRS_SRS14__CC_IE_MASK);
+	} else if (MMC_RSP_NONE != cmd->resp_type) {
+		cmd_transfer_mode.response_type_select = RESPONSE_TYPE_SELECT_048BIT_RESPONSE;
+	} else {
+		cmd_transfer_mode.response_type_select = RESPONSE_TYPE_SELECT_NO_RESPONSE;
+	}
+
+	cmd_transfer_mode.cmd_crc_check_enable	 = (MMC_RSP_CRC    & cmd->resp_type) ? (1) : (0);
+	cmd_transfer_mode.cmd_index_check_enable = (MMC_RSP_OPCODE & cmd->resp_type) ? (1) : (0);
+
+	const uint32_t retries = cmd_transfer_mode.retries;
+
+	rc = enter_critical_section(dev, cmd_transfer_mode.wait_for_sdcard_cmd_available_wait_us,
+			cmd_transfer_mode.wait_for_sdcard_cmd_available_sleep_us);
+	if (0 != rc) {
+		return rc;
+	}
+
+	const uint32_t srs12 = readl(&(SDHCI_SD4HC_SRS(dev)->srs12));
+	const uint32_t srs09 = readl(&(SDHCI_SD4HC_SRS(dev)->srs09));
+	if ((0 != (srs12 & SD4HC_SRS_SRS12__EINT_MASK)) ||
+			(0 != (srs09 & (SD4HC_SRS_SRS09__CICMD_MASK | SD4HC_SRS_SRS09__CIDAT_MASK)))) {
+		rc = dct_sdhc_error_recovery(dev);
+		if (0 != rc) {
+			leave_critical_section(dev);
+			return rc;
+		}
+	}
+
+	if (NULL == data) {
+		int cnt = 0;
+		do {
+			rc = dct_sdhc_do_send_cmd(dev, &cmd_transfer_mode);
+			dct_sdhc_clr_irqs(dev, SD4HC_SRS_SRS12__CC_MASK);
+			if (0 == rc) {
+				if (RESPONSE_TYPE_SELECT_NO_RESPONSE !=
+					cmd_transfer_mode.response_type_select) {
+					memcpy(cmd->response, &(cmd_transfer_mode.response_data),
+						   sizeof(cmd->response));
+				} else {
+					memset(cmd->response, 0x00, sizeof(cmd->response));
+				}
+			} else if ((0 != (readl(&(SDHCI_SD4HC_SRS(dev)->srs12)) & SD4HC_SRS_SRS12__EINT_MASK)) ||
+					(0 != (readl(&(SDHCI_SD4HC_SRS(dev)->srs09)) & (SD4HC_SRS_SRS09__CICMD_MASK | SD4HC_SRS_SRS09__CIDAT_MASK)))) {
+				dct_sdhc_error_recovery(dev);
+			}
+		} while ((rc != 0) && (cnt++ < retries));
+	} else {
+		// NULL != data
+		if ((0 == data->blocksize) || (0 == data->blocks) || (NULL == data->src)) {
+			rc = -EINVAL;
+		} else if ((1 < data->blocks) &&
+				   (MMC_CMD_WRITE_MULTIPLE_BLOCK != cmd_transfer_mode.cmd_idx) &&
+				   (MMC_CMD_READ_MULTIPLE_BLOCK != cmd_transfer_mode.cmd_idx)) {
+			rc = -EINVAL;
+		} else if (((0 != (MMC_DATA_READ & data->flags)) && (0 != (MMC_DATA_WRITE & data->flags))) ||
+				   ((0 == (MMC_DATA_READ & data->flags)) && (0 == (MMC_DATA_WRITE & data->flags)))) {
+			rc = -EINVAL;
+		} else {
+			// rx / tx data available
+			bool disable_dma = true;
+			cmd_transfer_mode.data_present_select = 1;
+			switch (cmd_transfer_mode.cmd_idx) {
+				case MMC_CMD_READ_SINGLE_BLOCK:
+				case MMC_CMD_READ_MULTIPLE_BLOCK:
+				case MMC_CMD_WRITE_SINGLE_BLOCK:
+				case MMC_CMD_WRITE_MULTIPLE_BLOCK:
+					disable_dma = false;
+					break;
+				default:
+					disable_dma = true;
+					break;
+			} // end of switch
+			cmd_transfer_mode.block_select = (1 < data->blocks) ?
+				(BLOCK_SELECT_TYPE_MULTI_BLOCK) : (BLOCK_SELECT_TYPE_SINGLE_BLOCK);
+			cmd_transfer_mode.auto_cmd = (1 < data->blocks) ? (AUT0_CMD_12) : (AUT0_CMD_DISABLE);
+			cmd_transfer_mode.block_cnt_enable = (1 < data->blocks) ? (1) : (0);
+
+			uint32_t srs01 = 0;
+			srs01 = setBits(srs01, SD4HC_SRS_SRS01__SDMABB_MASK, SD4HC_SRS_SRS01__SDMABB_SHIFT, 0);
+			srs01 = setBits(srs01, SD4HC_SRS_SRS01__BCCT_MASK, SD4HC_SRS_SRS01__BCCT_SHIFT,
+					(1 < data->blocks) ? (data->blocks) : (0));
+			srs01 = setBits(srs01, SD4HC_SRS_SRS01__TBS_MASK, SD4HC_SRS_SRS01__TBS_SHIFT, data->blocksize);
+			writel(srs01, &(SDHCI_SD4HC_SRS(dev)->srs01));
+			cmd_transfer_mode.data_transfer_direction = (0 != (MMC_DATA_READ & data->flags)) ?
+				(DATA_TRANSFER_DIRECTION_READ) : (DATA_TRANSFER_DIRECTION_WRITE);
+			int cnt = 0;
+			do {
+				if (!disable_dma && cmd_transfer_mode.use_dma) {
+					cmd_transfer_mode.dma_enable = 1;
+					rc = dct_sdhc_card_dma_transfer(dev, &cmd_transfer_mode, data);
+				} else {
+					cmd_transfer_mode.dma_enable = 0;
+					rc = dct_sdhc_card_pio_transfer(dev, &cmd_transfer_mode, data);
+				}
+				if (0 == rc) {
+					if (RESPONSE_TYPE_SELECT_NO_RESPONSE !=
+						cmd_transfer_mode.response_type_select) {
+						memcpy(cmd->response,
+							   &(cmd_transfer_mode.response_data),
+							   sizeof(cmd->response));
+					} else {
+						memset(cmd->response, 0x00,
+							   sizeof(cmd->response));
+					}
+				} else if ((0 != ((readl(&(SDHCI_SD4HC_SRS(dev)->srs12)) & SD4HC_SRS_SRS12__EINT_MASK))) ||
+						(0 != (readl(&(SDHCI_SD4HC_SRS(dev)->srs09)) & (SD4HC_SRS_SRS09__CIDAT_MASK | SD4HC_SRS_SRS09__CICMD_MASK)))) {
+					dct_sdhc_error_recovery(dev);
+				}
+			} while ((rc != 0) && (++cnt < retries));
+		}
+	} // end NULL != data
+
+	leave_critical_section(dev);
+	return rc;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_set_ios(struct udevice *dev)
+{
+	log_debug("Enter %s, %d\n",  __FILE__, __LINE__);
+	int rc = 0;
+	const struct mmc* const mmc = mmc_get_mmc_dev(dev);
+
+	log_debug("bus_with      = %d\n", mmc->bus_width);
+	log_debug("clock         = %d Hz and %s\n", mmc->clock, (mmc->clk_disable) ? ("disabled") : ("enabled"));
+	log_debug("signal voltage = %u\n", mmc_voltage_to_mv(mmc->signal_voltage));
+	log_debug("bus mode       = %s\n",  mmc_mode_name(mmc->selected_mode));
+
+	// set bus width
+	CHECK_FUNC(dct_sdhc_set_bus_width(dev));
+	// set clk
+	CHECK_FUNC(dct_sdhc_set_clk(dev));
+	// set signal voltage
+	CHECK_FUNC(dct_sdhc_set_signal_voltage(dev));
+	// set bus mode
+	CHECK_FUNC(dct_sdhc_set_bus_mode(dev));
+
+	return rc;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_get_cd(struct udevice *dev)
+{
+	log_debug("Enter %s, %d\n",  __FILE__, __LINE__);
+	return (readl_slice(&(SDHCI_SD4HC_SRS(dev)->srs09), SD4HC_SRS_SRS09__CI_MASK, SD4HC_SRS_SRS09__CI_SHIFT));
+}
+
+// ---------------------------------------------------------
+
+#ifdef MMC_SUPPORTS_TUNING
+static int dct_sdhc_execute_tuning(struct udevice *dev, uint opcode)
+{
+	log_debug("Enter %s, %d\n",  __FILE__, __LINE__);
+	// TODO: not implemented
+
+	return 0;
+}
+#endif
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_wait_dat0(struct udevice *dev, int state,
+		int timeout_us)
+{
+	log_debug("Enter %s, %d\n",  __FILE__, __LINE__);
+
+	const uint32_t dat_msk = 1U << SD4HC_SRS_SRS09__DATSL1_SHIFT;
+	uint32_t srs09;
+	int rc = 0;
+	const uint32_t required_state = (0 == state) ? (0) : (1);
+
+	rc = read_poll_timeout(readl_slice,
+			srs09,
+			(required_state == srs09),
+			1,
+			timeout_us,
+			&(SDHCI_SD4HC_SRS(dev)->srs09),
+			dat_msk,
+			SD4HC_SRS_SRS09__DATSL1_SHIFT);
+
+	return rc;
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_host_power_cycle(struct udevice *dev)
+{
+	log_debug("Enter %s, %d\n",  __FILE__, __LINE__);
+
+	// PGPIO14 will be controlled via gpio_regulator
+	// but also host register must be set properly
+	// set VDD1 to 3,3V
+	writel_slice(0x7, &(SDHCI_SD4HC_SRS(dev)->srs10), SD4HC_SRS_SRS10__BVS_MASK, SD4HC_SRS_SRS10__BVS_SHIFT);
+	// enable VDD1
+	writel_slice(0x1, &(SDHCI_SD4HC_SRS(dev)->srs10), SD4HC_SRS_SRS10__BP_MASK, SD4HC_SRS_SRS10__BP_SHIFT);
+
+	return 0;
+}
+
+// ---------------------------------------------------------
+
+int dct_sdhc_get_b_max(struct udevice *dev, void *dst, lbaint_t blkcnt)
+{
+	log_debug("Enter %s, %d\n",  __FILE__, __LINE__);
+
+	return CONFIG_SYS_MMC_MAX_BLK_COUNT;
+}
+
+// ---------------------------------------------------------
+
+const struct dm_mmc_ops dct_sdhc_mmc_ops = {
+	.deferred_probe	  = dct_sdhc_deferred_probe,
+	.reinit			  = dct_sdhc_reinit,
+	.send_cmd		  = dct_sdhc_send_command,
+	.set_ios		  = dct_sdhc_set_ios,
+	.get_cd			  = dct_sdhc_get_cd,
+#ifdef MMC_SUPPORTS_TUNING
+	.execute_tuning	  = dct_sdhc_execute_tuning,
+#endif
+	.wait_dat0	      = dct_sdhc_wait_dat0,
+	.host_power_cycle = dct_sdhc_host_power_cycle,
+	.get_b_max        = dct_sdhc_get_b_max,
+};
+
+// ---------------------------------------------------------
+// ------------- Driver API functions ----------------------
+// ---------------------------------------------------------
+
+static int dct_sdhc_bind(struct udevice *dev)
+{
+	log_debug("Enter %s, %d\n",  __FILE__, __LINE__);
+	struct dct_sdhc_plat* const plat = dev_get_plat(dev);
+
+	return mmc_bind(dev, &plat->mmc, &plat->cfg);
+}
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_probe(struct udevice *dev)
+{
+	log_debug("Enter %s, %d\n",  __FILE__, __LINE__);
+	int rc = 0;
+
+	struct mmc_uclass_priv* const upriv = dev_get_uclass_priv(dev);
+	struct dct_sdhc_plat* const plat = dev_get_plat(dev);
+
+	plat->cfg.b_max = dct_sdhc_get_b_max(dev, NULL, 0);
+
+	upriv->mmc = &plat->mmc;
+
+#ifndef __UBOOT__
+	// install IRQ handler
+	CHECK_FUNC(install_irq_handler(dev));
+#endif
+	// init pins
+	CHECK_FUNC(init_pins(dev));
+	// Software Reset
+	writel(0x00, &(SDHCI_SD4HC_SRS(dev)->srs11));
+	// reset host
+	CHECK_FUNC(dct_sdhc_reset_host(dev));
+	// reset phy
+	CHECK_FUNC(dct_sdhc_init_phy(dev));
+	// enable all flags
+	CHECK_FUNC(dct_sdhc_enable_all_flags(dev));
+
+	return rc;
+};
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_remove(struct udevice *dev)
+{
+	log_debug("Enter %s, %d\n",  __FILE__, __LINE__);
+	// SDHCI_SD4HC_HRS(dev)->hrs04 = 0;
+	return 0;
+};
+
+// ---------------------------------------------------------
+
+static int dct_sdhc_unbind(struct udevice *dev)
+{
+	log_debug("Enter %s, %d\n",  __FILE__, __LINE__);
+	return 0;
+};
+
+// ---------------------------------------------------------
+// ---------------------------------------------------------
+
+static int dct_sdhc_of_to_plat(struct udevice *dev)
+{
+	log_debug("Enter %s, %d\n",  __FILE__, __LINE__);
+	int rc = 0;
+	struct dct_sdhc_plat *plat = dev_get_plat(dev);
+	struct mmc_config *cfg     = &(plat->cfg);
+	struct dct_sdhc_priv* const priv = dev_get_priv(dev);
+
+	// init data
+	CHECK_FUNC(dct_sdhc_init_data(dev));
+
+	fdt_addr_t base;
+
+	base = dev_read_addr(dev);
+	if (base == FDT_ADDR_T_NONE) {
+		log_err("no base address given by Device Tree\n");
+		return -EINVAL;
+	}
+	priv->base_addr = devm_ioremap(dev, base, SZ_1K);
+	priv->use_dma = dev_read_bool(dev, "use-dma");
+	priv->no_1_8_v = dev_read_bool(dev, "no-1-8-v");
+	if (0 != dev_read_u32(dev, "clock-frequency", &priv->sys_clk_hz)) {
+		log_err("no clock frequency given by Device Tree\n");
+		return -EINVAL;
+	}
+
+	// cfg->name = "DCT SD/MMC";
+	cfg->name = dev->name;
+	cfg->f_min = dev_read_u32_default(dev, "min-frequency", MIN_FREQUENCY); /* not parsed by mmc_of_parse */
+	cfg->f_max = dev_read_u32_default(dev, "max-frequency", MAX_FREQUENCY);
+	cfg->voltages = MMC_VDD_32_33 | MMC_VDD_33_34;
+	if (!priv->no_1_8_v) {
+		cfg->voltages |= MMC_VDD_165_195;
+	}
+
+	CHECK_FUNC(mmc_of_parse(dev, &(plat->cfg)));
+
+	return rc;
+};
+
+// ---------------------------------------------------------
+
+static const struct udevice_id dct_sdhc_match[] = {
+	{ .compatible = "dct,dct_sdhc", .data = 0 },
+	{ /* sentinel */ }
+};
+
+// ---------------------------------------------------------
+
+U_BOOT_DRIVER(dct_sdhc) = {
+	.name = "dct-sdhc",
+	.id			= UCLASS_MMC,
+	.of_match	= of_match_ptr(dct_sdhc_match),
+	.bind		= dct_sdhc_bind,
+	.probe		= dct_sdhc_probe,
+	.remove		= dct_sdhc_remove,
+	.unbind		= dct_sdhc_unbind,
+	.of_to_plat = dct_sdhc_of_to_plat,
+	.priv_auto = sizeof(struct dct_sdhc_priv),
+	.plat_auto = sizeof(struct dct_sdhc_plat),
+	.ops	   = &dct_sdhc_mmc_ops,
+};
+
diff --git a/include/dct/sd4hc_cqrs_regs.h b/include/dct/sd4hc_cqrs_regs.h
new file mode 100644
index 0000000000..83f7a12156
--- /dev/null
+++ b/include/dct/sd4hc_cqrs_regs.h
@@ -0,0 +1,960 @@
+ /*
+ * (C) Copyright 2023,
+ * Dream Chip Technologies
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#ifndef __SD4HC_CQRS_REGS_H__
+#define __SD4HC_CQRS_REGS_H__
+
+
+#include <stdint.h>
+
+//! Sd4hcCqrs Register layout
+typedef struct
+{
+  //! Register Group: sd4hc_cqrs
+  uint32_t _notused_0 [256]; // gap in address space
+  uint32_t cqrs00; //!< CQRS00 (slice) SD4HC_CQRS_BASE + 0x00000000
+  uint32_t cqrs01; //!< CQRS01 (slice) SD4HC_CQRS_BASE + 0x00000004
+  uint32_t cqrs02; //!< CQRS02 (slice) SD4HC_CQRS_BASE + 0x00000008
+  uint32_t cqrs03; //!< CQRS03 (slice) SD4HC_CQRS_BASE + 0x0000000c
+  uint32_t cqrs04; //!< CQRS04 (slice) SD4HC_CQRS_BASE + 0x00000010
+  uint32_t cqrs05; //!< CQRS05 (slice) SD4HC_CQRS_BASE + 0x00000014
+  uint32_t cqrs06; //!< CQRS06 (slice) SD4HC_CQRS_BASE + 0x00000018
+  uint32_t cqrs07; //!< CQRS07 (slice) SD4HC_CQRS_BASE + 0x0000001c
+  uint32_t cqrs08; //!< CQRS08 (slice) SD4HC_CQRS_BASE + 0x00000020
+  uint32_t cqrs09; //!< CQRS09 (slice) SD4HC_CQRS_BASE + 0x00000024
+  uint32_t cqrs10; //!< CQRS10 (slice) SD4HC_CQRS_BASE + 0x00000028
+  uint32_t cqrs11; //!< CQRS11 (slice) SD4HC_CQRS_BASE + 0x0000002c
+  uint32_t cqrs12; //!< CQRS12 (slice) SD4HC_CQRS_BASE + 0x00000030
+  uint32_t cqrs13; //!< CQRS13 (slice) SD4HC_CQRS_BASE + 0x00000034
+  uint32_t cqrs14; //!< CQRS14 (slice) SD4HC_CQRS_BASE + 0x00000038
+  uint32_t _notused_1 [1]; // gap in address space
+  uint32_t cqrs16; //!< CQRS16 (slice) SD4HC_CQRS_BASE + 0x00000040
+  uint32_t cqrs17; //!< CQRS17 (slice) SD4HC_CQRS_BASE + 0x00000044
+  uint32_t cqrs18; //!< CQRS18 (slice) SD4HC_CQRS_BASE + 0x00000048
+  uint32_t _notused_2 [1]; // gap in address space
+  uint32_t cqrs20; //!< CQRS20 (slice) SD4HC_CQRS_BASE + 0x00000050
+  uint32_t cqrs21; //!< CQRS21 (slice) SD4HC_CQRS_BASE + 0x00000054
+  uint32_t cqrs22; //!< CQRS22 (slice) SD4HC_CQRS_BASE + 0x00000058
+  uint32_t cqrs23; //!< CQRS23 (slice) SD4HC_CQRS_BASE + 0x0000005c
+} Sd4hcCqrsRegister_t;
+
+
+// - MASK AND SHIFT MACROS ----------------------------------------------------------
+
+//! Register Group: sd4hc_cqrs
+
+//! Register: cqrs00: CQRS00 (SD4HC_CQRS_BASE + 0x00000000)
+//! Slice: CQRS00__CQVN3:
+//! CQVN3 - eMMC Version Suffix\n Suffix version number of supported eMMC standard - 0.
+#define SD4HC_CQRS_CQRS00__CQVN3
+#define SD4HC_CQRS_CQRS00__CQVN3_MASK 0x0000000FU
+#define SD4HC_CQRS_CQRS00__CQVN3_SHIFT 0U
+//! Slice: CQRS00__CQVN2:
+//! CQVN2 - eMMC Minor Version Number\n Minor version number of supported eMMC standard - 1.
+#define SD4HC_CQRS_CQRS00__CQVN2
+#define SD4HC_CQRS_CQRS00__CQVN2_MASK 0x000000F0U
+#define SD4HC_CQRS_CQRS00__CQVN2_SHIFT 4U
+//! Slice: CQRS00__CQVN1:
+//! CQVN1 - eMMC Major Version Number\n Major version number of supported eMMC standard - 5.
+#define SD4HC_CQRS_CQRS00__CQVN1
+#define SD4HC_CQRS_CQRS00__CQVN1_MASK 0x00000F00U
+#define SD4HC_CQRS_CQRS00__CQVN1_SHIFT 8U
+
+//! Register: cqrs01: CQRS01 (SD4HC_CQRS_BASE + 0x00000004)
+//! Slice: CQRS01__ITCFVAL:
+//! ITCFVAL - Internal Timer Clock Frequency Value (ITCFVAL)\n Value defines internal clock frequency for the coalescing timer and for the SQS polling period. The frequency is equal to ITCFMUL * ITCFVAL.
+#define SD4HC_CQRS_CQRS01__ITCFVAL
+#define SD4HC_CQRS_CQRS01__ITCFVAL_MASK 0x000003FFU
+#define SD4HC_CQRS_CQRS01__ITCFVAL_SHIFT 0U
+//! Slice: CQRS01__ITCFMUL:
+//! ITCFMUL - Internal Timer Clock Frequency Multiplier (ITCFMUL)\n Defines multiplier of internal clock frequency for the coalescing timer and for the SQS polling period.\n 0 - 0.001 MHz\n 1 - 0.01 MHz\n 2 - 0.1 MHz\n 3 - 1 MHz\n 4 - 10 MHz\n The ITCFMUL and ITCFVAL defines the clock frequency.
+#define SD4HC_CQRS_CQRS01__ITCFMUL
+#define SD4HC_CQRS_CQRS01__ITCFMUL_MASK 0x0000F000U
+#define SD4HC_CQRS_CQRS01__ITCFMUL_SHIFT 12U
+
+//! Register: cqrs02: CQRS02 (SD4HC_CQRS_BASE + 0x00000008)
+//! Slice: CQRS02__CQE:
+//! CQE - Command Queuing Enable\n Enables (1) or disables (0) the Command Queuing. This bit can be enabled only when all previous transactions are completed. This bit can be cleared only when all tasks are completed or cleared.\n Setting this bit to 1, set SRS15.HV4E automatically to 1.
+#define SD4HC_CQRS_CQRS02__CQE
+#define SD4HC_CQRS_CQRS02__CQE_MASK 0x00000001U
+#define SD4HC_CQRS_CQRS02__CQE_SHIFT 0U
+//! Slice: CQRS02__CQTDS:
+//! CQTDS - Task Descriptor\n Size Expect 128 bit (1) or 64 bit (0) task descriptor. This setting can be changed only when Command Queuing is disabled (CQE = 0).
+#define SD4HC_CQRS_CQRS02__CQTDS
+#define SD4HC_CQRS_CQRS02__CQTDS_MASK 0x00000100U
+#define SD4HC_CQRS_CQRS02__CQTDS_SHIFT 8U
+//! Slice: CQRS02__CQDCE:
+//! CQDCE - Direct Command (DCMD) Enable\n Process Task Descriptor for slot 31 as Data Transfer Task Descriptor (0) or Direct Command Task Descriptor (1).
+#define SD4HC_CQRS_CQRS02__CQDCE
+#define SD4HC_CQRS_CQRS02__CQDCE_MASK 0x00001000U
+#define SD4HC_CQRS_CQRS02__CQDCE_SHIFT 12U
+
+//! Register: cqrs03: CQRS03 (SD4HC_CQRS_BASE + 0x0000000c)
+//! Slice: CQRS03__CQHLT:
+//! CQHLT - Halt CQ\n Engine can be halted by writing this bit 1. Any pending operation will be completed, and awaiting operation will be stopped. Once all tasks are completed or stopped this bit is set 1. The host controller will not automatically start any new operation, but software can use SRS registers to issue any command directly bypassing CQE. CQ Engine starts operation after being halted by writing 0 to this register. Writing 0 is ignored when CQ Engine is not halted.
+#define SD4HC_CQRS_CQRS03__CQHLT
+#define SD4HC_CQRS_CQRS03__CQHLT_MASK 0x00000001U
+#define SD4HC_CQRS_CQRS03__CQHLT_SHIFT 0U
+//! Slice: CQRS03__CQCAT:
+//! CQCAT - Clear All Tasks\n Clears (1) all active tasks in the host controller. Software has to poll this register until operation is completed (bit is automatically cleared). Software can set this bit only when the CQ Engine is halted. Software has to clear all requested tasks in the eMMC device. Writing (0) has no effect.
+#define SD4HC_CQRS_CQRS03__CQCAT
+#define SD4HC_CQRS_CQRS03__CQCAT_MASK 0x00000100U
+#define SD4HC_CQRS_CQRS03__CQCAT_SHIFT 8U
+
+//! Register: cqrs04: CQRS04 (SD4HC_CQRS_BASE + 0x00000010)
+//! Slice: CQRS04__CQHAC:
+//! CQHAC - Halt Complete Interrupt (HAC)\n CQE sets this bit when value of CQHLT changed from 0 to 1.
+#define SD4HC_CQRS_CQRS04__CQHAC
+#define SD4HC_CQRS_CQRS04__CQHAC_MASK 0x00000001U
+#define SD4HC_CQRS_CQRS04__CQHAC_SHIFT 0U
+//! Slice: CQRS04__CQTCC:
+//! CQTCC - Task Complete Interrupt (TCC)\n CQE sets this bit when either a task with INT=1 is completed or Interrupt Coalescing reports interrupt.
+#define SD4HC_CQRS_CQRS04__CQTCC
+#define SD4HC_CQRS_CQRS04__CQTCC_MASK 0x00000002U
+#define SD4HC_CQRS_CQRS04__CQTCC_SHIFT 1U
+//! Slice: CQRS04__CQREDI:
+//! CQREDI - Response Error Detected Interrupt (RED)\n When an error is detected in the response received from eMMC device, the CQE sets this bit to 1. S/W can select which bits are analyzed by selecting CQRMEM.
+#define SD4HC_CQRS_CQRS04__CQREDI
+#define SD4HC_CQRS_CQRS04__CQREDI_MASK 0x00000004U
+#define SD4HC_CQRS_CQRS04__CQREDI_SHIFT 2U
+//! Slice: CQRS04__CQTCL:
+//! CQTCL - Task Cleared (TCL)\n When task clear operation or clear individual task is completed, the CQE sets this bit to 1.
+#define SD4HC_CQRS_CQRS04__CQTCL
+#define SD4HC_CQRS_CQRS04__CQTCL_MASK 0x00000008U
+#define SD4HC_CQRS_CQRS04__CQTCL_SHIFT 3U
+
+//! Register: cqrs05: CQRS05 (SD4HC_CQRS_BASE + 0x00000014)
+//! Slice: CQRS05__CQHACST:
+//! CQHACST - Halt Complete Status Enable (HAC)\n Enables CQTCLST register.
+#define SD4HC_CQRS_CQRS05__CQHACST
+#define SD4HC_CQRS_CQRS05__CQHACST_MASK 0x00000001U
+#define SD4HC_CQRS_CQRS05__CQHACST_SHIFT 0U
+//! Slice: CQRS05__CQTCCST:
+//! CQTCCST - Task Complete Status Enable (TCC)\n Enables CQHAC register.
+#define SD4HC_CQRS_CQRS05__CQTCCST
+#define SD4HC_CQRS_CQRS05__CQTCCST_MASK 0x00000002U
+#define SD4HC_CQRS_CQRS05__CQTCCST_SHIFT 1U
+//! Slice: CQRS05__CQREDST:
+//! CQREDST - Response Error Detected Status Enable (RED)\n Enables CQREDI register.
+#define SD4HC_CQRS_CQRS05__CQREDST
+#define SD4HC_CQRS_CQRS05__CQREDST_MASK 0x00000004U
+#define SD4HC_CQRS_CQRS05__CQREDST_SHIFT 2U
+//! Slice: CQRS05__CQTCLST:
+//! CQTCLST - Task Cleared Status Enable (TCL)\n Enables CQTCL register.
+#define SD4HC_CQRS_CQRS05__CQTCLST
+#define SD4HC_CQRS_CQRS05__CQTCLST_MASK 0x00000008U
+#define SD4HC_CQRS_CQRS05__CQTCLST_SHIFT 3U
+
+//! Register: cqrs06: CQRS06 (SD4HC_CQRS_BASE + 0x00000018)
+//! Slice: CQRS06__CQHACSI:
+//! CQHACSI - Halt Complete Signal Enable (HAC)\n Enables interrupt signaling from CQHLT register.
+#define SD4HC_CQRS_CQRS06__CQHACSI
+#define SD4HC_CQRS_CQRS06__CQHACSI_MASK 0x00000001U
+#define SD4HC_CQRS_CQRS06__CQHACSI_SHIFT 0U
+//! Slice: CQRS06__CQTCCSI:
+//! CQTCCSI - Task Complete Signal Enable (TCC)\n Enables interrupt signaling from CQTCC register.
+#define SD4HC_CQRS_CQRS06__CQTCCSI
+#define SD4HC_CQRS_CQRS06__CQTCCSI_MASK 0x00000002U
+#define SD4HC_CQRS_CQRS06__CQTCCSI_SHIFT 1U
+//! Slice: CQRS06__CQREDSI:
+//! CQREDSI - Response Error Detected Signal Enable (TCC)\n Enables interrupt signaling from CQREDI register.
+#define SD4HC_CQRS_CQRS06__CQREDSI
+#define SD4HC_CQRS_CQRS06__CQREDSI_MASK 0x00000004U
+#define SD4HC_CQRS_CQRS06__CQREDSI_SHIFT 2U
+//! Slice: CQRS06__CQTCLSI:
+//! CQTCLSI - Task Cleared Signal Enable (TCL)\n Enables interrupt signaling from CQTCL register.
+#define SD4HC_CQRS_CQRS06__CQTCLSI
+#define SD4HC_CQRS_CQRS06__CQTCLSI_MASK 0x00000008U
+#define SD4HC_CQRS_CQRS06__CQTCLSI_SHIFT 3U
+
+//! Register: cqrs07: CQRS07 (SD4HC_CQRS_BASE + 0x0000001c)
+//! Slice: CQRS07__CQICTOVAL:
+//! CQICTOVAL - Interrupt Coalescing Timeout Value (ICTOVAL)\n CQE generates interrupt when internal counter reaches period defined in this field. The counter starts when first transfer with INT=0 is completed. The counter increments each time when Internal Clock * 1024 period elapsed. S/W can disable this timer by setting this filed to 0.
+#define SD4HC_CQRS_CQRS07__CQICTOVAL
+#define SD4HC_CQRS_CQRS07__CQICTOVAL_MASK 0x0000007FU
+#define SD4HC_CQRS_CQRS07__CQICTOVAL_SHIFT 0U
+//! Slice: CQRS07__CQICTOVALEN:
+//! CQICTOVALEN - Interrupt Coalescing Timeout Value Write Enable (ICTOVALWEN)\n This is write enable for CQICTOVAL. When this bit is set 1, the field will be updated.
+#define SD4HC_CQRS_CQRS07__CQICTOVALEN
+#define SD4HC_CQRS_CQRS07__CQICTOVALEN_MASK 0x00000080U
+#define SD4HC_CQRS_CQRS07__CQICTOVALEN_SHIFT 7U
+//! Slice: CQRS07__CQICCTH:
+//! CQICCTH - Interrupt Coalescing Counter Threshold (ICCTH)\n CQE increments internal counter when task with INT=0 is completed. When internal counter reaches this value the coalescing generates interrupt. S/W can select treshold value in range 1 to 31. S/W can disable internal counter and interrupt generation by setting this field to 0.
+#define SD4HC_CQRS_CQRS07__CQICCTH
+#define SD4HC_CQRS_CQRS07__CQICCTH_MASK 0x00001F00U
+#define SD4HC_CQRS_CQRS07__CQICCTH_SHIFT 8U
+//! Slice: CQRS07__CQICCTHWEN:
+//! CQICCTHWEN - Interrupt Coalescing Counter Threshold Write Enable (ICCTHWEN)\n This is write enable for CQICCTH. When this bit is set 1, the field will be updated.
+#define SD4HC_CQRS_CQRS07__CQICCTHWEN
+#define SD4HC_CQRS_CQRS07__CQICCTHWEN_MASK 0x00008000U
+#define SD4HC_CQRS_CQRS07__CQICCTHWEN_SHIFT 15U
+//! Slice: CQRS07__CQICCTR:
+//! CQICCTR - Counter and Timer Reset(ICCTR)\n S/W resets interrupt coalescing timer and counter.
+#define SD4HC_CQRS_CQRS07__CQICCTR
+#define SD4HC_CQRS_CQRS07__CQICCTR_MASK 0x00010000U
+#define SD4HC_CQRS_CQRS07__CQICCTR_SHIFT 16U
+//! Slice: CQRS07__CQICSB:
+//! CQICSB - Interrupt Coalescing Status Bit (ICSB)\n CQE sets this bit 1 when any task with INT=0 is completed.
+#define SD4HC_CQRS_CQRS07__CQICSB
+#define SD4HC_CQRS_CQRS07__CQICSB_MASK 0x00100000U
+#define SD4HC_CQRS_CQRS07__CQICSB_SHIFT 20U
+//! Slice: CQRS07__CQICED:
+//! CQICED - Interrupt Coalescing Enable/Disable\n Enables coalescing mechanism allowing to generate coalescing interrupts.
+#define SD4HC_CQRS_CQRS07__CQICED
+#define SD4HC_CQRS_CQRS07__CQICED_MASK 0x80000000U
+#define SD4HC_CQRS_CQRS07__CQICED_SHIFT 31U
+
+//! Register: cqrs08: CQRS08 (SD4HC_CQRS_BASE + 0x00000020)
+//! Slice: CQRS08__CQTDLBA:
+//! CQTDLBA - Task Descriptor List Base Address (lower)\n Base address (32 lower bits) of the Task Descriptor List. S/W will write values aligned to 1kB boundary (lower 10 bits have to be 0). The hardware ignores 10 lower bits.\n S/W will update this register only when CQE is disabled.
+#define SD4HC_CQRS_CQRS08__CQTDLBA
+#define SD4HC_CQRS_CQRS08__CQTDLBA_MASK 0xFFFFFFFFU
+#define SD4HC_CQRS_CQRS08__CQTDLBA_SHIFT 0U
+
+//! Register: cqrs09: CQRS09 (SD4HC_CQRS_BASE + 0x00000024)
+//! Slice: CQRS09__CQTDLBAU:
+//! CQTDLBAU - Task Descriptor List Base Address (upper)\n Base address (32 upper bits) of the Task descriptor List. This register is not used in 32 bit addressing mode (S/W does not change this value). S/W will update this register only when CQE is disabled.
+#define SD4HC_CQRS_CQRS09__CQTDLBAU
+#define SD4HC_CQRS_CQRS09__CQTDLBAU_MASK 0xFFFFFFFFU
+#define SD4HC_CQRS_CQRS09__CQTDLBAU_SHIFT 0U
+
+//! Register: cqrs10: CQRS10 (SD4HC_CQRS_BASE + 0x00000028)
+//! Slice: CQRS10__CQTD00:
+//! CQTD00 - Command Queuing Task Doorbell #00
+#define SD4HC_CQRS_CQRS10__CQTD00
+#define SD4HC_CQRS_CQRS10__CQTD00_MASK 0x00000001U
+#define SD4HC_CQRS_CQRS10__CQTD00_SHIFT 0U
+//! Slice: CQRS10__CQTD01:
+//! CQTD01 - Command Queuing Task Doorbell #01
+#define SD4HC_CQRS_CQRS10__CQTD01
+#define SD4HC_CQRS_CQRS10__CQTD01_MASK 0x00000002U
+#define SD4HC_CQRS_CQRS10__CQTD01_SHIFT 1U
+//! Slice: CQRS10__CQTD02:
+//! CQTD02 - Command Queuing Task Doorbell #02
+#define SD4HC_CQRS_CQRS10__CQTD02
+#define SD4HC_CQRS_CQRS10__CQTD02_MASK 0x00000004U
+#define SD4HC_CQRS_CQRS10__CQTD02_SHIFT 2U
+//! Slice: CQRS10__CQTD03:
+//! CQTD03 - Command Queuing Task Doorbell #03
+#define SD4HC_CQRS_CQRS10__CQTD03
+#define SD4HC_CQRS_CQRS10__CQTD03_MASK 0x00000008U
+#define SD4HC_CQRS_CQRS10__CQTD03_SHIFT 3U
+//! Slice: CQRS10__CQTD04:
+//! CQTD04 - Command Queuing Task Doorbell #04
+#define SD4HC_CQRS_CQRS10__CQTD04
+#define SD4HC_CQRS_CQRS10__CQTD04_MASK 0x00000010U
+#define SD4HC_CQRS_CQRS10__CQTD04_SHIFT 4U
+//! Slice: CQRS10__CQTD05:
+//! CQTD05 - Command Queuing Task Doorbell #05
+#define SD4HC_CQRS_CQRS10__CQTD05
+#define SD4HC_CQRS_CQRS10__CQTD05_MASK 0x00000020U
+#define SD4HC_CQRS_CQRS10__CQTD05_SHIFT 5U
+//! Slice: CQRS10__CQTD06:
+//! CQTD06 - Command Queuing Task Doorbell #06
+#define SD4HC_CQRS_CQRS10__CQTD06
+#define SD4HC_CQRS_CQRS10__CQTD06_MASK 0x00000040U
+#define SD4HC_CQRS_CQRS10__CQTD06_SHIFT 6U
+//! Slice: CQRS10__CQTD07:
+//! CQTD07 - Command Queuing Task Doorbell #07
+#define SD4HC_CQRS_CQRS10__CQTD07
+#define SD4HC_CQRS_CQRS10__CQTD07_MASK 0x00000080U
+#define SD4HC_CQRS_CQRS10__CQTD07_SHIFT 7U
+//! Slice: CQRS10__CQTD08:
+//! CQTD08 - Command Queuing Task Doorbell #08
+#define SD4HC_CQRS_CQRS10__CQTD08
+#define SD4HC_CQRS_CQRS10__CQTD08_MASK 0x00000100U
+#define SD4HC_CQRS_CQRS10__CQTD08_SHIFT 8U
+//! Slice: CQRS10__CQTD09:
+//! CQTD09 - Command Queuing Task Doorbell #09
+#define SD4HC_CQRS_CQRS10__CQTD09
+#define SD4HC_CQRS_CQRS10__CQTD09_MASK 0x00000200U
+#define SD4HC_CQRS_CQRS10__CQTD09_SHIFT 9U
+//! Slice: CQRS10__CQTD10:
+//! CQTD10 - Command Queuing Task Doorbell #10
+#define SD4HC_CQRS_CQRS10__CQTD10
+#define SD4HC_CQRS_CQRS10__CQTD10_MASK 0x00000400U
+#define SD4HC_CQRS_CQRS10__CQTD10_SHIFT 10U
+//! Slice: CQRS10__CQTD11:
+//! CQTD11 - Command Queuing Task Doorbell #11
+#define SD4HC_CQRS_CQRS10__CQTD11
+#define SD4HC_CQRS_CQRS10__CQTD11_MASK 0x00000800U
+#define SD4HC_CQRS_CQRS10__CQTD11_SHIFT 11U
+//! Slice: CQRS10__CQTD12:
+//! CQTD12 - Command Queuing Task Doorbell #12
+#define SD4HC_CQRS_CQRS10__CQTD12
+#define SD4HC_CQRS_CQRS10__CQTD12_MASK 0x00001000U
+#define SD4HC_CQRS_CQRS10__CQTD12_SHIFT 12U
+//! Slice: CQRS10__CQTD13:
+//! CQTD13 - Command Queuing Task Doorbell #13
+#define SD4HC_CQRS_CQRS10__CQTD13
+#define SD4HC_CQRS_CQRS10__CQTD13_MASK 0x00002000U
+#define SD4HC_CQRS_CQRS10__CQTD13_SHIFT 13U
+//! Slice: CQRS10__CQTD14:
+//! CQTD14 - Command Queuing Task Doorbell #14
+#define SD4HC_CQRS_CQRS10__CQTD14
+#define SD4HC_CQRS_CQRS10__CQTD14_MASK 0x00004000U
+#define SD4HC_CQRS_CQRS10__CQTD14_SHIFT 14U
+//! Slice: CQRS10__CQTD15:
+//! CQTD15 - Command Queuing Task Doorbell #15
+#define SD4HC_CQRS_CQRS10__CQTD15
+#define SD4HC_CQRS_CQRS10__CQTD15_MASK 0x00008000U
+#define SD4HC_CQRS_CQRS10__CQTD15_SHIFT 15U
+//! Slice: CQRS10__CQTD16:
+//! CQTD16 - Command Queuing Task Doorbell #16
+#define SD4HC_CQRS_CQRS10__CQTD16
+#define SD4HC_CQRS_CQRS10__CQTD16_MASK 0x00010000U
+#define SD4HC_CQRS_CQRS10__CQTD16_SHIFT 16U
+//! Slice: CQRS10__CQTD17:
+//! CQTD17 - Command Queuing Task Doorbell #17
+#define SD4HC_CQRS_CQRS10__CQTD17
+#define SD4HC_CQRS_CQRS10__CQTD17_MASK 0x00020000U
+#define SD4HC_CQRS_CQRS10__CQTD17_SHIFT 17U
+//! Slice: CQRS10__CQTD18:
+//! CQTD18 - Command Queuing Task Doorbell #18
+#define SD4HC_CQRS_CQRS10__CQTD18
+#define SD4HC_CQRS_CQRS10__CQTD18_MASK 0x00040000U
+#define SD4HC_CQRS_CQRS10__CQTD18_SHIFT 18U
+//! Slice: CQRS10__CQTD19:
+//! CQTD19 - Command Queuing Task Doorbell #19
+#define SD4HC_CQRS_CQRS10__CQTD19
+#define SD4HC_CQRS_CQRS10__CQTD19_MASK 0x00080000U
+#define SD4HC_CQRS_CQRS10__CQTD19_SHIFT 19U
+//! Slice: CQRS10__CQTD20:
+//! CQTD20 - Command Queuing Task Doorbell #20
+#define SD4HC_CQRS_CQRS10__CQTD20
+#define SD4HC_CQRS_CQRS10__CQTD20_MASK 0x00100000U
+#define SD4HC_CQRS_CQRS10__CQTD20_SHIFT 20U
+//! Slice: CQRS10__CQTD21:
+//! CQTD21 - Command Queuing Task Doorbell #21
+#define SD4HC_CQRS_CQRS10__CQTD21
+#define SD4HC_CQRS_CQRS10__CQTD21_MASK 0x00200000U
+#define SD4HC_CQRS_CQRS10__CQTD21_SHIFT 21U
+//! Slice: CQRS10__CQTD22:
+//! CQTD22 - Command Queuing Task Doorbell #22
+#define SD4HC_CQRS_CQRS10__CQTD22
+#define SD4HC_CQRS_CQRS10__CQTD22_MASK 0x00400000U
+#define SD4HC_CQRS_CQRS10__CQTD22_SHIFT 22U
+//! Slice: CQRS10__CQTD23:
+//! CQTD23 - Command Queuing Task Doorbell #23
+#define SD4HC_CQRS_CQRS10__CQTD23
+#define SD4HC_CQRS_CQRS10__CQTD23_MASK 0x00800000U
+#define SD4HC_CQRS_CQRS10__CQTD23_SHIFT 23U
+//! Slice: CQRS10__CQTD24:
+//! CQTD24 - Command Queuing Task Doorbell #24
+#define SD4HC_CQRS_CQRS10__CQTD24
+#define SD4HC_CQRS_CQRS10__CQTD24_MASK 0x01000000U
+#define SD4HC_CQRS_CQRS10__CQTD24_SHIFT 24U
+//! Slice: CQRS10__CQTD25:
+//! CQTD25 - Command Queuing Task Doorbell #25
+#define SD4HC_CQRS_CQRS10__CQTD25
+#define SD4HC_CQRS_CQRS10__CQTD25_MASK 0x02000000U
+#define SD4HC_CQRS_CQRS10__CQTD25_SHIFT 25U
+//! Slice: CQRS10__CQTD26:
+//! CQTD26 - Command Queuing Task Doorbell #26
+#define SD4HC_CQRS_CQRS10__CQTD26
+#define SD4HC_CQRS_CQRS10__CQTD26_MASK 0x04000000U
+#define SD4HC_CQRS_CQRS10__CQTD26_SHIFT 26U
+//! Slice: CQRS10__CQTD27:
+//! CQTD27 - Command Queuing Task Doorbell #27
+#define SD4HC_CQRS_CQRS10__CQTD27
+#define SD4HC_CQRS_CQRS10__CQTD27_MASK 0x08000000U
+#define SD4HC_CQRS_CQRS10__CQTD27_SHIFT 27U
+//! Slice: CQRS10__CQTD28:
+//! CQTD28 - Command Queuing Task Doorbell #28
+#define SD4HC_CQRS_CQRS10__CQTD28
+#define SD4HC_CQRS_CQRS10__CQTD28_MASK 0x10000000U
+#define SD4HC_CQRS_CQRS10__CQTD28_SHIFT 28U
+//! Slice: CQRS10__CQTD29:
+//! CQTD29 - Command Queuing Task Doorbell #29
+#define SD4HC_CQRS_CQRS10__CQTD29
+#define SD4HC_CQRS_CQRS10__CQTD29_MASK 0x20000000U
+#define SD4HC_CQRS_CQRS10__CQTD29_SHIFT 29U
+//! Slice: CQRS10__CQTD30:
+//! CQTD30 - Command Queuing Task Doorbell #30
+#define SD4HC_CQRS_CQRS10__CQTD30
+#define SD4HC_CQRS_CQRS10__CQTD30_MASK 0x40000000U
+#define SD4HC_CQRS_CQRS10__CQTD30_SHIFT 30U
+//! Slice: CQRS10__CQTD31:
+//! CQTD31 - Command Queuing Task Doorbell #31
+#define SD4HC_CQRS_CQRS10__CQTD31
+#define SD4HC_CQRS_CQRS10__CQTD31_MASK 0x80000000U
+#define SD4HC_CQRS_CQRS10__CQTD31_SHIFT 31U
+
+//! Register: cqrs11: CQRS11 (SD4HC_CQRS_BASE + 0x0000002c)
+//! Slice: CQRS11__CQTCN00:
+//! CQTCN00 - Task Completion Notification #00
+#define SD4HC_CQRS_CQRS11__CQTCN00
+#define SD4HC_CQRS_CQRS11__CQTCN00_MASK 0x00000001U
+#define SD4HC_CQRS_CQRS11__CQTCN00_SHIFT 0U
+//! Slice: CQRS11__CQTCN01:
+//! CQTCN01 - Task Completion Notification #01
+#define SD4HC_CQRS_CQRS11__CQTCN01
+#define SD4HC_CQRS_CQRS11__CQTCN01_MASK 0x00000002U
+#define SD4HC_CQRS_CQRS11__CQTCN01_SHIFT 1U
+//! Slice: CQRS11__CQTCN02:
+//! CQTCN02 - Task Completion Notification #02
+#define SD4HC_CQRS_CQRS11__CQTCN02
+#define SD4HC_CQRS_CQRS11__CQTCN02_MASK 0x00000004U
+#define SD4HC_CQRS_CQRS11__CQTCN02_SHIFT 2U
+//! Slice: CQRS11__CQTCN03:
+//! CQTCN03 - Task Completion Notification #03
+#define SD4HC_CQRS_CQRS11__CQTCN03
+#define SD4HC_CQRS_CQRS11__CQTCN03_MASK 0x00000008U
+#define SD4HC_CQRS_CQRS11__CQTCN03_SHIFT 3U
+//! Slice: CQRS11__CQTCN04:
+//! CQTCN04 - Task Completion Notification #04
+#define SD4HC_CQRS_CQRS11__CQTCN04
+#define SD4HC_CQRS_CQRS11__CQTCN04_MASK 0x00000010U
+#define SD4HC_CQRS_CQRS11__CQTCN04_SHIFT 4U
+//! Slice: CQRS11__CQTCN05:
+//! CQTCN05 - Task Completion Notification #05
+#define SD4HC_CQRS_CQRS11__CQTCN05
+#define SD4HC_CQRS_CQRS11__CQTCN05_MASK 0x00000020U
+#define SD4HC_CQRS_CQRS11__CQTCN05_SHIFT 5U
+//! Slice: CQRS11__CQTCN06:
+//! CQTCN06 - Task Completion Notification #06
+#define SD4HC_CQRS_CQRS11__CQTCN06
+#define SD4HC_CQRS_CQRS11__CQTCN06_MASK 0x00000040U
+#define SD4HC_CQRS_CQRS11__CQTCN06_SHIFT 6U
+//! Slice: CQRS11__CQTCN07:
+//! CQTCN07 - Task Completion Notification #07
+#define SD4HC_CQRS_CQRS11__CQTCN07
+#define SD4HC_CQRS_CQRS11__CQTCN07_MASK 0x00000080U
+#define SD4HC_CQRS_CQRS11__CQTCN07_SHIFT 7U
+//! Slice: CQRS11__CQTCN08:
+//! CQTCN08 - Task Completion Notification #08
+#define SD4HC_CQRS_CQRS11__CQTCN08
+#define SD4HC_CQRS_CQRS11__CQTCN08_MASK 0x00000100U
+#define SD4HC_CQRS_CQRS11__CQTCN08_SHIFT 8U
+//! Slice: CQRS11__CQTCN09:
+//! CQTCN09 - Task Completion Notification #09
+#define SD4HC_CQRS_CQRS11__CQTCN09
+#define SD4HC_CQRS_CQRS11__CQTCN09_MASK 0x00000200U
+#define SD4HC_CQRS_CQRS11__CQTCN09_SHIFT 9U
+//! Slice: CQRS11__CQTCN10:
+//! CQTCN10 - Task Completion Notification #10
+#define SD4HC_CQRS_CQRS11__CQTCN10
+#define SD4HC_CQRS_CQRS11__CQTCN10_MASK 0x00000400U
+#define SD4HC_CQRS_CQRS11__CQTCN10_SHIFT 10U
+//! Slice: CQRS11__CQTCN11:
+//! CQTCN11 - Task Completion Notification #11
+#define SD4HC_CQRS_CQRS11__CQTCN11
+#define SD4HC_CQRS_CQRS11__CQTCN11_MASK 0x00000800U
+#define SD4HC_CQRS_CQRS11__CQTCN11_SHIFT 11U
+//! Slice: CQRS11__CQTCN12:
+//! CQTCN12 - Task Completion Notification #12
+#define SD4HC_CQRS_CQRS11__CQTCN12
+#define SD4HC_CQRS_CQRS11__CQTCN12_MASK 0x00001000U
+#define SD4HC_CQRS_CQRS11__CQTCN12_SHIFT 12U
+//! Slice: CQRS11__CQTCN13:
+//! CQTCN13 - Task Completion Notification #13
+#define SD4HC_CQRS_CQRS11__CQTCN13
+#define SD4HC_CQRS_CQRS11__CQTCN13_MASK 0x00002000U
+#define SD4HC_CQRS_CQRS11__CQTCN13_SHIFT 13U
+//! Slice: CQRS11__CQTCN14:
+//! CQTCN14 - Task Completion Notification #14
+#define SD4HC_CQRS_CQRS11__CQTCN14
+#define SD4HC_CQRS_CQRS11__CQTCN14_MASK 0x00004000U
+#define SD4HC_CQRS_CQRS11__CQTCN14_SHIFT 14U
+//! Slice: CQRS11__CQTCN15:
+//! CQTCN15 - Task Completion Notification #15
+#define SD4HC_CQRS_CQRS11__CQTCN15
+#define SD4HC_CQRS_CQRS11__CQTCN15_MASK 0x00008000U
+#define SD4HC_CQRS_CQRS11__CQTCN15_SHIFT 15U
+//! Slice: CQRS11__CQTCN16:
+//! CQTCN16 - Task Completion Notification #16
+#define SD4HC_CQRS_CQRS11__CQTCN16
+#define SD4HC_CQRS_CQRS11__CQTCN16_MASK 0x00010000U
+#define SD4HC_CQRS_CQRS11__CQTCN16_SHIFT 16U
+//! Slice: CQRS11__CQTCN17:
+//! CQTCN17 - Task Completion Notification #17
+#define SD4HC_CQRS_CQRS11__CQTCN17
+#define SD4HC_CQRS_CQRS11__CQTCN17_MASK 0x00020000U
+#define SD4HC_CQRS_CQRS11__CQTCN17_SHIFT 17U
+//! Slice: CQRS11__CQTCN18:
+//! CQTCN18 - Task Completion Notification #18
+#define SD4HC_CQRS_CQRS11__CQTCN18
+#define SD4HC_CQRS_CQRS11__CQTCN18_MASK 0x00040000U
+#define SD4HC_CQRS_CQRS11__CQTCN18_SHIFT 18U
+//! Slice: CQRS11__CQTCN19:
+//! CQTCN19 - Task Completion Notification #19
+#define SD4HC_CQRS_CQRS11__CQTCN19
+#define SD4HC_CQRS_CQRS11__CQTCN19_MASK 0x00080000U
+#define SD4HC_CQRS_CQRS11__CQTCN19_SHIFT 19U
+//! Slice: CQRS11__CQTCN20:
+//! CQTCN20 - Task Completion Notification #20
+#define SD4HC_CQRS_CQRS11__CQTCN20
+#define SD4HC_CQRS_CQRS11__CQTCN20_MASK 0x00100000U
+#define SD4HC_CQRS_CQRS11__CQTCN20_SHIFT 20U
+//! Slice: CQRS11__CQTCN21:
+//! CQTCN21 - Task Completion Notification #21
+#define SD4HC_CQRS_CQRS11__CQTCN21
+#define SD4HC_CQRS_CQRS11__CQTCN21_MASK 0x00200000U
+#define SD4HC_CQRS_CQRS11__CQTCN21_SHIFT 21U
+//! Slice: CQRS11__CQTCN22:
+//! CQTCN22 - Task Completion Notification #22
+#define SD4HC_CQRS_CQRS11__CQTCN22
+#define SD4HC_CQRS_CQRS11__CQTCN22_MASK 0x00400000U
+#define SD4HC_CQRS_CQRS11__CQTCN22_SHIFT 22U
+//! Slice: CQRS11__CQTCN23:
+//! CQTCN23 - Task Completion Notification #23
+#define SD4HC_CQRS_CQRS11__CQTCN23
+#define SD4HC_CQRS_CQRS11__CQTCN23_MASK 0x00800000U
+#define SD4HC_CQRS_CQRS11__CQTCN23_SHIFT 23U
+//! Slice: CQRS11__CQTCN24:
+//! CQTCN24 - Task Completion Notification #24
+#define SD4HC_CQRS_CQRS11__CQTCN24
+#define SD4HC_CQRS_CQRS11__CQTCN24_MASK 0x01000000U
+#define SD4HC_CQRS_CQRS11__CQTCN24_SHIFT 24U
+//! Slice: CQRS11__CQTCN25:
+//! CQTCN25 - Task Completion Notification #25
+#define SD4HC_CQRS_CQRS11__CQTCN25
+#define SD4HC_CQRS_CQRS11__CQTCN25_MASK 0x02000000U
+#define SD4HC_CQRS_CQRS11__CQTCN25_SHIFT 25U
+//! Slice: CQRS11__CQTCN26:
+//! CQTCN26 - Task Completion Notification #26
+#define SD4HC_CQRS_CQRS11__CQTCN26
+#define SD4HC_CQRS_CQRS11__CQTCN26_MASK 0x04000000U
+#define SD4HC_CQRS_CQRS11__CQTCN26_SHIFT 26U
+//! Slice: CQRS11__CQTCN27:
+//! CQTCN27 - Task Completion Notification #27
+#define SD4HC_CQRS_CQRS11__CQTCN27
+#define SD4HC_CQRS_CQRS11__CQTCN27_MASK 0x08000000U
+#define SD4HC_CQRS_CQRS11__CQTCN27_SHIFT 27U
+//! Slice: CQRS11__CQTCN28:
+//! CQTCN28 - Task Completion Notification #28
+#define SD4HC_CQRS_CQRS11__CQTCN28
+#define SD4HC_CQRS_CQRS11__CQTCN28_MASK 0x10000000U
+#define SD4HC_CQRS_CQRS11__CQTCN28_SHIFT 28U
+//! Slice: CQRS11__CQTCN29:
+//! CQTCN29 - Task Completion Notification #29
+#define SD4HC_CQRS_CQRS11__CQTCN29
+#define SD4HC_CQRS_CQRS11__CQTCN29_MASK 0x20000000U
+#define SD4HC_CQRS_CQRS11__CQTCN29_SHIFT 29U
+//! Slice: CQRS11__CQTCN30:
+//! CQTCN30 - Task Completion Notification #30
+#define SD4HC_CQRS_CQRS11__CQTCN30
+#define SD4HC_CQRS_CQRS11__CQTCN30_MASK 0x40000000U
+#define SD4HC_CQRS_CQRS11__CQTCN30_SHIFT 30U
+//! Slice: CQRS11__CQTCN31:
+//! CQTCN31 - Task Completion Notification #31
+#define SD4HC_CQRS_CQRS11__CQTCN31
+#define SD4HC_CQRS_CQRS11__CQTCN31_MASK 0x80000000U
+#define SD4HC_CQRS_CQRS11__CQTCN31_SHIFT 31U
+
+//! Register: cqrs12: CQRS12 (SD4HC_CQRS_BASE + 0x00000030)
+//! Slice: CQRS12__CQDQS:
+//! CQDQS - Device Queue Status\n This register reflects to eMMC device status. Task N is ready for execution when bit N in this register is set to 1. This register is updated each time response for SEND_QUEUE_STATUS (CMD13) is received.
+#define SD4HC_CQRS_CQRS12__CQDQS
+#define SD4HC_CQRS_CQRS12__CQDQS_MASK 0xFFFFFFFFU
+#define SD4HC_CQRS_CQRS12__CQDQS_SHIFT 0U
+
+//! Register: cqrs13: CQRS13 (SD4HC_CQRS_BASE + 0x00000034)
+//! Slice: CQRS13__CQDPT00:
+//! CQDPT00 - Device Pending Tasks #00
+#define SD4HC_CQRS_CQRS13__CQDPT00
+#define SD4HC_CQRS_CQRS13__CQDPT00_MASK 0x00000001U
+#define SD4HC_CQRS_CQRS13__CQDPT00_SHIFT 0U
+//! Slice: CQRS13__CQDPT01:
+//! CQDPT01 - Device Pending Tasks #01
+#define SD4HC_CQRS_CQRS13__CQDPT01
+#define SD4HC_CQRS_CQRS13__CQDPT01_MASK 0x00000002U
+#define SD4HC_CQRS_CQRS13__CQDPT01_SHIFT 1U
+//! Slice: CQRS13__CQDPT02:
+//! CQDPT02 - Device Pending Tasks #02
+#define SD4HC_CQRS_CQRS13__CQDPT02
+#define SD4HC_CQRS_CQRS13__CQDPT02_MASK 0x00000004U
+#define SD4HC_CQRS_CQRS13__CQDPT02_SHIFT 2U
+//! Slice: CQRS13__CQDPT03:
+//! CQDPT03 - Device Pending Tasks #03
+#define SD4HC_CQRS_CQRS13__CQDPT03
+#define SD4HC_CQRS_CQRS13__CQDPT03_MASK 0x00000008U
+#define SD4HC_CQRS_CQRS13__CQDPT03_SHIFT 3U
+//! Slice: CQRS13__CQDPT04:
+//! CQDPT04 - Device Pending Tasks #04
+#define SD4HC_CQRS_CQRS13__CQDPT04
+#define SD4HC_CQRS_CQRS13__CQDPT04_MASK 0x00000010U
+#define SD4HC_CQRS_CQRS13__CQDPT04_SHIFT 4U
+//! Slice: CQRS13__CQDPT05:
+//! CQDPT05 - Device Pending Tasks #05
+#define SD4HC_CQRS_CQRS13__CQDPT05
+#define SD4HC_CQRS_CQRS13__CQDPT05_MASK 0x00000020U
+#define SD4HC_CQRS_CQRS13__CQDPT05_SHIFT 5U
+//! Slice: CQRS13__CQDPT06:
+//! CQDPT06 - Device Pending Tasks #06
+#define SD4HC_CQRS_CQRS13__CQDPT06
+#define SD4HC_CQRS_CQRS13__CQDPT06_MASK 0x00000040U
+#define SD4HC_CQRS_CQRS13__CQDPT06_SHIFT 6U
+//! Slice: CQRS13__CQDPT07:
+//! CQDPT07 - Device Pending Tasks #07
+#define SD4HC_CQRS_CQRS13__CQDPT07
+#define SD4HC_CQRS_CQRS13__CQDPT07_MASK 0x00000080U
+#define SD4HC_CQRS_CQRS13__CQDPT07_SHIFT 7U
+//! Slice: CQRS13__CQDPT08:
+//! CQDPT08 - Device Pending Tasks #08
+#define SD4HC_CQRS_CQRS13__CQDPT08
+#define SD4HC_CQRS_CQRS13__CQDPT08_MASK 0x00000100U
+#define SD4HC_CQRS_CQRS13__CQDPT08_SHIFT 8U
+//! Slice: CQRS13__CQDPT09:
+//! CQDPT09 - Device Pending Tasks #09
+#define SD4HC_CQRS_CQRS13__CQDPT09
+#define SD4HC_CQRS_CQRS13__CQDPT09_MASK 0x00000200U
+#define SD4HC_CQRS_CQRS13__CQDPT09_SHIFT 9U
+//! Slice: CQRS13__CQDPT10:
+//! CQDPT10 - Device Pending Tasks #10
+#define SD4HC_CQRS_CQRS13__CQDPT10
+#define SD4HC_CQRS_CQRS13__CQDPT10_MASK 0x00000400U
+#define SD4HC_CQRS_CQRS13__CQDPT10_SHIFT 10U
+//! Slice: CQRS13__CQDPT11:
+//! CQDPT11 - Device Pending Tasks #11
+#define SD4HC_CQRS_CQRS13__CQDPT11
+#define SD4HC_CQRS_CQRS13__CQDPT11_MASK 0x00000800U
+#define SD4HC_CQRS_CQRS13__CQDPT11_SHIFT 11U
+//! Slice: CQRS13__CQDPT12:
+//! CQDPT12 - Device Pending Tasks #12
+#define SD4HC_CQRS_CQRS13__CQDPT12
+#define SD4HC_CQRS_CQRS13__CQDPT12_MASK 0x00001000U
+#define SD4HC_CQRS_CQRS13__CQDPT12_SHIFT 12U
+//! Slice: CQRS13__CQDPT13:
+//! CQDPT13 - Device Pending Tasks #13
+#define SD4HC_CQRS_CQRS13__CQDPT13
+#define SD4HC_CQRS_CQRS13__CQDPT13_MASK 0x00002000U
+#define SD4HC_CQRS_CQRS13__CQDPT13_SHIFT 13U
+//! Slice: CQRS13__CQDPT14:
+//! CQDPT14 - Device Pending Tasks #14
+#define SD4HC_CQRS_CQRS13__CQDPT14
+#define SD4HC_CQRS_CQRS13__CQDPT14_MASK 0x00004000U
+#define SD4HC_CQRS_CQRS13__CQDPT14_SHIFT 14U
+//! Slice: CQRS13__CQDPT15:
+//! CQDPT15 - Device Pending Tasks #15
+#define SD4HC_CQRS_CQRS13__CQDPT15
+#define SD4HC_CQRS_CQRS13__CQDPT15_MASK 0x00008000U
+#define SD4HC_CQRS_CQRS13__CQDPT15_SHIFT 15U
+//! Slice: CQRS13__CQDPT16:
+//! CQDPT16 - Device Pending Tasks #16
+#define SD4HC_CQRS_CQRS13__CQDPT16
+#define SD4HC_CQRS_CQRS13__CQDPT16_MASK 0x00010000U
+#define SD4HC_CQRS_CQRS13__CQDPT16_SHIFT 16U
+//! Slice: CQRS13__CQDPT17:
+//! CQDPT17 - Device Pending Tasks #17
+#define SD4HC_CQRS_CQRS13__CQDPT17
+#define SD4HC_CQRS_CQRS13__CQDPT17_MASK 0x00020000U
+#define SD4HC_CQRS_CQRS13__CQDPT17_SHIFT 17U
+//! Slice: CQRS13__CQDPT18:
+//! CQDPT18 - Device Pending Tasks #18
+#define SD4HC_CQRS_CQRS13__CQDPT18
+#define SD4HC_CQRS_CQRS13__CQDPT18_MASK 0x00040000U
+#define SD4HC_CQRS_CQRS13__CQDPT18_SHIFT 18U
+//! Slice: CQRS13__CQDPT19:
+//! CQDPT19 - Device Pending Tasks #19
+#define SD4HC_CQRS_CQRS13__CQDPT19
+#define SD4HC_CQRS_CQRS13__CQDPT19_MASK 0x00080000U
+#define SD4HC_CQRS_CQRS13__CQDPT19_SHIFT 19U
+//! Slice: CQRS13__CQDPT20:
+//! CQDPT20 - Device Pending Tasks #20
+#define SD4HC_CQRS_CQRS13__CQDPT20
+#define SD4HC_CQRS_CQRS13__CQDPT20_MASK 0x00100000U
+#define SD4HC_CQRS_CQRS13__CQDPT20_SHIFT 20U
+//! Slice: CQRS13__CQDPT21:
+//! CQDPT21 - Device Pending Tasks #21
+#define SD4HC_CQRS_CQRS13__CQDPT21
+#define SD4HC_CQRS_CQRS13__CQDPT21_MASK 0x00200000U
+#define SD4HC_CQRS_CQRS13__CQDPT21_SHIFT 21U
+//! Slice: CQRS13__CQDPT22:
+//! CQDPT22 - Device Pending Tasks #22
+#define SD4HC_CQRS_CQRS13__CQDPT22
+#define SD4HC_CQRS_CQRS13__CQDPT22_MASK 0x00400000U
+#define SD4HC_CQRS_CQRS13__CQDPT22_SHIFT 22U
+//! Slice: CQRS13__CQDPT23:
+//! CQDPT23 - Device Pending Tasks #23
+#define SD4HC_CQRS_CQRS13__CQDPT23
+#define SD4HC_CQRS_CQRS13__CQDPT23_MASK 0x00800000U
+#define SD4HC_CQRS_CQRS13__CQDPT23_SHIFT 23U
+//! Slice: CQRS13__CQDPT24:
+//! CQDPT24 - Device Pending Tasks #24
+#define SD4HC_CQRS_CQRS13__CQDPT24
+#define SD4HC_CQRS_CQRS13__CQDPT24_MASK 0x01000000U
+#define SD4HC_CQRS_CQRS13__CQDPT24_SHIFT 24U
+//! Slice: CQRS13__CQDPT25:
+//! CQDPT25 - Device Pending Tasks #25
+#define SD4HC_CQRS_CQRS13__CQDPT25
+#define SD4HC_CQRS_CQRS13__CQDPT25_MASK 0x02000000U
+#define SD4HC_CQRS_CQRS13__CQDPT25_SHIFT 25U
+//! Slice: CQRS13__CQDPT26:
+//! CQDPT26 - Device Pending Tasks #26
+#define SD4HC_CQRS_CQRS13__CQDPT26
+#define SD4HC_CQRS_CQRS13__CQDPT26_MASK 0x04000000U
+#define SD4HC_CQRS_CQRS13__CQDPT26_SHIFT 26U
+//! Slice: CQRS13__CQDPT27:
+//! CQDPT27 - Device Pending Tasks #27
+#define SD4HC_CQRS_CQRS13__CQDPT27
+#define SD4HC_CQRS_CQRS13__CQDPT27_MASK 0x08000000U
+#define SD4HC_CQRS_CQRS13__CQDPT27_SHIFT 27U
+//! Slice: CQRS13__CQDPT28:
+//! CQDPT28 - Device Pending Tasks #28
+#define SD4HC_CQRS_CQRS13__CQDPT28
+#define SD4HC_CQRS_CQRS13__CQDPT28_MASK 0x10000000U
+#define SD4HC_CQRS_CQRS13__CQDPT28_SHIFT 28U
+//! Slice: CQRS13__CQDPT29:
+//! CQDPT29 - Device Pending Tasks #29
+#define SD4HC_CQRS_CQRS13__CQDPT29
+#define SD4HC_CQRS_CQRS13__CQDPT29_MASK 0x20000000U
+#define SD4HC_CQRS_CQRS13__CQDPT29_SHIFT 29U
+//! Slice: CQRS13__CQDPT30:
+//! CQDPT30 - Device Pending Tasks #30
+#define SD4HC_CQRS_CQRS13__CQDPT30
+#define SD4HC_CQRS_CQRS13__CQDPT30_MASK 0x40000000U
+#define SD4HC_CQRS_CQRS13__CQDPT30_SHIFT 30U
+//! Slice: CQRS13__CQDPT31:
+//! CQDPT31 - Device Pending Tasks #31
+#define SD4HC_CQRS_CQRS13__CQDPT31
+#define SD4HC_CQRS_CQRS13__CQDPT31_MASK 0x80000000U
+#define SD4HC_CQRS_CQRS13__CQDPT31_SHIFT 31U
+
+//! Register: cqrs14: CQRS14 (SD4HC_CQRS_BASE + 0x00000038)
+//! Slice: CQRS14__CQTC00:
+//! CQTC00 - Command Queuing Task Clear #00
+#define SD4HC_CQRS_CQRS14__CQTC00
+#define SD4HC_CQRS_CQRS14__CQTC00_MASK 0x00000001U
+#define SD4HC_CQRS_CQRS14__CQTC00_SHIFT 0U
+//! Slice: CQRS14__CQTC01:
+//! CQTC01 - Command Queuing Task Clear #01
+#define SD4HC_CQRS_CQRS14__CQTC01
+#define SD4HC_CQRS_CQRS14__CQTC01_MASK 0x00000002U
+#define SD4HC_CQRS_CQRS14__CQTC01_SHIFT 1U
+//! Slice: CQRS14__CQTC02:
+//! CQTC02 - Command Queuing Task Clear #02
+#define SD4HC_CQRS_CQRS14__CQTC02
+#define SD4HC_CQRS_CQRS14__CQTC02_MASK 0x00000004U
+#define SD4HC_CQRS_CQRS14__CQTC02_SHIFT 2U
+//! Slice: CQRS14__CQTC03:
+//! CQTC03 - Command Queuing Task Clear #03
+#define SD4HC_CQRS_CQRS14__CQTC03
+#define SD4HC_CQRS_CQRS14__CQTC03_MASK 0x00000008U
+#define SD4HC_CQRS_CQRS14__CQTC03_SHIFT 3U
+//! Slice: CQRS14__CQTC04:
+//! CQTC04 - Command Queuing Task Clear #04
+#define SD4HC_CQRS_CQRS14__CQTC04
+#define SD4HC_CQRS_CQRS14__CQTC04_MASK 0x00000010U
+#define SD4HC_CQRS_CQRS14__CQTC04_SHIFT 4U
+//! Slice: CQRS14__CQTC05:
+//! CQTC05 - Command Queuing Task Clear #05
+#define SD4HC_CQRS_CQRS14__CQTC05
+#define SD4HC_CQRS_CQRS14__CQTC05_MASK 0x00000020U
+#define SD4HC_CQRS_CQRS14__CQTC05_SHIFT 5U
+//! Slice: CQRS14__CQTC06:
+//! CQTC06 - Command Queuing Task Clear #06
+#define SD4HC_CQRS_CQRS14__CQTC06
+#define SD4HC_CQRS_CQRS14__CQTC06_MASK 0x00000040U
+#define SD4HC_CQRS_CQRS14__CQTC06_SHIFT 6U
+//! Slice: CQRS14__CQTC07:
+//! CQTC07 - Command Queuing Task Clear #07
+#define SD4HC_CQRS_CQRS14__CQTC07
+#define SD4HC_CQRS_CQRS14__CQTC07_MASK 0x00000080U
+#define SD4HC_CQRS_CQRS14__CQTC07_SHIFT 7U
+//! Slice: CQRS14__CQTC08:
+//! CQTC08 - Command Queuing Task Clear #08
+#define SD4HC_CQRS_CQRS14__CQTC08
+#define SD4HC_CQRS_CQRS14__CQTC08_MASK 0x00000100U
+#define SD4HC_CQRS_CQRS14__CQTC08_SHIFT 8U
+//! Slice: CQRS14__CQTC09:
+//! CQTC09 - Command Queuing Task Clear #09
+#define SD4HC_CQRS_CQRS14__CQTC09
+#define SD4HC_CQRS_CQRS14__CQTC09_MASK 0x00000200U
+#define SD4HC_CQRS_CQRS14__CQTC09_SHIFT 9U
+//! Slice: CQRS14__CQTC10:
+//! CQTC10 - Command Queuing Task Clear #10
+#define SD4HC_CQRS_CQRS14__CQTC10
+#define SD4HC_CQRS_CQRS14__CQTC10_MASK 0x00000400U
+#define SD4HC_CQRS_CQRS14__CQTC10_SHIFT 10U
+//! Slice: CQRS14__CQTC11:
+//! CQTC11 - Command Queuing Task Clear #11
+#define SD4HC_CQRS_CQRS14__CQTC11
+#define SD4HC_CQRS_CQRS14__CQTC11_MASK 0x00000800U
+#define SD4HC_CQRS_CQRS14__CQTC11_SHIFT 11U
+//! Slice: CQRS14__CQTC12:
+//! CQTC12 - Command Queuing Task Clear #12
+#define SD4HC_CQRS_CQRS14__CQTC12
+#define SD4HC_CQRS_CQRS14__CQTC12_MASK 0x00001000U
+#define SD4HC_CQRS_CQRS14__CQTC12_SHIFT 12U
+//! Slice: CQRS14__CQTC13:
+//! CQTC13 - Command Queuing Task Clear #13
+#define SD4HC_CQRS_CQRS14__CQTC13
+#define SD4HC_CQRS_CQRS14__CQTC13_MASK 0x00002000U
+#define SD4HC_CQRS_CQRS14__CQTC13_SHIFT 13U
+//! Slice: CQRS14__CQTC14:
+//! CQTC14 - Command Queuing Task Clear #14
+#define SD4HC_CQRS_CQRS14__CQTC14
+#define SD4HC_CQRS_CQRS14__CQTC14_MASK 0x00004000U
+#define SD4HC_CQRS_CQRS14__CQTC14_SHIFT 14U
+//! Slice: CQRS14__CQTC15:
+//! CQTC15 - Command Queuing Task Clear #15
+#define SD4HC_CQRS_CQRS14__CQTC15
+#define SD4HC_CQRS_CQRS14__CQTC15_MASK 0x00008000U
+#define SD4HC_CQRS_CQRS14__CQTC15_SHIFT 15U
+//! Slice: CQRS14__CQTC16:
+//! CQTC16 - Command Queuing Task Clear #16
+#define SD4HC_CQRS_CQRS14__CQTC16
+#define SD4HC_CQRS_CQRS14__CQTC16_MASK 0x00010000U
+#define SD4HC_CQRS_CQRS14__CQTC16_SHIFT 16U
+//! Slice: CQRS14__CQTC17:
+//! CQTC17 - Command Queuing Task Clear #17
+#define SD4HC_CQRS_CQRS14__CQTC17
+#define SD4HC_CQRS_CQRS14__CQTC17_MASK 0x00020000U
+#define SD4HC_CQRS_CQRS14__CQTC17_SHIFT 17U
+//! Slice: CQRS14__CQTC18:
+//! CQTC18 - Command Queuing Task Clear #18
+#define SD4HC_CQRS_CQRS14__CQTC18
+#define SD4HC_CQRS_CQRS14__CQTC18_MASK 0x00040000U
+#define SD4HC_CQRS_CQRS14__CQTC18_SHIFT 18U
+//! Slice: CQRS14__CQTC19:
+//! CQTC19 - Command Queuing Task Clear #19
+#define SD4HC_CQRS_CQRS14__CQTC19
+#define SD4HC_CQRS_CQRS14__CQTC19_MASK 0x00080000U
+#define SD4HC_CQRS_CQRS14__CQTC19_SHIFT 19U
+//! Slice: CQRS14__CQTC20:
+//! CQTC20 - Command Queuing Task Clear #20
+#define SD4HC_CQRS_CQRS14__CQTC20
+#define SD4HC_CQRS_CQRS14__CQTC20_MASK 0x00100000U
+#define SD4HC_CQRS_CQRS14__CQTC20_SHIFT 20U
+//! Slice: CQRS14__CQTC21:
+//! CQTC21 - Command Queuing Task Clear #21
+#define SD4HC_CQRS_CQRS14__CQTC21
+#define SD4HC_CQRS_CQRS14__CQTC21_MASK 0x00200000U
+#define SD4HC_CQRS_CQRS14__CQTC21_SHIFT 21U
+//! Slice: CQRS14__CQTC22:
+//! CQTC22 - Command Queuing Task Clear #22
+#define SD4HC_CQRS_CQRS14__CQTC22
+#define SD4HC_CQRS_CQRS14__CQTC22_MASK 0x00400000U
+#define SD4HC_CQRS_CQRS14__CQTC22_SHIFT 22U
+//! Slice: CQRS14__CQTC23:
+//! CQTC23 - Command Queuing Task Clear #23
+#define SD4HC_CQRS_CQRS14__CQTC23
+#define SD4HC_CQRS_CQRS14__CQTC23_MASK 0x00800000U
+#define SD4HC_CQRS_CQRS14__CQTC23_SHIFT 23U
+//! Slice: CQRS14__CQTC24:
+//! CQTC24 - Command Queuing Task Clear #24
+#define SD4HC_CQRS_CQRS14__CQTC24
+#define SD4HC_CQRS_CQRS14__CQTC24_MASK 0x01000000U
+#define SD4HC_CQRS_CQRS14__CQTC24_SHIFT 24U
+//! Slice: CQRS14__CQTC25:
+//! CQTC25 - Command Queuing Task Clear #25
+#define SD4HC_CQRS_CQRS14__CQTC25
+#define SD4HC_CQRS_CQRS14__CQTC25_MASK 0x02000000U
+#define SD4HC_CQRS_CQRS14__CQTC25_SHIFT 25U
+//! Slice: CQRS14__CQTC26:
+//! CQTC26 - Command Queuing Task Clear #26
+#define SD4HC_CQRS_CQRS14__CQTC26
+#define SD4HC_CQRS_CQRS14__CQTC26_MASK 0x04000000U
+#define SD4HC_CQRS_CQRS14__CQTC26_SHIFT 26U
+//! Slice: CQRS14__CQTC27:
+//! CQTC27 - Command Queuing Task Clear #27
+#define SD4HC_CQRS_CQRS14__CQTC27
+#define SD4HC_CQRS_CQRS14__CQTC27_MASK 0x08000000U
+#define SD4HC_CQRS_CQRS14__CQTC27_SHIFT 27U
+//! Slice: CQRS14__CQTC28:
+//! CQTC28 - Command Queuing Task Clear #28
+#define SD4HC_CQRS_CQRS14__CQTC28
+#define SD4HC_CQRS_CQRS14__CQTC28_MASK 0x10000000U
+#define SD4HC_CQRS_CQRS14__CQTC28_SHIFT 28U
+//! Slice: CQRS14__CQTC29:
+//! CQTC29 - Command Queuing Task Clear #29
+#define SD4HC_CQRS_CQRS14__CQTC29
+#define SD4HC_CQRS_CQRS14__CQTC29_MASK 0x20000000U
+#define SD4HC_CQRS_CQRS14__CQTC29_SHIFT 29U
+//! Slice: CQRS14__CQTC30:
+//! CQTC30 - Command Queuing Task Clear #30
+#define SD4HC_CQRS_CQRS14__CQTC30
+#define SD4HC_CQRS_CQRS14__CQTC30_MASK 0x40000000U
+#define SD4HC_CQRS_CQRS14__CQTC30_SHIFT 30U
+//! Slice: CQRS14__CQTC31:
+//! CQTC31 - Command Queuing Task Clear #31
+#define SD4HC_CQRS_CQRS14__CQTC31
+#define SD4HC_CQRS_CQRS14__CQTC31_MASK 0x80000000U
+#define SD4HC_CQRS_CQRS14__CQTC31_SHIFT 31U
+
+//! Register: cqrs16: CQRS16 (SD4HC_CQRS_BASE + 0x00000040)
+//! Slice: CQRS16__CQSSCIT:
+//! CQSSCIT - Send Status Command Idle Timer (CIT)\n When CQE is in idle, the host controller can poll device by sending SEND_QUEUE_STATUS (CMD13) with interval defined by this register. Accepted register value is in range 1 to 65535. The interval can be calculated as CQSSICT * internal clock period.
+#define SD4HC_CQRS_CQRS16__CQSSCIT
+#define SD4HC_CQRS_CQRS16__CQSSCIT_MASK 0x0000FFFFU
+#define SD4HC_CQRS_CQRS16__CQSSCIT_SHIFT 0U
+//! Slice: CQRS16__CQSSCBC:
+//! CQSSCBC - Send Status Command Block Counter (CBC)\n S/W can define if and when CQE sends SEND_QUEUE_STATUS (CMD13) command during data transfer.\n When this register is set 0, the CQE does not send CMD13 during data transfer. The value is 1, 2, or N means, the CQE sends CMD13 is transferred during last, one before last, or (N-1) before last block, respectively.\n Accepted register value range is 0 to 15.
+#define SD4HC_CQRS_CQRS16__CQSSCBC
+#define SD4HC_CQRS_CQRS16__CQSSCBC_MASK 0x000F0000U
+#define SD4HC_CQRS_CQRS16__CQSSCBC_SHIFT 16U
+
+//! Register: cqrs17: CQRS17 (SD4HC_CQRS_BASE + 0x00000044)
+//! Slice: CQRS17__CQSQSR:
+//! CQSQSR - Send Queue Status RCA\n S/W writes 16-bit RCA value which is send as an argument in SEND_QUEUE_STATUS (CMD13) command.
+#define SD4HC_CQRS_CQRS17__CQSQSR
+#define SD4HC_CQRS_CQRS17__CQSQSR_MASK 0x0000FFFFU
+#define SD4HC_CQRS_CQRS17__CQSQSR_SHIFT 0U
+
+//! Register: cqrs18: CQRS18 (SD4HC_CQRS_BASE + 0x00000048)
+//! Slice: CQRS18__CQDCLR:
+//! CQDCLR - Direct Command Last Response\n CQE holds the last DCMD command response.
+#define SD4HC_CQRS_CQRS18__CQDCLR
+#define SD4HC_CQRS_CQRS18__CQDCLR_MASK 0xFFFFFFFFU
+#define SD4HC_CQRS_CQRS18__CQDCLR_SHIFT 0U
+
+//! Register: cqrs20: CQRS20 (SD4HC_CQRS_BASE + 0x00000050)
+//! Slice: CQRS20__CQRMEM:
+//! CQRMEM - Response Mode Error Mask\n CQE is able to automatically detect errors in response. The S/W defines which bits of the response need to be checked. All bits set to 1 (written by S/W) are analyzed. The CQE reports Response Error Detected Interrupt (CQREDI) when N bit of CQRMEM is 1 and N bit of response is 1. Response for SEND_QUEUE_STATUS (CMD13) automatically sent by CQE is ignored.
+#define SD4HC_CQRS_CQRS20__CQRMEM
+#define SD4HC_CQRS_CQRS20__CQRMEM_MASK 0xFFFFFFFFU
+#define SD4HC_CQRS_CQRS20__CQRMEM_SHIFT 0U
+
+//! Register: cqrs21: CQRS21 (SD4HC_CQRS_BASE + 0x00000054)
+//! Slice: CQRS21__CQRMECI:
+//! CQRMECI - Response Mode Error Command Index\n Host updates this field with index of the command executed when error occurred during the command transaction.
+#define SD4HC_CQRS_CQRS21__CQRMECI
+#define SD4HC_CQRS_CQRS21__CQRMECI_MASK 0x0000003FU
+#define SD4HC_CQRS_CQRS21__CQRMECI_SHIFT 0U
+//! Slice: CQRS21__CQRMETID:
+//! CQRMETID - Response Mode Error Task ID\n Host updates this field with ID of the task with active command transfer when error occurred during the command transaction.
+#define SD4HC_CQRS_CQRS21__CQRMETID
+#define SD4HC_CQRS_CQRS21__CQRMETID_MASK 0x00001F00U
+#define SD4HC_CQRS_CQRS21__CQRMETID_SHIFT 8U
+//! Slice: CQRS21__CQRMEFV:
+//! CQRMEFV - Response Mode Error Fields Valid\n Host sets this bit to 1 when error is detected and command transaction is active. Host sets this bit to 0 when error is detected and command transaction is no active.
+#define SD4HC_CQRS_CQRS21__CQRMEFV
+#define SD4HC_CQRS_CQRS21__CQRMEFV_MASK 0x00008000U
+#define SD4HC_CQRS_CQRS21__CQRMEFV_SHIFT 15U
+//! Slice: CQRS21__CQDTECI:
+//! CQDTECI - Data Transfer Error Command Index\n Host updates this field with index of the data transfer command executed when error occurred during the data transfer.
+#define SD4HC_CQRS_CQRS21__CQDTECI
+#define SD4HC_CQRS_CQRS21__CQDTECI_MASK 0x003F0000U
+#define SD4HC_CQRS_CQRS21__CQDTECI_SHIFT 16U
+//! Slice: CQRS21__CQDTETID:
+//! CQDTETID - Data Transfer Error Task ID\n Host updates this field with ID of the task with active data transfer when error occurred during the data transfer.
+#define SD4HC_CQRS_CQRS21__CQDTETID
+#define SD4HC_CQRS_CQRS21__CQDTETID_MASK 0x1F000000U
+#define SD4HC_CQRS_CQRS21__CQDTETID_SHIFT 24U
+//! Slice: CQRS21__CQDTEFV:
+//! CQDTEFV - Data Transfer Error Fields Valid\n Host sets this bit to 1 when error is detected during data transfer. Host clears this bit to 0 when error is detected and there is no active data transfer.
+#define SD4HC_CQRS_CQRS21__CQDTEFV
+#define SD4HC_CQRS_CQRS21__CQDTEFV_MASK 0x80000000U
+#define SD4HC_CQRS_CQRS21__CQDTEFV_SHIFT 31U
+
+//! Register: cqrs22: CQRS22 (SD4HC_CQRS_BASE + 0x00000058)
+//! Slice: CQRS22__CQLCRI:
+//! CQLCRI - Last Command Response Index\n Host updates this field with command index when response is received.
+#define SD4HC_CQRS_CQRS22__CQLCRI
+#define SD4HC_CQRS_CQRS22__CQLCRI_MASK 0x0000003FU
+#define SD4HC_CQRS_CQRS22__CQLCRI_SHIFT 0U
+
+//! Register: cqrs23: CQRS23 (SD4HC_CQRS_BASE + 0x0000005c)
+//! Slice: CQRS23__CQLCRA:
+//! CQLCRA - Last Command Response Argument\n Host updates this field with command argument when response is received.
+#define SD4HC_CQRS_CQRS23__CQLCRA
+#define SD4HC_CQRS_CQRS23__CQLCRA_MASK 0xFFFFFFFFU
+#define SD4HC_CQRS_CQRS23__CQLCRA_SHIFT 0U
+
+#endif /* __SD4HC_CQRS_REGS_H__ */
+/*************************** EOF **************************************/
diff --git a/include/dct/sd4hc_crs_regs.h b/include/dct/sd4hc_crs_regs.h
new file mode 100644
index 0000000000..beb5c8b235
--- /dev/null
+++ b/include/dct/sd4hc_crs_regs.h
@@ -0,0 +1,40 @@
+ /*
+ * (C) Copyright 2023,
+ * Dream Chip Technologies
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#ifndef __SD4HC_CRS_REGS_H__
+#define __SD4HC_CRS_REGS_H__
+
+
+#include <stdint.h>
+
+//! Sd4hcCrs Register layout
+typedef struct
+{
+  //! Register Group: sd4hc_crs
+  uint32_t _notused_0 [191]; // gap in address space
+  uint32_t crs63; //!< CRS63 (slice) SD4HC_CRS_BASE + 0x00000000
+} Sd4hcCrsRegister_t;
+
+
+// - MASK AND SHIFT MACROS ----------------------------------------------------------
+
+//! Register Group: sd4hc_crs
+
+//! Register: crs63: CRS63 (SD4HC_CRS_BASE + 0x00000000)
+//! Slice: CRS63__ISES:
+//! ISES - Interrupt Signal For Each Slot.\n This field informs whether Interrupt or Wake-Up signal is active.
+#define SD4HC_CRS_CRS63__ISES
+#define SD4HC_CRS_CRS63__ISES_MASK 0x00000001U
+#define SD4HC_CRS_CRS63__ISES_SHIFT 0U
+//! Slice: CRS63__SVN:
+//! SVN - Specification Version Number.\n This field identifies the Host Controller Specification Version.\n [list] [*] 0h - Version 1.00 [*] 1h - Version 2.00 [*] 2h - Version 3.00 [*] 3h - Version 4.00 [*] 4h - Version 4.10 [*] 5h - Version 4.20 [*] 6h-FFh - reserved [/list]
+#define SD4HC_CRS_CRS63__SVN
+#define SD4HC_CRS_CRS63__SVN_MASK 0x00FF0000U
+#define SD4HC_CRS_CRS63__SVN_SHIFT 16U
+
+#endif /* __SD4HC_CRS_REGS_H__ */
+/*************************** EOF **************************************/
diff --git a/include/dct/sd4hc_hrs_regs.h b/include/dct/sd4hc_hrs_regs.h
new file mode 100644
index 0000000000..19babc8e5e
--- /dev/null
+++ b/include/dct/sd4hc_hrs_regs.h
@@ -0,0 +1,501 @@
+ /*
+ * (C) Copyright 2023,
+ * Dream Chip Technologies
+ * Axel Ludszuweit, <Axel.ludszuweit@dreamchip.de>
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#ifndef __SD4HC_HRS_REGS_H__
+#define __SD4HC_HRS_REGS_H__
+
+#include <stdint.h>
+
+//! Sd4hcHrs Register layout
+typedef struct
+{
+  //! Register Group: sd4hc_hrs
+  uint32_t hrs00; //!< HRS00 (slice) SD4HC_HRS_BASE + 0x00000000
+  uint32_t hrs01; //!< HRS01 (slice) SD4HC_HRS_BASE + 0x00000004
+  uint32_t hrs02; //!< HRS02 (slice) SD4HC_HRS_BASE + 0x00000008
+  uint32_t hrs03; //!< HRS03 (slice) SD4HC_HRS_BASE + 0x0000000c
+  uint32_t hrs04; //!< HRS04 (slice) SD4HC_HRS_BASE + 0x00000010
+  uint32_t hrs05; //!< HRS05 (slice) SD4HC_HRS_BASE + 0x00000014
+  uint32_t hrs06; //!< HRS06 (slice) SD4HC_HRS_BASE + 0x00000018
+  uint32_t hrs07; //!< HRS07 (slice) SD4HC_HRS_BASE + 0x0000001c
+  uint32_t hrs08; //!< HRS08 (slice) SD4HC_HRS_BASE + 0x00000020
+  uint32_t hrs09; //!< HRS09 (slice) SD4HC_HRS_BASE + 0x00000024
+  uint32_t hrs10; //!< HRS10 (slice) SD4HC_HRS_BASE + 0x00000028
+  uint32_t hrs11; //!< HRS11 (slice) SD4HC_HRS_BASE + 0x0000002c
+  uint32_t hrs12; //!< HRS12 (slice) SD4HC_HRS_BASE + 0x00000030
+  uint32_t hrs13; //!< HRS13 (slice) SD4HC_HRS_BASE + 0x00000034
+  uint32_t hrs14; //!< HRS14 (slice) SD4HC_HRS_BASE + 0x00000038
+  uint32_t _notused_0 [1]; // gap in address space
+  uint32_t hrs16; //!< HRS16 (slice) SD4HC_HRS_BASE + 0x00000040
+  uint32_t _notused_1 [12]; // gap in address space
+  uint32_t hrs29; //!< HRS29 (slice) SD4HC_HRS_BASE + 0x00000074
+  uint32_t hrs30; //!< HRS30 (slice) SD4HC_HRS_BASE + 0x00000078
+  uint32_t hrs31; //!< HRS31 (slice) SD4HC_HRS_BASE + 0x0000007c
+  uint32_t hrs32; //!< HRS32 (slice) SD4HC_HRS_BASE + 0x00000080
+  uint32_t hrs33; //!< HRS33 (slice) SD4HC_HRS_BASE + 0x00000084
+  uint32_t hrs34; //!< HRS34 (slice) SD4HC_HRS_BASE + 0x00000088
+  uint32_t _notused_2 [1]; // gap in address space
+  uint32_t hrs36; //!< HRS36 (slice) SD4HC_HRS_BASE + 0x00000090
+  uint32_t _notused_3 [3]; // gap in address space
+  uint32_t hrs40; //!< HRS40 (slice) SD4HC_HRS_BASE + 0x000000a0
+  uint32_t hrs41; //!< HRS41 (slice) SD4HC_HRS_BASE + 0x000000a4
+  uint32_t hrs42; //!< HRS42 (slice) SD4HC_HRS_BASE + 0x000000a8
+  uint32_t hrs43; //!< HRS43 (slice) SD4HC_HRS_BASE + 0x000000ac
+} Sd4hcHrsRegister_t;
+
+
+// - MASK AND SHIFT MACROS ----------------------------------------------------------
+
+//! Register Group: sd4hc_hrs
+
+//! Register: hrs00: HRS00 (SD4HC_HRS_BASE + 0x00000000)
+//! Slice: HRS00__SWR:
+//! SWR - Software Reset\n When set to 1, the entire core is reset. After reset operation complete, SWR bit is automatically cleared. It takes some time to complete the requested reset operation, so the software should always poll SWR bit status, and continue the other operations only when SWR is cleared to 0.\n There is no difference between SWR and SRS11.SRFA software resets. Both resets the same flip-flops.
+#define SD4HC_HRS_HRS00__SWR
+#define SD4HC_HRS_HRS00__SWR_MASK 0x00000001U
+#define SD4HC_HRS_HRS00__SWR_SHIFT 0U
+//! Slice: HRS00__SAV:
+//! SAV - Slot Available\n Field informs that the Host Controller supports one slot.
+#define SD4HC_HRS_HRS00__SAV
+#define SD4HC_HRS_HRS00__SAV_MASK 0x00FF0000U
+#define SD4HC_HRS_HRS00__SAV_SHIFT 16U
+
+//! Register: hrs01: HRS01 (SD4HC_HRS_BASE + 0x00000004)
+//! Slice: HRS01__DP:
+//! DP - Debounce Period\n Defines the number of system (clk) clock cycles used by the debounce logic, which detects card insertion and removal events. The debounce period is equal to DP * tclk, where tclk is the period of clk clock. If there is no change on pad_mem_ctrl_0 signal level for a programmed debounce period, the core logic decodes the card state as stable and triggers card_inserted or card_removed event. Typically, DP value should be chosen to obtain the period of 20ms.\n This register is reset to DEBOUNCE_PERIOD.
+#define SD4HC_HRS_HRS01__DP
+#define SD4HC_HRS_HRS01__DP_MASK 0x00FFFFFFU
+#define SD4HC_HRS_HRS01__DP_SHIFT 0U
+
+//! Register: hrs02: HRS02 (SD4HC_HRS_BASE + 0x00000008)
+//! Slice: HRS02__PBL:
+//! PBL - Programmable Burst Length\n This field defines a maximum number of beats in DMA burst. The value can be changed when no active transfer.\n This register is 0 after reset.\n [list] [*] 0001b - 1 beat in burst [*] 0010b - 2 beats in burst [*] 0011b - 4 beats in burst [*] 0100b - 8 bits in burst [*] other - 16 beats in burst [/list]
+#define SD4HC_HRS_HRS02__PBL
+#define SD4HC_HRS_HRS02__PBL_MASK 0x0000000FU
+#define SD4HC_HRS_HRS02__PBL_SHIFT 0U
+//! Slice: HRS02__OTN:
+//! OTN - Number of Outstanding Transfers\n Specifies number of outstanding transfers on DMA (Master) interface. The number of outstadings is (OTN + 1), where OTN can be defined in range 0 to 3.\n This register is set to 3 after reset (i.e. 4 outstanding transfers).
+#define SD4HC_HRS_HRS02__OTN
+#define SD4HC_HRS_HRS02__OTN_MASK 0x00030000U
+#define SD4HC_HRS_HRS02__OTN_SHIFT 16U
+
+//! Register: hrs03: HRS03 (SD4HC_HRS_BASE + 0x0000000c)
+//! Slice: HRS03__AER_RD:
+//! AER_RD - AXI ERROR Response R channel: DECERR\n This bit is set when a DECERR is detected on AXI Master bus in R channel (READ Response Channel).
+#define SD4HC_HRS_HRS03__AER_RD
+#define SD4HC_HRS_HRS03__AER_RD_MASK 0x00000001U
+#define SD4HC_HRS_HRS03__AER_RD_SHIFT 0U
+//! Slice: HRS03__AER_RS:
+//! AER_RS - AXI ERROR Response R channel: SLVERR\n This bit is set when a SLVERR is detected on AXI Master bus in R channel (READ Response Channel).
+#define SD4HC_HRS_HRS03__AER_RS
+#define SD4HC_HRS_HRS03__AER_RS_MASK 0x00000002U
+#define SD4HC_HRS_HRS03__AER_RS_SHIFT 1U
+//! Slice: HRS03__AER_BD:
+//! AER_BD - AXI ERROR Response B channel: DECERR\n This bit is set when a DECERR is detected on AXI Master bus in B channel (Write Response Channel).
+#define SD4HC_HRS_HRS03__AER_BD
+#define SD4HC_HRS_HRS03__AER_BD_MASK 0x00000004U
+#define SD4HC_HRS_HRS03__AER_BD_SHIFT 2U
+//! Slice: HRS03__AER_BS:
+//! AER_BS - AXI ERROR Response B channel: SLVERR\n This bit is set when a SLVERR is detected on AXI Master bus in B channel (Write Response Channel).
+#define SD4HC_HRS_HRS03__AER_BS
+#define SD4HC_HRS_HRS03__AER_BS_MASK 0x00000008U
+#define SD4HC_HRS_HRS03__AER_BS_SHIFT 3U
+//! Slice: HRS03__AER_SENRD:
+//! AER_SENRD - Status Enable for AXI ERROR Response R channel: DECERR\n 1 - status enable\n 0 - status disable
+#define SD4HC_HRS_HRS03__AER_SENRD
+#define SD4HC_HRS_HRS03__AER_SENRD_MASK 0x00000100U
+#define SD4HC_HRS_HRS03__AER_SENRD_SHIFT 8U
+//! Slice: HRS03__AER_SENRS:
+//! AER_SENRS - Status Enable for AXI ERROR Response R channel: SLVERR\n 1 - status enable\n 0 - status disable
+#define SD4HC_HRS_HRS03__AER_SENRS
+#define SD4HC_HRS_HRS03__AER_SENRS_MASK 0x00000200U
+#define SD4HC_HRS_HRS03__AER_SENRS_SHIFT 9U
+//! Slice: HRS03__AER_SENBD:
+//! AER_SENBD - Status Enable for AXI ERROR Response B channel: DECERR\n 1 - status enable\n 0 - status disable
+#define SD4HC_HRS_HRS03__AER_SENBD
+#define SD4HC_HRS_HRS03__AER_SENBD_MASK 0x00000400U
+#define SD4HC_HRS_HRS03__AER_SENBD_SHIFT 10U
+//! Slice: HRS03__AER_SENBS:
+//! AER_SENBS - Status Enable for AXI ERROR Response B channel: SLVERR\n 1 - status enable\n 0 - status disable
+#define SD4HC_HRS_HRS03__AER_SENBS
+#define SD4HC_HRS_HRS03__AER_SENBS_MASK 0x00000800U
+#define SD4HC_HRS_HRS03__AER_SENBS_SHIFT 11U
+//! Slice: HRS03__AER_IERD:
+//! AER_IERD - Signal Enable for AXI ERROR Response R channel: DECERR\n 1 - interrupt enable\n 0 - interrupt masked
+#define SD4HC_HRS_HRS03__AER_IERD
+#define SD4HC_HRS_HRS03__AER_IERD_MASK 0x00010000U
+#define SD4HC_HRS_HRS03__AER_IERD_SHIFT 16U
+//! Slice: HRS03__AER_IERS:
+//! AER_IERS - Signal Enable for AXI ERROR Response R channel: SLVERR\n 1 - interrupt enable\n 0 - interrupt masked
+#define SD4HC_HRS_HRS03__AER_IERS
+#define SD4HC_HRS_HRS03__AER_IERS_MASK 0x00020000U
+#define SD4HC_HRS_HRS03__AER_IERS_SHIFT 17U
+//! Slice: HRS03__AER_IEBD:
+//! AER_IEBD - Signal Enable for AXI ERROR Response B channel: DECERR\n 1 - interrupt enable\n 0 - interrupt masked
+#define SD4HC_HRS_HRS03__AER_IEBD
+#define SD4HC_HRS_HRS03__AER_IEBD_MASK 0x00040000U
+#define SD4HC_HRS_HRS03__AER_IEBD_SHIFT 18U
+//! Slice: HRS03__AER_IEBS:
+//! AER_IEBS - Signal Enable for AXI ERROR Response B channel: SLVERR\n 1 - interrupt enable\n 0 - interrupt masked
+#define SD4HC_HRS_HRS03__AER_IEBS
+#define SD4HC_HRS_HRS03__AER_IEBS_MASK 0x00080000U
+#define SD4HC_HRS_HRS03__AER_IEBS_SHIFT 19U
+
+//! Register: hrs04: HRS04 (SD4HC_HRS_BASE + 0x00000010)
+//! Slice: HRS04__PHYREGADDR:
+//! PHYREGADDR - PHY Register Address\n This filed defines the PHY Register Address for read / write accesses to PHY Register done through the HRS05.
+#define SD4HC_HRS_HRS04__PHYREGADDR
+#define SD4HC_HRS_HRS04__PHYREGADDR_MASK 0x0000FFFFU
+#define SD4HC_HRS_HRS04__PHYREGADDR_SHIFT 0U
+
+//! Register: hrs05: HRS05 (SD4HC_HRS_BASE + 0x00000014)
+//! Slice: HRS05__PHYREGDATA:
+//! PHYREGDATA - PHY Register Data Port\n Access to this register generates read or write transaction to Combo PHY Register.\n When this field is read, a read transaction is sent to PHY through APB interface. Value received in the transaction is passed back as the access result.\n When this field is write, a write transaction is sent to PHY through APB interface along with the written data.\n Host Controller -- Combo PHY APB interface does not support unaligned transfers, and so access to this field is limited to 32-bit transactions only. Unaligned (16-bit or 8-bit) access to this field may lead to unexpected result.
+#define SD4HC_HRS_HRS05__PHYREGDATA
+#define SD4HC_HRS_HRS05__PHYREGDATA_MASK 0xFFFFFFFFU
+#define SD4HC_HRS_HRS05__PHYREGDATA_SHIFT 0U
+
+//! Register: hrs06: HRS06 (SD4HC_HRS_BASE + 0x00000018)
+//! Slice: HRS06__EMM:
+//! EMM - eMMC Mode select\n This field sets eMMC mode. The mode should reflect to the eMMC device setting. If the SD card is in use, this field needs to be 000b.\n [list] [*] 000b - SD Card in use [*] 010b - SDR [*] 011b - DDR [*] 100b - HS200 [*] 101b - HS400 [*] 110b - HS400 Enhanced Strobe [*] others - Legacy [/list]
+#define SD4HC_HRS_HRS06__EMM
+#define SD4HC_HRS_HRS06__EMM_MASK 0x00000007U
+#define SD4HC_HRS_HRS06__EMM_SHIFT 0U
+
+//! Register: hrs07: HRS07 (SD4HC_HRS_BASE + 0x0000001c)
+//! Slice: HRS07__IDELAY_VAL:
+//! IDELAY_VAL - Input delay value for IO. \n Designer should update this register with delay value of IO with appriopriate input delay. \n Delay is count in half of period of sdmclk. If sdmclk is working at 200MHz frequency, \n then 1 is 2,5 ns. \n This value will be used to compensate delay of DAT line when controller is reading Card Interrupt. \n
+#define SD4HC_HRS_HRS07__IDELAY_VAL
+#define SD4HC_HRS_HRS07__IDELAY_VAL_MASK 0x0000001FU
+#define SD4HC_HRS_HRS07__IDELAY_VAL_SHIFT 0U
+//! Slice: HRS07__RW_COMPENSATE:
+//! RW_COMPENSATE - Read Wait Compensate value \n According to delays between PAD and dfi_rddata, dfi_wrdata and PAD and to Read Wait timing requirements, the signal dat[2] should be set to 0 earlier than controller read the end bit of read data. Designer should update this register with delay of data path count in sdmclk clock cycles. If the value is greater than 10 and value of field SDCLK Frequency Select (concatenation of SRS11.SDCFSH, SRS11.SDCFSL) is equal 0, then io_mask_start parameter in PHY register phy_dq_timing_reg should be set with value equal (RW_COMPENSATE-10)*2.
+#define SD4HC_HRS_HRS07__RW_COMPENSATE
+#define SD4HC_HRS_HRS07__RW_COMPENSATE_MASK 0x001F0000U
+#define SD4HC_HRS_HRS07__RW_COMPENSATE_SHIFT 16U
+
+//! Register: hrs08: HRS08 (SD4HC_HRS_BASE + 0x00000020)
+//! Slice: HRS08__PHY_DLL_UPDREQ:
+//! PHY_DLL_UPDREQ\n This register controls sdphy_dfi_ctrlupd_req port.
+#define SD4HC_HRS_HRS08__PHY_DLL_UPDREQ
+#define SD4HC_HRS_HRS08__PHY_DLL_UPDREQ_MASK 0x00000001U
+#define SD4HC_HRS_HRS08__PHY_DLL_UPDREQ_SHIFT 0U
+//! Slice: HRS08__PHY_DLL_UPDACK:
+//! PHY_DLL_UPDACK\n This register contains value read from sdphy_dfi_ctrlupd_ack port.
+#define SD4HC_HRS_HRS08__PHY_DLL_UPDACK
+#define SD4HC_HRS_HRS08__PHY_DLL_UPDACK_MASK 0x00000002U
+#define SD4HC_HRS_HRS08__PHY_DLL_UPDACK_SHIFT 1U
+
+//! Register: hrs09: HRS09 (SD4HC_HRS_BASE + 0x00000024)
+//! Slice: HRS09__PHY_SW_RESET:
+//! PHY_SW_RESET\n This field controls sdphy_dll_rst_n.
+#define SD4HC_HRS_HRS09__PHY_SW_RESET
+#define SD4HC_HRS_HRS09__PHY_SW_RESET_MASK 0x00000001U
+#define SD4HC_HRS_HRS09__PHY_SW_RESET_SHIFT 0U
+//! Slice: HRS09__PHY_INIT_COMPLETE:
+//! PHY_INIT_COMPLETE\n This field contains a value read from sdphy_dfi_init_complete port.
+#define SD4HC_HRS_HRS09__PHY_INIT_COMPLETE
+#define SD4HC_HRS_HRS09__PHY_INIT_COMPLETE_MASK 0x00000002U
+#define SD4HC_HRS_HRS09__PHY_INIT_COMPLETE_SHIFT 1U
+//! Slice: HRS09__EXTENDED_RD_MODE:
+//! EXTENDED_RD_MODE\n Controls sdphy_param_extended_rd_mode port.\n Non of software resets clear this register.
+#define SD4HC_HRS_HRS09__EXTENDED_RD_MODE
+#define SD4HC_HRS_HRS09__EXTENDED_RD_MODE_MASK 0x00000004U
+#define SD4HC_HRS_HRS09__EXTENDED_RD_MODE_SHIFT 2U
+//! Slice: HRS09__EXTENDED_WR_MODE:
+//! EXTENDED_WR_MODE\n Controls sdphy_param_extended_wr_mode port. Non of software resets clear this register.
+#define SD4HC_HRS_HRS09__EXTENDED_WR_MODE
+#define SD4HC_HRS_HRS09__EXTENDED_WR_MODE_MASK 0x00000008U
+#define SD4HC_HRS_HRS09__EXTENDED_WR_MODE_SHIFT 3U
+//! Slice: HRS09__RDCMD_EN:
+//! RDCMD_EN\n If 1, dfi_rdcmd_en is forced to 1, else host logic controls the signal.
+#define SD4HC_HRS_HRS09__RDCMD_EN
+#define SD4HC_HRS_HRS09__RDCMD_EN_MASK 0x00008000U
+#define SD4HC_HRS_HRS09__RDCMD_EN_SHIFT 15U
+//! Slice: HRS09__RDDATA_EN:
+//! RDDATA_EN\n If 1, dfi_rddata_en is forced to 1, else host logic controls the signal.
+#define SD4HC_HRS_HRS09__RDDATA_EN
+#define SD4HC_HRS_HRS09__RDDATA_EN_MASK 0x00010000U
+#define SD4HC_HRS_HRS09__RDDATA_EN_SHIFT 16U
+//! Slice: HRS09__LVSI_TCKSEL:
+//! LVSI_TCKSEL\n This field defines unit for LVSI_CNT. [list] [*] 0 - 2*t_CLK (two CLK clock cycles) [*] 1 - 4*t_CLK (four CLK clock cycles) [*] 2 - 8*t_CLK (eight CLK clock cycles) [*] 3 - 16*t_CLK (sixteen clock cycles) [*] N - (2^(N+1))*t_CLK [/list]\n where N must equal 0 to 47. Values above 47 are reserved.
+#define SD4HC_HRS_HRS09__LVSI_TCKSEL
+#define SD4HC_HRS_HRS09__LVSI_TCKSEL_MASK 0x0FC00000U
+#define SD4HC_HRS_HRS09__LVSI_TCKSEL_SHIFT 22U
+//! Slice: HRS09__LVSI_CNT:
+//! LVSI_CNT\n This field defines period of SDCLK pulse during LVS Identification. The period varies in range from LVSI_CNT * 2^(LVSI_TCKSEL+1) * t_CLK to (LVSI_CNT + 1) * 2^(LVSI_TCKSEL+1) * t_CLK.\n It is recommended to use lower LVSI_TCKSEL value and higher LVSI_CNT value to reduce SDCLK pulse period variation. The variation is +1/-1 LVSI_TCLKSEL unit.
+#define SD4HC_HRS_HRS09__LVSI_CNT
+#define SD4HC_HRS_HRS09__LVSI_CNT_MASK 0xF0000000U
+#define SD4HC_HRS_HRS09__LVSI_CNT_SHIFT 28U
+
+//! Register: hrs10: HRS10 (SD4HC_HRS_BASE + 0x00000028)
+//! Slice: HRS10__HCSDCLKADJ:
+//! HCSDCLKADJ\n This field allows to adjust flow control mechanism which disables SDCLK. With value 0, the clock (dfi_webar/dfi_webar_high) will be disabled right after end bit of the data block. Increasing this value will cause that clock signal is to be disabled earlier with SDCLK period step.
+#define SD4HC_HRS_HRS10__HCSDCLKADJ
+#define SD4HC_HRS_HRS10__HCSDCLKADJ_MASK 0x000F0000U
+#define SD4HC_HRS_HRS10__HCSDCLKADJ_SHIFT 16U
+//! Slice: HRS10__RDDATA_SWAP:
+//! RDDATA_SWAP\n If 1, dfi_rddata bytes [7:0] and [15:8] are swapped.
+#define SD4HC_HRS_HRS10__RDDATA_SWAP
+#define SD4HC_HRS_HRS10__RDDATA_SWAP_MASK 0x00400000U
+#define SD4HC_HRS_HRS10__RDDATA_SWAP_SHIFT 22U
+
+//! Register: hrs11: HRS11 (SD4HC_HRS_BASE + 0x0000002c)
+//! Slice: HRS11__EMMC_RST:
+//! EMMC_RST\n This field drives dfi_rstbar which is used as eMMC reset.
+#define SD4HC_HRS_HRS11__EMMC_RST
+#define SD4HC_HRS_HRS11__EMMC_RST_MASK 0x00000001U
+#define SD4HC_HRS_HRS11__EMMC_RST_SHIFT 0U
+
+//! Register: hrs12: HRS12 (SD4HC_HRS_BASE + 0x00000030)
+//! Slice: HRS12__PHYCMDUR:
+//! PHY CMD Underrun - Status received from Combo PHY informing about CMD FIFO status.
+#define SD4HC_HRS_HRS12__PHYCMDUR
+#define SD4HC_HRS_HRS12__PHYCMDUR_MASK 0x00000001U
+#define SD4HC_HRS_HRS12__PHYCMDUR_SHIFT 0U
+//! Slice: HRS12__PHYCMDOF:
+//! PHY CMD Overflow - Status received from Combo PHY informing about CMD FIFO status.
+#define SD4HC_HRS_HRS12__PHYCMDOF
+#define SD4HC_HRS_HRS12__PHYCMDOF_MASK 0x00000002U
+#define SD4HC_HRS_HRS12__PHYCMDOF_SHIFT 1U
+//! Slice: HRS12__PHYDATUR:
+//! PHY DAT Underrun - Status received from Combo PHY informing about DAT FIFO status.
+#define SD4HC_HRS_HRS12__PHYDATUR
+#define SD4HC_HRS_HRS12__PHYDATUR_MASK 0x00000004U
+#define SD4HC_HRS_HRS12__PHYDATUR_SHIFT 2U
+//! Slice: HRS12__PHYDATOF:
+//! PHY DAT Overflow - Status received from Combo PHY informing about DAT FIFO status.
+#define SD4HC_HRS_HRS12__PHYDATOF
+#define SD4HC_HRS_HRS12__PHYDATOF_MASK 0x00000008U
+#define SD4HC_HRS_HRS12__PHYDATOF_SHIFT 3U
+
+//! Register: hrs13: HRS13 (SD4HC_HRS_BASE + 0x00000034)
+//! Slice: HRS13__PHYCMDUR_SE:
+//! Mask for PHYCMDUR status\n [list] [*] 1 - enabled [*] 0 - masked [/list]
+#define SD4HC_HRS_HRS13__PHYCMDUR_SE
+#define SD4HC_HRS_HRS13__PHYCMDUR_SE_MASK 0x00000001U
+#define SD4HC_HRS_HRS13__PHYCMDUR_SE_SHIFT 0U
+//! Slice: HRS13__PHYCMDOF_SE:
+//! Mask for PHYCMDOF status\n [list] [*] 1 - enabled [*] 0 - masked [/list]
+#define SD4HC_HRS_HRS13__PHYCMDOF_SE
+#define SD4HC_HRS_HRS13__PHYCMDOF_SE_MASK 0x00000002U
+#define SD4HC_HRS_HRS13__PHYCMDOF_SE_SHIFT 1U
+//! Slice: HRS13__PHYDATUR_SE:
+//! Mask for PHYDATUR status\n [list] [*] 1 - enabled [*] 0 - masked [/list]
+#define SD4HC_HRS_HRS13__PHYDATUR_SE
+#define SD4HC_HRS_HRS13__PHYDATUR_SE_MASK 0x00000004U
+#define SD4HC_HRS_HRS13__PHYDATUR_SE_SHIFT 2U
+//! Slice: HRS13__PHYDATOF_SE:
+//! Mask for PHYDATOF status\n [list] [*] 1 - enabled [*] 0 - masked [/list]
+#define SD4HC_HRS_HRS13__PHYDATOF_SE
+#define SD4HC_HRS_HRS13__PHYDATOF_SE_MASK 0x00000008U
+#define SD4HC_HRS_HRS13__PHYDATOF_SE_SHIFT 3U
+
+//! Register: hrs14: HRS14 (SD4HC_HRS_BASE + 0x00000038)
+//! Slice: HRS14__PHYCMDUR_IE:
+//! Interrupt enable for PHYCMDUR status\n [list] [*] 1 - enabled [*] 0 - masked [/list]
+#define SD4HC_HRS_HRS14__PHYCMDUR_IE
+#define SD4HC_HRS_HRS14__PHYCMDUR_IE_MASK 0x00000001U
+#define SD4HC_HRS_HRS14__PHYCMDUR_IE_SHIFT 0U
+//! Slice: HRS14__PHYCMDOF_IE:
+//! Interrupt enable for PHYCMDOF status\n [list] [*] 1 - enabled [*] 0 - masked [/list]
+#define SD4HC_HRS_HRS14__PHYCMDOF_IE
+#define SD4HC_HRS_HRS14__PHYCMDOF_IE_MASK 0x00000002U
+#define SD4HC_HRS_HRS14__PHYCMDOF_IE_SHIFT 1U
+//! Slice: HRS14__PHYDATUR_IE:
+//! Interrupt enable for PHYDATUR status\n [list] [*] 1 - enabled [*] 0 - masked [/list]
+#define SD4HC_HRS_HRS14__PHYDATUR_IE
+#define SD4HC_HRS_HRS14__PHYDATUR_IE_MASK 0x00000004U
+#define SD4HC_HRS_HRS14__PHYDATUR_IE_SHIFT 2U
+//! Slice: HRS14__PHYDATOF_IE:
+//! Interrupt enable for PHYDATOF status\n [list] [*] 1 - enabled [*] 0 - masked [/list]
+#define SD4HC_HRS_HRS14__PHYDATOF_IE
+#define SD4HC_HRS_HRS14__PHYDATOF_IE_MASK 0x00000008U
+#define SD4HC_HRS_HRS14__PHYDATOF_IE_SHIFT 3U
+
+//! Register: hrs16: HRS16 (SD4HC_HRS_BASE + 0x00000040)
+//! Slice: HRS16__WRCMD0_DLY:
+//! WRCMD0_DLY\n Value in this field defines a delay of the dfi_wrcmd[0] signal. The delay is equal value * t_SDMCLK.
+#define SD4HC_HRS_HRS16__WRCMD0_DLY
+#define SD4HC_HRS_HRS16__WRCMD0_DLY_MASK 0x0000000FU
+#define SD4HC_HRS_HRS16__WRCMD0_DLY_SHIFT 0U
+//! Slice: HRS16__WRCMD1_DLY:
+//! WRCMD1_DLY\n Value in this field defines a delay of the dfi_wrcmd[1] signal. The delay is equal value * t_SDMCLK.
+#define SD4HC_HRS_HRS16__WRCMD1_DLY
+#define SD4HC_HRS_HRS16__WRCMD1_DLY_MASK 0x000000F0U
+#define SD4HC_HRS_HRS16__WRCMD1_DLY_SHIFT 4U
+//! Slice: HRS16__WRDATA0_DLY:
+//! WRDATA0_DLY\n Value in this field defines a delay of the dfi_wrdata[7:0] signal. The delay is equal value * t_SDMCLK.
+#define SD4HC_HRS_HRS16__WRDATA0_DLY
+#define SD4HC_HRS_HRS16__WRDATA0_DLY_MASK 0x00000F00U
+#define SD4HC_HRS_HRS16__WRDATA0_DLY_SHIFT 8U
+//! Slice: HRS16__WRDATA1_DLY:
+//! WRDATA1_DLY\n Value in this field defines a delay of the dfi_wrdata[15:8] signal. The delay is equal value * t_SDMCLK.
+#define SD4HC_HRS_HRS16__WRDATA1_DLY
+#define SD4HC_HRS_HRS16__WRDATA1_DLY_MASK 0x0000F000U
+#define SD4HC_HRS_HRS16__WRDATA1_DLY_SHIFT 12U
+//! Slice: HRS16__WRCMD0_SDCLK_DLY:
+//! WRCMD0_SDCLK_DLY\n Value in this field defines a delay of the dfi_wrcmd signal. The delay is equal value * t_SDCLK/2.
+#define SD4HC_HRS_HRS16__WRCMD0_SDCLK_DLY
+#define SD4HC_HRS_HRS16__WRCMD0_SDCLK_DLY_MASK 0x000F0000U
+#define SD4HC_HRS_HRS16__WRCMD0_SDCLK_DLY_SHIFT 16U
+//! Slice: HRS16__WRCMD1_SDCLK_DLY:
+//! WRCMD1_SDCLK_DLY\n Value in this field defines a delay of the dfi_wrcmd signal. The delay is equal value * t_SDCLK/2.
+#define SD4HC_HRS_HRS16__WRCMD1_SDCLK_DLY
+#define SD4HC_HRS_HRS16__WRCMD1_SDCLK_DLY_MASK 0x00F00000U
+#define SD4HC_HRS_HRS16__WRCMD1_SDCLK_DLY_SHIFT 20U
+//! Slice: HRS16__WRDATA0_SDCLK_DLY:
+//! WRDATA0_SDCLK_DLY\n Value in this field defines a delay of the dfi_wrdata[7:0] signal. The delay is equal value * t_SDCLK/2.
+#define SD4HC_HRS_HRS16__WRDATA0_SDCLK_DLY
+#define SD4HC_HRS_HRS16__WRDATA0_SDCLK_DLY_MASK 0x0F000000U
+#define SD4HC_HRS_HRS16__WRDATA0_SDCLK_DLY_SHIFT 24U
+//! Slice: HRS16__WRDATA1_SDCLK_DLY:
+//! WRDATA1_SDCLK_DLY\n Value in this field defines a delay of the dfi_wrdata[15:8] signal. The delay is equal value * t_SDCLK/2.
+#define SD4HC_HRS_HRS16__WRDATA1_SDCLK_DLY
+#define SD4HC_HRS_HRS16__WRDATA1_SDCLK_DLY_MASK 0xF0000000U
+#define SD4HC_HRS_HRS16__WRDATA1_SDCLK_DLY_SHIFT 28U
+
+//! Register: hrs29: HRS29 (SD4HC_HRS_BASE + 0x00000074)
+//! Slice: HRS29__SDMAGICNUM:
+//! This product number is IP6061
+#define SD4HC_HRS_HRS29__SDMAGICNUM
+#define SD4HC_HRS_HRS29__SDMAGICNUM_MASK 0xFFFFFFFFU
+#define SD4HC_HRS_HRS29__SDMAGICNUM_SHIFT 0U
+
+//! Register: hrs30: HRS30 (SD4HC_HRS_BASE + 0x00000078)
+//! Slice: HRS30__CQSUP:
+//! Command Queuing supported\n This field informs whether Command Queuing is supported (1) or is not supported (0).
+#define SD4HC_HRS_HRS30__CQSUP
+#define SD4HC_HRS_HRS30__CQSUP_MASK 0x00000001U
+#define SD4HC_HRS_HRS30__CQSUP_SHIFT 0U
+//! Slice: HRS30__HS400ESSUP:
+//! High Speed 400 Enhance Strobe supported\n This field informs whether HS400 Enhance Strobe mode is supported (1) or is not supported (0).
+#define SD4HC_HRS_HRS30__HS400ESSUP
+#define SD4HC_HRS_HRS30__HS400ESSUP_MASK 0x00000002U
+#define SD4HC_HRS_HRS30__HS400ESSUP_SHIFT 1U
+
+//! Register: hrs31: HRS31 (SD4HC_HRS_BASE + 0x0000007c)
+//! Slice: HRS31__HOSTFIXVER:
+//! Fix Version Number\n Number of the fix related to the Host Controller Version.
+#define SD4HC_HRS_HRS31__HOSTFIXVER
+#define SD4HC_HRS_HRS31__HOSTFIXVER_MASK 0x000000FFU
+#define SD4HC_HRS_HRS31__HOSTFIXVER_SHIFT 0U
+//! Slice: HRS31__HOSTCTRLVER:
+//! Host Controller Version\n Release number of the Host Controller
+#define SD4HC_HRS_HRS31__HOSTCTRLVER
+#define SD4HC_HRS_HRS31__HOSTCTRLVER_MASK 0x0FFF0000U
+#define SD4HC_HRS_HRS31__HOSTCTRLVER_SHIFT 16U
+
+//! Register: hrs32: HRS32 (SD4HC_HRS_BASE + 0x00000080)
+//! Slice: HRS32__DATA:
+//! DATA - FSM status\n This register contains read FSM status. Before reading it user should select FSM address (ADDR), set LOAD bit and wait until hardware clears it.
+#define SD4HC_HRS_HRS32__DATA
+#define SD4HC_HRS_HRS32__DATA_MASK 0x0000FFFFU
+#define SD4HC_HRS_HRS32__DATA_SHIFT 0U
+//! Slice: HRS32__ADDR:
+//! ADDR - FSM address\n This field selects which FSM status will be read.\n All available status machines are listed in Debug section of User Guide.
+#define SD4HC_HRS_HRS32__ADDR
+#define SD4HC_HRS_HRS32__ADDR_MASK 0x7FFF0000U
+#define SD4HC_HRS_HRS32__ADDR_SHIFT 16U
+//! Slice: HRS32__LOAD:
+//! LOAD - FSM monitor update request\n Setting this bit to 1 starts internal FSM monitor to load value from selected FSM.\n After finishing this bit will be automatically cleared by hardware and FSM status can be read.
+#define SD4HC_HRS_HRS32__LOAD
+#define SD4HC_HRS_HRS32__LOAD_MASK 0x80000000U
+#define SD4HC_HRS_HRS32__LOAD_SHIFT 31U
+
+//! Register: hrs33: HRS33 (SD4HC_HRS_BASE + 0x00000084)
+//! Slice: HRS33__STAT0:
+//! STAT0 - Tune status 0\n After invoking UHS-I tunning procedure each bit of this register represents status of one tuning step.\n This field correspond to tuning steps 31-0.\n [list] [*] 0 - Step failed [*] 1 - Step passed [/list]
+#define SD4HC_HRS_HRS33__STAT0
+#define SD4HC_HRS_HRS33__STAT0_MASK 0xFFFFFFFFU
+#define SD4HC_HRS_HRS33__STAT0_SHIFT 0U
+
+//! Register: hrs34: HRS34 (SD4HC_HRS_BASE + 0x00000088)
+//! Slice: HRS34__STAT1:
+//! STAT1 - Tune status 1\n This field is continuation of STAT0 field.\n Its value represents status of tuning steps 39-32.
+#define SD4HC_HRS_HRS34__STAT1
+#define SD4HC_HRS_HRS34__STAT1_MASK 0x000000FFU
+#define SD4HC_HRS_HRS34__STAT1_SHIFT 0U
+
+//! Register: hrs36: HRS36 (SD4HC_HRS_BASE + 0x00000090)
+//! Slice: HRS36__BOOT_ACT:
+//! Boot Active\n Informs that the BOOT is active and the operation cannot be interfere by writing any registers.
+#define SD4HC_HRS_HRS36__BOOT_ACT
+#define SD4HC_HRS_HRS36__BOOT_ACT_MASK 0x00000001U
+#define SD4HC_HRS_HRS36__BOOT_ACT_SHIFT 0U
+//! Slice: HRS36__BOOT_EAT:
+//! Boot Error - Acknowledge Timeout Error
+#define SD4HC_HRS_HRS36__BOOT_EAT
+#define SD4HC_HRS_HRS36__BOOT_EAT_MASK 0x00000002U
+#define SD4HC_HRS_HRS36__BOOT_EAT_SHIFT 1U
+//! Slice: HRS36__BOOT_EAI:
+//! Boot Error - Invalid Acknowledge Error
+#define SD4HC_HRS_HRS36__BOOT_EAI
+#define SD4HC_HRS_HRS36__BOOT_EAI_MASK 0x00000004U
+#define SD4HC_HRS_HRS36__BOOT_EAI_SHIFT 2U
+//! Slice: HRS36__BOOT_EDT:
+//! Boot Error - Data Timeout Error
+#define SD4HC_HRS_HRS36__BOOT_EDT
+#define SD4HC_HRS_HRS36__BOOT_EDT_MASK 0x00000008U
+#define SD4HC_HRS_HRS36__BOOT_EDT_SHIFT 3U
+//! Slice: HRS36__BOOT_EDC:
+//! Boot Error - Data CRC Error
+#define SD4HC_HRS_HRS36__BOOT_EDC
+#define SD4HC_HRS_HRS36__BOOT_EDC_MASK 0x00000010U
+#define SD4HC_HRS_HRS36__BOOT_EDC_SHIFT 4U
+//! Slice: HRS36__BOOT_EDE:
+//! Boot Error - End Bit Error
+#define SD4HC_HRS_HRS36__BOOT_EDE
+#define SD4HC_HRS_HRS36__BOOT_EDE_MASK 0x00000020U
+#define SD4HC_HRS_HRS36__BOOT_EDE_SHIFT 5U
+//! Slice: HRS36__BOOT_EDM:
+//! Boot Error - Descriptor Mechanism Error
+#define SD4HC_HRS_HRS36__BOOT_EDM
+#define SD4HC_HRS_HRS36__BOOT_EDM_MASK 0x00000040U
+#define SD4HC_HRS_HRS36__BOOT_EDM_SHIFT 6U
+
+//! Register: hrs40: HRS40 (SD4HC_HRS_BASE + 0x000000a0)
+//! Slice: HRS40__BASE_ADDR0:
+//! BASE_ADDR0 - lower descriptor list base address\n Lower 32-bits of the base address required for auto-configuration descriptor mechanism.
+#define SD4HC_HRS_HRS40__BASE_ADDR0
+#define SD4HC_HRS_HRS40__BASE_ADDR0_MASK 0xFFFFFFFFU
+#define SD4HC_HRS_HRS40__BASE_ADDR0_SHIFT 0U
+
+//! Register: hrs41: HRS41 (SD4HC_HRS_BASE + 0x000000a4)
+//! Slice: HRS41__BASE_ADDR1:
+//! BASE_ADDR1 - higher descriptor list base address\n Higher 32-bits of the base address required for auto-configuration descriptor mechanism and if 64-bit address is supported.
+#define SD4HC_HRS_HRS41__BASE_ADDR1
+#define SD4HC_HRS_HRS41__BASE_ADDR1_MASK 0xFFFFFFFFU
+#define SD4HC_HRS_HRS41__BASE_ADDR1_SHIFT 0U
+
+//! Register: hrs42: HRS42 (SD4HC_HRS_BASE + 0x000000a8)
+//! Slice: HRS42__DESCMECH_EN:
+//! DESCMECH_EN - Enable/disable auto-configuration descritor mechanism for Host/PHY pre-initialization sequence update.\n
+#define SD4HC_HRS_HRS42__DESCMECH_EN
+#define SD4HC_HRS_HRS42__DESCMECH_EN_MASK 0x00000001U
+#define SD4HC_HRS_HRS42__DESCMECH_EN_SHIFT 0U
+//! Slice: HRS42__DESCMECH_TM:
+//! DESCMECH_TM - Descritor mechanism timeout value\n This value determines the interval by which descriptor mechanism timeout is detected.\n The interval can be computed as below:\n [list] [*] 1111b - clk*2^(29+2) [*] 1110b - clk*2^(28+2) [*] 1101b - clk*2^(27+2) [*] ... [*] 0001b - clk*2^(15+2) [*] 0000b - clk*2^(14+2) [/list] Where clk is the system clock period.
+#define SD4HC_HRS_HRS42__DESCMECH_TM
+#define SD4HC_HRS_HRS42__DESCMECH_TM_MASK 0x0000001EU
+#define SD4HC_HRS_HRS42__DESCMECH_TM_SHIFT 1U
+
+//! Register: hrs43: HRS43 (SD4HC_HRS_BASE + 0x000000ac)
+//! Slice: HRS43__ERROR_ST:
+//! Error occured during auto-configuration descriptor mechanism performance.\n
+#define SD4HC_HRS_HRS43__ERROR_ST
+#define SD4HC_HRS_HRS43__ERROR_ST_MASK 0x00000001U
+#define SD4HC_HRS_HRS43__ERROR_ST_SHIFT 0U
+//! Slice: HRS43__ERROR_VAL:
+//! ERROR_VAL - auto-configuration descriptor mechanism error type\n Error types:\n [list] [*] 000b - first descriptor other than LINK [*] 001b - invalid descriptor (VAL field = 0) [*] 010b - DMA error [*] 011b - timeout (descriptor fetching failed or register update failed) [*] 100b - wrong mask set for read command (mask[9:5] value is less than mask[4:0]) [*] 101b - descriptor with command other than READ_BLOCK read after descriptor with command READ_NONBLOCK [/list]
+#define SD4HC_HRS_HRS43__ERROR_VAL
+#define SD4HC_HRS_HRS43__ERROR_VAL_MASK 0x0000000EU
+#define SD4HC_HRS_HRS43__ERROR_VAL_SHIFT 1U
+
+#endif /* __SD4HC_HRS_REGS_H__ */
+/*************************** EOF **************************************/
diff --git a/include/dct/sd4hc_srs_regs.h b/include/dct/sd4hc_srs_regs.h
new file mode 100644
index 0000000000..00d241ffe8
--- /dev/null
+++ b/include/dct/sd4hc_srs_regs.h
@@ -0,0 +1,1248 @@
+ /*
+ * (C) Copyright 2023,
+ * Dream Chip Technologies
+ * Axel Ludszuweit, <Axel.ludszuweit@dreamchip.de>
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#ifndef __SD4HC_SRS_REGS_H__
+#define __SD4HC_SRS_REGS_H__
+
+#include <stdint.h>
+
+//! Sd4hcSrs Register layout
+typedef struct
+{
+  //! Register Group: sd4hc_srs
+  uint32_t _notused_0 [128]; // gap in address space
+  uint32_t srs00; //!< SRS00 (slice) SD4HC_SRS_BASE + 0x00000000
+  uint32_t srs01; //!< SRS01 (slice) SD4HC_SRS_BASE + 0x00000004
+  uint32_t srs02; //!< SRS02 (slice) SD4HC_SRS_BASE + 0x00000008
+  uint32_t srs03; //!< SRS03 (slice) SD4HC_SRS_BASE + 0x0000000c
+  uint32_t srs04; //!< SRS04 (slice) SD4HC_SRS_BASE + 0x00000010
+  uint32_t srs05; //!< SRS05 (slice) SD4HC_SRS_BASE + 0x00000014
+  uint32_t srs06; //!< SRS06 (slice) SD4HC_SRS_BASE + 0x00000018
+  uint32_t srs07; //!< SRS07 (slice) SD4HC_SRS_BASE + 0x0000001c
+  uint32_t srs08; //!< SRS08 (slice) SD4HC_SRS_BASE + 0x00000020
+  uint32_t srs09; //!< SRS09 (slice) SD4HC_SRS_BASE + 0x00000024
+  uint32_t srs10; //!< SRS10 (slice) SD4HC_SRS_BASE + 0x00000028
+  uint32_t srs11; //!< SRS11 (slice) SD4HC_SRS_BASE + 0x0000002c
+  uint32_t srs12; //!< SRS12 (slice) SD4HC_SRS_BASE + 0x00000030
+  uint32_t srs13; //!< SRS13 (slice) SD4HC_SRS_BASE + 0x00000034
+  uint32_t srs14; //!< SRS14 (slice) SD4HC_SRS_BASE + 0x00000038
+  uint32_t srs15; //!< SRS15 (slice) SD4HC_SRS_BASE + 0x0000003c
+  uint32_t srs16; //!< SRS16 (slice) SD4HC_SRS_BASE + 0x00000040
+  uint32_t srs17; //!< SRS17 (slice) SD4HC_SRS_BASE + 0x00000044
+  uint32_t srs18; //!< SRS18 (slice) SD4HC_SRS_BASE + 0x00000048
+  uint32_t srs19; //!< SRS19 (slice) SD4HC_SRS_BASE + 0x0000004c
+  uint32_t srs20; //!< SRS20 (slice) SD4HC_SRS_BASE + 0x00000050
+  uint32_t srs21; //!< SRS21 (slice) SD4HC_SRS_BASE + 0x00000054
+  uint32_t srs22; //!< SRS22 (slice) SD4HC_SRS_BASE + 0x00000058
+  uint32_t srs23; //!< SRS23 (slice) SD4HC_SRS_BASE + 0x0000005c
+  uint32_t srs24; //!< SRS24 (slice) SD4HC_SRS_BASE + 0x00000060
+  uint32_t srs25; //!< SRS25 (slice) SD4HC_SRS_BASE + 0x00000064
+  uint32_t srs26; //!< SRS26 (slice) SD4HC_SRS_BASE + 0x00000068
+  uint32_t srs27; //!< SRS27 (slice) SD4HC_SRS_BASE + 0x0000006c
+  uint32_t _notused_1 [2]; // gap in address space
+  uint32_t srs30; //!< SRS30 (slice) SD4HC_SRS_BASE + 0x00000078
+  uint32_t srs31; //!< SRS31 (slice) SD4HC_SRS_BASE + 0x0000007c
+} Sd4hcSrsRegister_t;
+
+
+// - MASK AND SHIFT MACROS ----------------------------------------------------------
+
+//! Register Group: sd4hc_srs
+
+//! Register: srs00: SRS00 (SD4HC_SRS_BASE + 0x00000000)
+//! Slice: SRS00__SAAR:
+//! SAAR - System Address / Argument 2 / 32-bit block count\n This field is used as: [list] [*] 32-bit Block Count register [*] SDMA system memory address [*] Auto CMD23 Argument [/list] \n 32-bit block count:\n This field enables to define number of data blocks for the next transfer.\n It is used when Host Controller is set in version 4 compatibility mode (SRS15.HV4E=1), Block Count Enable is enabled (SRS03.BCE=1) and 16-bit Block Count for Current Transfer is cleared (SRS01.BCCT=0).\n Value of this field is decremented after each block transfer. When this field is set 0, no data blocks is transferred.\n Software should not read this field during data transfer as return unexpected value. Write to this field during data transfer are ignored.\n When Host Controller is not set in version 4 compatibility mode (SRS15.HV4E=0) or 16-bit Block Count for Current Transfer is not equal to 0, (SRS01.BCCT) defines the block count.\n [list] [*] 00000000h - no block transfer [*] 00000001h..FFFFFFFFh - 1..4294967295 block(s) transfer. [/list] \n System Address:\n This register is used as base address when SDMA engine is selected (SRS03.DMAE=1 and SRS10.DMASEL=0) and SRS15.HV4E=0.\n When SDMA stops at SDMA Buffer Boundary, software updates System Address and write to SAAR[31:24] resumes SDMA transfer. Software driver sets address to the next data location in system memory. \n Auto CMD23 Argument:\n Auto CMD23 can be used in non-DMA or ADMA2 mode (when SRS15.HV4E=0) or in non-DMA, SDMA, ADMA2 mode (when SRS15.HV4E=1).
+#define SD4HC_SRS_SRS00__SAAR
+#define SD4HC_SRS_SRS00__SAAR_MASK 0xFFFFFFFFU
+#define SD4HC_SRS_SRS00__SAAR_SHIFT 0U
+
+//! Register: srs01: SRS01 (SD4HC_SRS_BASE + 0x00000004)
+//! Slice: SRS01__TBS:
+//! TBS - Transfer Block Size\n This field defines block size for block data transfers. During data transfer, read operations may return an invalid value, and write operations are ignored.\n The software will not set value that exceeds the physically implemented internal FIFO buffer size. The buffer size is equal to 2^FIFODEPTH, where FIFODEPTH is the generic parameter of the core.\n The SD/MMC (memory) uses block size up to 512 bytes.\n The SDIO can use up to 2048 bytes.\n [list] [*] 000h - not used [*] 001h - 1 data byte [*] 002h - 2 data bytes [*] 003h - 3 data bytes [*] ... [*] 1FFh - 511 data bytes [*] 200h - 512 data bytes [*] ... [*] 800h - 2048 data bytes [*] others - not used. [/list] Note: It is recommended for the software to use native data block size (512B) in case of multiple data block transfer (SRS03.MSBS==1). Using smaller block may cause unexpected response error when flow control is activated (i.e. SDCLK is disabled) during response transfer.
+#define SD4HC_SRS_SRS01__TBS
+#define SD4HC_SRS_SRS01__TBS_MASK 0x00000FFFU
+#define SD4HC_SRS_SRS01__TBS_SHIFT 0U
+//! Slice: SRS01__SDMABB:
+//! SDMABB - SDMA Buffer Boundary\n In this field, the system address boundary can be set for SDMA engine.\n The SDMA transfer stops crossing the address boundary and generates the DMA Interrupt (SRS12.DMAINT).\n After the DMA Interrupt, when the SRS15.HV4E is 0, the software should write new SDMA System Address (SRS00.SAAR / SRS22.DMASA1) in order to resume the SDMA transaction.\n [list] [*] 0 - 4k bytes address boundary [*] 1 - 8k bytes address boundary [*] 2 - 16k bytes address boundary [*] 3 - 32k bytes address boundary [*] 4 - 64k bytes address boundary [*] 5 - 128k bytes address boundary [*] 6 - 256k bytes address boundary [*] 7 - 512k bytes address boundary [/list]
+#define SD4HC_SRS_SRS01__SDMABB
+#define SD4HC_SRS_SRS01__SDMABB_MASK 0x00007000U
+#define SD4HC_SRS_SRS01__SDMABB_SHIFT 12U
+//! Slice: SRS01__BCCT:
+//! BCCT - Block Count For Current Transfer\n With this field, the number of data blocks can be defined for next transfer.\n This register is used when SRS03.BCE is set 1, and SRS15.HV4E is set to 0 or SRS15.H4VE is set to 1 and this field is different than 0, otherwise it will be ignored.\n When SRS15.HV4E==1 and this field == 0. 32-bit block count register is selected (SRS00.SAAR).\n The value is decremented after each block transfer. When this field is set 0, no data blocks will be transferred.\n During data transfer read operation may return invalid value, and write operations are ignored.\n [list] [*] 0000h - no block transfer [*] 0001h..FFFFh - 1..65535 block(s) transfer. [/list]
+#define SD4HC_SRS_SRS01__BCCT
+#define SD4HC_SRS_SRS01__BCCT_MASK 0xFFFF0000U
+#define SD4HC_SRS_SRS01__BCCT_SHIFT 16U
+
+//! Register: srs02: SRS02 (SD4HC_SRS_BASE + 0x00000008)
+//! Slice: SRS02__ARG1:
+//! ARG1 - Command Argument 1\n This field contains 32-bits argument for command issued by SRS03.CIDX file write.
+#define SD4HC_SRS_SRS02__ARG1
+#define SD4HC_SRS_SRS02__ARG1_MASK 0xFFFFFFFFU
+#define SD4HC_SRS_SRS02__ARG1_SHIFT 0U
+
+//! Register: srs03: SRS03 (SD4HC_SRS_BASE + 0x0000000c)
+//! Slice: SRS03__DMAE:
+//! DMAE - DMA Enable\n When set to 1, it enables DMA functionality. DMA can be enabled only if it is supported as indicated in the DMA Support in the SRS16.DMAS register. If DMA is not supported (due to host configuration), this bit is ignored.\n This field is hardware-protected by Command Inhibit DAT bit in Present State Register (SRS09.CIDAT).\n When SRS09.CIDAT=1, all writes to this field are ignored.\n Note: The ADMA2 mode uses only the finite transfer mode, i.e. this bit is to be set 1.
+#define SD4HC_SRS_SRS03__DMAE
+#define SD4HC_SRS_SRS03__DMAE_MASK 0x00000001U
+#define SD4HC_SRS_SRS03__DMAE_SHIFT 0U
+//! Slice: SRS03__BCE:
+//! BCE - Block Count Enable\n When set to 1, active block count register is enabled for the next data transfer. The active register is either SRS01.BCCT or SRS00.SAAR.\n Transfer of each block automatically decrements the counter value. The multi-block transfer ends when the counter reaches 0. So the finite transfer can not be performed with this setting.\n When 0, block counting is disabled, and SRS01.BCCT retains its value.\n The transfer will be infinite in non-DMA and SDMA modes. For ADMA mode the transfer can be infinite or finite. The finite transfer ends on reading the descriptor with END status (so the transfer length is designated by the table of descriptors). In case of infinite transfer, the software will explicitly set ABORT command type to stop transfer.\n This field is hardware-protected by Command Inhibit DAT bit in Present State Register (SRS09.CIDAT). When CIDAT=1, all writes to this field are ignored.
+#define SD4HC_SRS_SRS03__BCE
+#define SD4HC_SRS_SRS03__BCE_MASK 0x00000002U
+#define SD4HC_SRS_SRS03__BCE_SHIFT 1U
+//! Slice: SRS03__ACE:
+//! ACE - Auto CMD Enable\n The field allows to send one additional command to the card/device when the command is issued.\n [list] [*] 00b - No auto command [*] 01b - Auto CMD12 [*] 10b - Auto CMD23 [*] 11b - Auto CMD Auto Select [/list] If Auto CMD disable (00b) is set, the host does not send any additional command. This setting will be used when auto command is not required or not intended.\n If Auto CMD12 (01b) is set, the host sends CMD12 (Abort) automatically when last block of multi-block transfer is completed.\n If Auto CMD23 (10b) is set, the host sends CMD23 (Set Block Count) automatically before issued transfer data command. An argument of this command can be set in SRS00.\n If Auto CMD Auto Select (11b) is set, the host sends CMD12 or CMD23 according to result of identification process of card. If SRS15.CMD23E == 1 the host sends CMD23 as when as Auto CMD23 is set. If SRS15.CMD23E == 0 the host sends CMD12 as when as Auto CMD12 is set.\n On any error the issued command will not be sent.\n This field is hardware-protected by Command Inhibit DAT bit in Present State Register (SRS09.CIDAT). When SRS09.CIDAT=1, all writes to this field are ignored.
+#define SD4HC_SRS_SRS03__ACE
+#define SD4HC_SRS_SRS03__ACE_MASK 0x0000000CU
+#define SD4HC_SRS_SRS03__ACE_SHIFT 2U
+//! Slice: SRS03__DTDS:
+//! DTDS - Data Transfer Direction Select\n Selects direction of data transfer for commands with DPS=1. [list] [*] 0 - Write [*] 1 - Read [/list] For commands with SRS03.DPS=0, this field is ignored.\n This field is hardware-protected by Command Inhibit DAT bit in Present State Register (SRS09.CIDAT). When CIDAT=1, all writes to this field are ignored.
+#define SD4HC_SRS_SRS03__DTDS
+#define SD4HC_SRS_SRS03__DTDS_MASK 0x00000010U
+#define SD4HC_SRS_SRS03__DTDS_SHIFT 4U
+//! Slice: SRS03__MSBS:
+//! MSBS - Multi/Single Block Select\n Multi-block or single-block data transfer can be selected with this field.\n 0 - Single-block\n 1 - Multi-block\n This field is hardware-protected by Command Inhibit DAT bit in Present State Register (SRS09.CIDAT). When CIDAT=1, all writes to this field are ignored.
+#define SD4HC_SRS_SRS03__MSBS
+#define SD4HC_SRS_SRS03__MSBS_MASK 0x00000020U
+#define SD4HC_SRS_SRS03__MSBS_SHIFT 5U
+//! Slice: SRS03__RECT:
+//! RECT - Response Type R1/R5\n Select R1 or R5 response type for the response content checker. Listed below error bits will be evaluated.\n RECT = 0, Response Type - R1 (SD Memory):\n [list] [*] bit 31 OUT_OF_RANGE [*] bit 30 ADDRESS_ERROR [*] bit 29 BLOCK_LEN_ERROR [*] bit 26 WP_VIOLATION [*] bit 25 CARD_IS_LOCKED [*] bit 23 COM_CRC_ERROR [*] bit 21 CARD_ECC_FAILED [*] bit 20 CC_ERROR [*] bit 19 ERRORRECT [/list] RECT = 1, Response Type - R5 (SDIO):\n [list] [*] bit 7 COM_CRC_ERROR [*] bit 3 ERROR [*] bit 1 FUNCTION_NUMBER [*] bit 0 OUT_OF_RANGE [/list] This field is ignored when SRS03.RECE=0.
+#define SD4HC_SRS_SRS03__RECT
+#define SD4HC_SRS_SRS03__RECT_MASK 0x00000040U
+#define SD4HC_SRS_SRS03__RECT_SHIFT 6U
+//! Slice: SRS03__RECE:
+//! RECE - Response Error Check Enable\n When set 1, the host will look after R1/R5 responses.\n If any error will be detected in the response, the SRS12.ERSP bit is set to 1.\n The software will set this bit only when R1/R5 response is expected.\n The software will set SRS03.RID and RECE bits to 1 when the host checks R1/R5 errors. And both bits will be clear to 0, when the Software Driver will checks R1/R5 errors. On response error, the SRS12.ERSP bit (in Interrupt Status) is set 1.
+#define SD4HC_SRS_SRS03__RECE
+#define SD4HC_SRS_SRS03__RECE_MASK 0x00000080U
+#define SD4HC_SRS_SRS03__RECE_SHIFT 7U
+//! Slice: SRS03__RID:
+//! RID - Response Interrupt Disable\n When set to 1, the Command Complete Interrupt (SRS12.CC) will be disabled. The host will ignore the SRS13.CC_SE and behave as the SRS13.CC_SE would be 0.\n When set to 0, the SRS12.CC will be enabled or disabled depend on the SRS13.CC_SE bit only.
+#define SD4HC_SRS_SRS03__RID
+#define SD4HC_SRS_SRS03__RID_MASK 0x00000100U
+#define SD4HC_SRS_SRS03__RID_SHIFT 8U
+//! Slice: SRS03__RTS:
+//! RTS - Response Type Select\n Defines the expected response length.\n 00b - no response\n 01b - 136-bit response\n 10b - 48-bit response\n 11b - 48-bit response with BUSY\n Every command implies one of the response types listed above. To check the response type corresponding to a given command, please refer to the appropriate card/device specifications.
+#define SD4HC_SRS_SRS03__RTS
+#define SD4HC_SRS_SRS03__RTS_MASK 0x00030000U
+#define SD4HC_SRS_SRS03__RTS_SHIFT 16U
+//! Slice: SRS03__SCF:
+//! SCF - Sub Command Flag\n This bit is added from Version 4.10 to distinguish a main command or sub command.\n When issuing a main command, this bit is set to 0 and when issuing a sub command, this bit is set to 1. Setting of this bit is checked by Sub Command Status in Present State register SRS09.SCMDS). Host Driver manages whether main or sub command.\n Host Controller does not refer to this bit to issue the command. \n
+#define SD4HC_SRS_SRS03__SCF
+#define SD4HC_SRS_SRS03__SCF_MASK 0x00040000U
+#define SD4HC_SRS_SRS03__SCF_SHIFT 18U
+//! Slice: SRS03__CRCCE:
+//! CRCCE - Command CRC Check Enable\n When set to 1, the host checks if the CRC field of the response is valid.\n When 0, the CRC check is disabled and the CRC field of the response is ignored.\n The CRC check should be disabled for responses which do not contain an actual CRC value (some responses contain all 1s in place of the CRC field), and enabled for all other kinds of responses.\n Recommended settings depends on response type, see following table for details:\n SRS03.RTS=00: 0 - No Response\n SRS03.RTS=01: 1 - R2\n SRS03.RTS=10: 0 - R3, R4\n SRS03.RTS=10: 1 - R1, R5, R6, R7\n SRS03.RTS=11: 1 - R1b, R5b
+#define SD4HC_SRS_SRS03__CRCCE
+#define SD4HC_SRS_SRS03__CRCCE_MASK 0x00080000U
+#define SD4HC_SRS_SRS03__CRCCE_SHIFT 19U
+//! Slice: SRS03__CICE:
+//! CICE - Command Index Check Enable\n When set to 1, the host checks if the Command Index field in the response is equal to the SRS03.CIDX value.\n When 0, the check is not performed and Command Index field of the response is ignored.\n Recommended settings depends on response type, see following table for details: [list] [*] SRS03.RTS=00: 0 - No Response [*] SRS03.RTS=01: 0 - R2 [*] SRS03.RTS=10: 0 - R3, R4 [*] SRS03.RTS=10: 1 - R1, R5, R6, R7 [*] SRS03.RTS=11: 1 - R1b, R5b [/list]
+#define SD4HC_SRS_SRS03__CICE
+#define SD4HC_SRS_SRS03__CICE_MASK 0x00100000U
+#define SD4HC_SRS_SRS03__CICE_SHIFT 20U
+//! Slice: SRS03__DPS:
+//! DPS - Data Present Select\n Set to 1 for commands which transfer data (i.e. read or write data using DAT line).\n Set to 0 for all other commands, including: [list] [*] Commands using only CMD line [*] Commands with busy signalized on DAT[0] line (SRS03.RTS=11b) [/list]
+#define SD4HC_SRS_SRS03__DPS
+#define SD4HC_SRS_SRS03__DPS_MASK 0x00200000U
+#define SD4HC_SRS_SRS03__DPS_SHIFT 21U
+//! Slice: SRS03__CT:
+//! CT - Command Type\n This field defines specific type of command. [list] [*] Normal Command (0) - used by default when other command types are not intended to be used [*] Suspend Command (01b) - not used [*] Resume Command (10b) - not used [*] Abort Command (11b) - used when the software wants to stop the current data transfer (read or write data transfer). [/list] The read transfer ends by stopping transfer to the internal buffer. The write transfer ends with releasing DAT line to High-Z state. Then, after sending an Abort Command, the software will issue the software reset.\n The Suspend and Resume Mechanism is not supported by the SD Host version 4.00 and later, and the Suspend and Resume Commands will not be used.
+#define SD4HC_SRS_SRS03__CT
+#define SD4HC_SRS_SRS03__CT_MASK 0x00C00000U
+#define SD4HC_SRS_SRS03__CT_SHIFT 22U
+//! Slice: SRS03__CIDX:
+//! CIDX - Command Index\n This field contains a command number (index) of the command to be sent.\n The index can be defined in range 00-63, which means all commands (CMD00-CMD63 and ACMD00-ACMD63) defined in related specifications are supported.\n Writing this filed triggers the actual command transfer. This field is to be written only when Command Inhibit CMD bit is 0 in Present State Register (SRS09.CICMD).\n To check the list of available commands, refer to the appropriate card/device specifications.
+#define SD4HC_SRS_SRS03__CIDX
+#define SD4HC_SRS_SRS03__CIDX_MASK 0x3F000000U
+#define SD4HC_SRS_SRS03__CIDX_SHIFT 24U
+
+//! Register: srs04: SRS04 (SD4HC_SRS_BASE + 0x00000010)
+//! Slice: SRS04__RESP0:
+//! RESP0 - Response Register #0
+#define SD4HC_SRS_SRS04__RESP0
+#define SD4HC_SRS_SRS04__RESP0_MASK 0xFFFFFFFFU
+#define SD4HC_SRS_SRS04__RESP0_SHIFT 0U
+
+//! Register: srs05: SRS05 (SD4HC_SRS_BASE + 0x00000014)
+//! Slice: SRS05__RESP1:
+//! RESP1 - Response Register #1
+#define SD4HC_SRS_SRS05__RESP1
+#define SD4HC_SRS_SRS05__RESP1_MASK 0xFFFFFFFFU
+#define SD4HC_SRS_SRS05__RESP1_SHIFT 0U
+
+//! Register: srs06: SRS06 (SD4HC_SRS_BASE + 0x00000018)
+//! Slice: SRS06__RESP2:
+//! RESP2 - Response Register #2
+#define SD4HC_SRS_SRS06__RESP2
+#define SD4HC_SRS_SRS06__RESP2_MASK 0xFFFFFFFFU
+#define SD4HC_SRS_SRS06__RESP2_SHIFT 0U
+
+//! Register: srs07: SRS07 (SD4HC_SRS_BASE + 0x0000001c)
+//! Slice: SRS07__RESP3:
+//! RESP3 - Response Register #3
+#define SD4HC_SRS_SRS07__RESP3
+#define SD4HC_SRS_SRS07__RESP3_MASK 0xFFFFFFFFU
+#define SD4HC_SRS_SRS07__RESP3_SHIFT 0U
+
+//! Register: srs08: SRS08 (SD4HC_SRS_BASE + 0x00000020)
+//! Slice: SRS08__BDP:
+//! BDP - Buffer Data Port\n The field is to access the internal buffer (data block) in non-DMA transfer mode. 8-bit, 16-bit, or 32-bit access to SRS08 is possible with the following restrictions:\n - Only sequential contiguous access in Little Endian mode is possible. For example, if the software accesses BDP[7:0], then the next transfer will access BDP[15:8]. No byte skipping is allowed.\n - Each new block will start at the least significant byte of BDP, which is BDP[7:0].\n - If the block size is not a multiple of 32-bits, and the software accesses BDP using 32-bit words, then the excess bytes of the last word are ignored. This allows the software driver to use only 32-bit data transfers regardless of the block size.\n - Access to the register with precaution - the FIFO pointers can be damaged when buffer is not ready or when number of accesses exceed the transfer block size (SRS01.TBS).\n Following shows all transfers (byte enable variations) that are allowed on SRS08:\n Transfer width = 32-bit: [list] [*] be[3:0] = 'b1111 -> BDP[31:0] [/list] Transfer width = 16-bit:\n [list] [*] be[3:0] = 'b0011 -> BDP[15:0] [*] be[3:0] = 'b1100 -> BDP[31:16] [/list] Transfer width = 8-bit:\n [list] [*] be[3:0] = 'b0001 -> BDP[7:0] [*] be[3:0] = 'b0010 -> BDP[15:8] [*] be[3:0] = 'b0100 -> BDP[23:16] [*] be[3:0] = 'b1000 -> BDP[31:24] [/list]
+#define SD4HC_SRS_SRS08__BDP
+#define SD4HC_SRS_SRS08__BDP_MASK 0xFFFFFFFFU
+#define SD4HC_SRS_SRS08__BDP_SHIFT 0U
+
+//! Register: srs09: SRS09 (SD4HC_SRS_BASE + 0x00000024)
+//! Slice: SRS09__CICMD:
+//! CICMD - Command Inhibit CMD\n Indicates if the host can issue a command. [list] [*] 0 - command can be sent [*] 1 - command cannot be sent [/list] If this bit is 0, indicates the CMD line is not in use and the Host Controller can issue an SD command using the CMD line.\n This bit is set immediately after the CI is written, indicating start of command transmission.\n This bit is cleared when the command response is received.\n Even if the Command Inhibit DAT is set to 1, commands using only the CMD line can be issued if the Command Inhibit CMD is 0.\n Change from 1 to 0 directly triggers Command Complete Interrupt (SRS12.CC).
+#define SD4HC_SRS_SRS09__CICMD
+#define SD4HC_SRS_SRS09__CICMD_MASK 0x00000001U
+#define SD4HC_SRS_SRS09__CICMD_SHIFT 0U
+//! Slice: SRS09__CIDAT:
+//! CIDAT - Command Inhibit DAT\n Indicates if the host can issue a command which uses DAT line. Commands which use DAT line include write and read data commands and commands with busy response. [list] [*] 1 - command using DAT line cannot be sent [*] 0 - command using DAT line can be sent [/list] When CIDAT=1 then the SRS03[15:0] is write-protected. The software can write SRS03[15:0] only when CIDAT=0.
+#define SD4HC_SRS_SRS09__CIDAT
+#define SD4HC_SRS_SRS09__CIDAT_MASK 0x00000002U
+#define SD4HC_SRS_SRS09__CIDAT_SHIFT 1U
+//! Slice: SRS09__DLA:
+//! DLA - DAT Line Active\n Indicates if the DAT lines of SD interface are currently in use. [list] [*] 1 - DAT lines are active (in use) [*] 0 - DAT lines are released (not in use) [/list] This bit set to 1, when Read or Write Transfer bits are active (SRS09.RTA=1 or SRS09.WTA=1), or if the card indicates busy state on the DAT lines. The card can become busy immediately after the write operation, or after command which requires response with busy.\n Falling edge of this bit (change from 1 to 0) directly triggers Transfer Complete Interrupt (SRS12.TC).
+#define SD4HC_SRS_SRS09__DLA
+#define SD4HC_SRS_SRS09__DLA_MASK 0x00000004U
+#define SD4HC_SRS_SRS09__DLA_SHIFT 2U
+//! Slice: SRS09__DATSL2:
+//! DATSL2 - DAT[7:4] Line Signal Level\n The value is equal to the actual signal level on DAT input pad of the SD/eMMC interface:\n [list] [*] SRS9.7 - pad_mem_data[7] [*] SRS9.6 - pad_mem_data[6] [*] SRS9.5 - pad_mem_data[5] [*] SRS9.4 - pad_mem_data[4] [/list]
+#define SD4HC_SRS_SRS09__DATSL2
+#define SD4HC_SRS_SRS09__DATSL2_MASK 0x000000F0U
+#define SD4HC_SRS_SRS09__DATSL2_SHIFT 4U
+//! Slice: SRS09__WTA:
+//! WTA - Write Transfer Active\n Indicates the status of the write data transfer. [list] [*] 0 - no data write transfer in progress [*] 1 - data write transfer in progress [/list] Bit is set 1 after sending the write command, or after restarting the write transfer by the Continue Request (SRS10.CREQ).\n Bit is set 0 by the hardware after the last block of the write transfer, or after stopping the write transfer by the Stop at Block Gap Request (SRS10.SBGR).\n In both cases, the entire data has to be transferred to the card from the internal data buffer before setting this bit to 0. In other words, WTA=0 means that the entire data is already transferred to the card, and CRC response for the last data block is already received.
+#define SD4HC_SRS_SRS09__WTA
+#define SD4HC_SRS_SRS09__WTA_MASK 0x00000100U
+#define SD4HC_SRS_SRS09__WTA_SHIFT 8U
+//! Slice: SRS09__RTA:
+//! RTA - Read Transfer Active\n Indicates the status of the read data transfer. [list] [*] 0 - no data read transfer in progress [*] 1 - data read transfer in progress [/list] Bit is set 1 after sending the read command, or after restarting the read transfer by the Continue Request (SRS10.CREQ).\n Bit is set 0 by the hardware after the last block of the read transfer, or after stopping the read transfer by the Stop at Block Gap Request (SRS10.SBGR).\n In both cases, the entire data is to be read by the system from the internal data buffer before setting this bit to 0. In other words, SRS09.RTA=0 means that the entire data is already transferred to the system, and internal data buffer is empty.
+#define SD4HC_SRS_SRS09__RTA
+#define SD4HC_SRS_SRS09__RTA_MASK 0x00000200U
+#define SD4HC_SRS_SRS09__RTA_SHIFT 9U
+//! Slice: SRS09__BWE:
+//! BWE - Buffer Write Enable\n This bit represents data buffer (SRS08.BDP) state for write transfer in non-DMA mode.\n [list] [*] 1 - data can be written to the data buffer [*] 0 - data cannot be written [/list] After reading the entire data block, this changes to 0.\n This bit will be cleared in case of SBGR at non-DMA write transfer (even if the internal buffer is ready). The buffer must not be written after the SBGR. If the BWR was set, the only action from the S/W is to clear the interrupt status.
+#define SD4HC_SRS_SRS09__BWE
+#define SD4HC_SRS_SRS09__BWE_MASK 0x00000400U
+#define SD4HC_SRS_SRS09__BWE_SHIFT 10U
+//! Slice: SRS09__BRE:
+//! BRE - Buffer Read Enable\n This field represents data buffer (SRS08.BDP) state for read transfer in non-DMA mode.\n [list] [*] 1 - valid data can be read from the data buffer [*] 0 - no valid data inside the data buffer [/list] After reading the entire data block, this bit changes to 0.
+#define SD4HC_SRS_SRS09__BRE
+#define SD4HC_SRS_SRS09__BRE_MASK 0x00000800U
+#define SD4HC_SRS_SRS09__BRE_SHIFT 11U
+//! Slice: SRS09__CI:
+//! CI - Card Inserted\n Indicates if the card is inserted inside the slot. [list] [*] 0 - no card in slot [*] 1 - card is inserted [/list] Unlike SRS09.CDSL, value of SRS09.CI bit is guaranteed to be stable (i.e. debouncing is performed on this bit). Use of this bit is recommended during the normal operation of host.
+#define SD4HC_SRS_SRS09__CI
+#define SD4HC_SRS_SRS09__CI_MASK 0x00010000U
+#define SD4HC_SRS_SRS09__CI_SHIFT 16U
+//! Slice: SRS09__CSS:
+//! CSS - Card State Stable\n Indicates if Card Detect Pin Level (CDSL) is stable. [list] [*] 1 - means that the CDSL value is stable [*] 0 - means that the CDSL is not stable (during card insertion/removal or during the reset) [/list] Field is useful for debugging purposes.
+#define SD4HC_SRS_SRS09__CSS
+#define SD4HC_SRS_SRS09__CSS_MASK 0x00020000U
+#define SD4HC_SRS_SRS09__CSS_SHIFT 17U
+//! Slice: SRS09__CDSL:
+//! CDSL - Card Detect Pin Level\n The value is equal to the inverted signal level on Card Detect pin of the SD/eMMC interface (\textit{pad_mem_ctrl_0}). [list] [*] 1 - means that the card is inserted [*] 0 - means no card is inside the slot [/list] Debouncing is not performed on CDSL, therefore the use of Card Inserted (CI) bit is recommended during normal work.\n CDSL bit is useful only for debugging purposes.
+#define SD4HC_SRS_SRS09__CDSL
+#define SD4HC_SRS_SRS09__CDSL_MASK 0x00040000U
+#define SD4HC_SRS_SRS09__CDSL_SHIFT 18U
+//! Slice: SRS09__WPSL:
+//! WPSL - Write Protect Switch Pin Level\n The value is equal to the actual signal level on Write Protect pad of the SD/eMMC interface (\textit{pad_mem_wpbar}). [list] [*] 1 - means that the write operation is enabled [*] 0 - means that the write operations is disabled [/list]
+#define SD4HC_SRS_SRS09__WPSL
+#define SD4HC_SRS_SRS09__WPSL_MASK 0x00080000U
+#define SD4HC_SRS_SRS09__WPSL_SHIFT 19U
+//! Slice: SRS09__DATSL1:
+//! DATSL1 - DAT[3:0] Line Signal Level\n The value is equal to the actual signal level on DAT input pad of the SD/eMMC interface:\n [list] [*] SRS09.23 - pad_mem_data[3] [*] SRS09.22 - pad_mem_data[2] [*] SRS09.21 - pad_mem_data[1] [*] SRS09.20 - pad_mem_data[0] [/list]
+#define SD4HC_SRS_SRS09__DATSL1
+#define SD4HC_SRS_SRS09__DATSL1_MASK 0x00F00000U
+#define SD4HC_SRS_SRS09__DATSL1_SHIFT 20U
+//! Slice: SRS09__CMDSL:
+//! CMDSL - CMD Line Signal Level\n The value is equal to the actual signal level on CMD line of the SD interface (pad_mem_cmd).\n Is useful for debugging purposes.
+#define SD4HC_SRS_SRS09__CMDSL
+#define SD4HC_SRS_SRS09__CMDSL_MASK 0x01000000U
+#define SD4HC_SRS_SRS09__CMDSL_SHIFT 24U
+//! Slice: SRS09__LVSIRSLT:
+//! LVSIRSLT - LVS Identification Result\n Result of the Low Voltage Signaling Identification. This bit contains a valid information only when LVS Identification Execution bit has changed from 1 to 0. This field is cleared when any of following condition is met: (a) SD Bus Power for VDD1 is set to 0 (b) Card Inserted indicates card removal (c) HRS00.SWR (software reset)
+#define SD4HC_SRS_SRS09__LVSIRSLT
+#define SD4HC_SRS_SRS09__LVSIRSLT_MASK 0x04000000U
+#define SD4HC_SRS_SRS09__LVSIRSLT_SHIFT 26U
+//! Slice: SRS09__CNIBE:
+//! CNIBE - Command Not Issued By Error\n Setting of CNIBE status indicates that a command cannot be issued to an error, except Auto CMD12 error. (Equivalent error status by Auto CMD12 error is defined as SRS15.CNIACE.) This status is set to 1 when Host Controller cannot issue a command after setting Command register.\n
+#define SD4HC_SRS_SRS09__CNIBE
+#define SD4HC_SRS_SRS09__CNIBE_MASK 0x08000000U
+#define SD4HC_SRS_SRS09__CNIBE_SHIFT 27U
+//! Slice: SRS09__SCMDS:
+//! SCMDS - Sub Command Status\n The SRS03 register and Response registers (SRS04-SRS07) are commonly used for main command and sub command. This status is used to distinguish which response error statuses, main command or sub command, indicated the Error Interrupt Status register. Just before reading of this register, the SRS03.SCF is copied to this status. This status is effective when not only Response Error interrupt is generated (SRS12.ERSP) but also data error interrupt is generated with Command Not Issued by Error (SRS09.CNIBE) or Auto CMD Error (SRS12.EAC) interrupt is generated with Command Not Issued by Error by Auto CMD12 (SRS15.CNIACE). \n SRS09.SCMDS indicate which command is not issued (main or sub).\n
+#define SD4HC_SRS_SRS09__SCMDS
+#define SD4HC_SRS_SRS09__SCMDS_MASK 0x10000000U
+#define SD4HC_SRS_SRS09__SCMDS_SHIFT 28U
+
+//! Register: srs10: SRS10 (SD4HC_SRS_BASE + 0x00000028)
+//! Slice: SRS10__LEDC:
+//! LEDC - LED Control\n State of this bit directly drives led port of the host in order to control the external LED diode.\n LEDC=1 will switch LED on, while LEDC=0 will switch it off.\n The software will switch LED on to caution the user not to remove the card while the transfer is in progress.
+#define SD4HC_SRS_SRS10__LEDC
+#define SD4HC_SRS_SRS10__LEDC_MASK 0x00000001U
+#define SD4HC_SRS_SRS10__LEDC_SHIFT 0U
+//! Slice: SRS10__DTW:
+//! DTW - Data Transfer Width\n Bit used to configure DAT bus width to 1 or 4.\n 0 - 1-bit mode\n 1 - 4-bit mode\n This bit is ignored when the SRS10.EDTW is set 1 (8-bit mode selected).
+#define SD4HC_SRS_SRS10__DTW
+#define SD4HC_SRS_SRS10__DTW_MASK 0x00000002U
+#define SD4HC_SRS_SRS10__DTW_SHIFT 1U
+//! Slice: SRS10__HSE:
+//! HSE - High Speed Enable\n Selects operating mode to Default Speed (HSE=0) or High Speed (HSE=1).\n The maximum SD clock frequency is defined as 0-25MHz in the default speed mode, and 0-50MHz in the High Speed mode.
+#define SD4HC_SRS_SRS10__HSE
+#define SD4HC_SRS_SRS10__HSE_MASK 0x00000004U
+#define SD4HC_SRS_SRS10__HSE_SHIFT 2U
+//! Slice: SRS10__DMASEL:
+//! DMASEL - DMA Select\n In this field the DMA mode can be selected. The field behaviour depends on the Host Controller Compatibility bit (SRS15.HV4E).\n Host Controller version 3.00 compatible mode (SRS15.HV4E=0)\n 00b - SDMA mode\n 01b - Reserved\n 10b - ADMA2 (32-bit Address)\n 11b - ADMA2 (64-bit Address)\n Host Controller version 4.00 compatibility mode (SRS15.HV4E=1)\n 00b - SDMA mode\n 01b - Not Used\n 10b - ADMA2 mode (ADMA3 is not supported or disabled)\n 11b - ADMA2 or ADMA3 is selected\n The ADMA2 address bus width is configured by 64-bit Addressing bit in Host Controller 2 register when SRS15.HV4E=1.
+#define SD4HC_SRS_SRS10__DMASEL
+#define SD4HC_SRS_SRS10__DMASEL_MASK 0x00000018U
+#define SD4HC_SRS_SRS10__DMASEL_SHIFT 3U
+//! Slice: SRS10__EDTW:
+//! EDTW - Extended Data Transfer Width\n This bit is to enable/disable 8-bit DAT bus width mode.\n 0 - bus width selected by SRS10.DTW\n 1 - 8-bit mode enabled
+#define SD4HC_SRS_SRS10__EDTW
+#define SD4HC_SRS_SRS10__EDTW_MASK 0x00000020U
+#define SD4HC_SRS_SRS10__EDTW_SHIFT 5U
+//! Slice: SRS10__CDTL:
+//! CDTL - Card Detect Test Level\n Designates card insertion status when SRS10.CDSS=1. Bit provided for test purposes.\n 0 - no card\n 1 - card inserted
+#define SD4HC_SRS_SRS10__CDTL
+#define SD4HC_SRS_SRS10__CDTL_MASK 0x00000040U
+#define SD4HC_SRS_SRS10__CDTL_SHIFT 6U
+//! Slice: SRS10__CDSS:
+//! CDSS - Card Detect Signal Selection\n A card detection mechanism will base on either pad_mem_ctrl_0 port or register value.\n 0 - pad_mem_ctrl_0 pin (normal mode)\n 1 - CDTL(SRS10.6) bit (testing mode)
+#define SD4HC_SRS_SRS10__CDSS
+#define SD4HC_SRS_SRS10__CDSS_MASK 0x00000080U
+#define SD4HC_SRS_SRS10__CDSS_SHIFT 7U
+//! Slice: SRS10__BP:
+//! BP - SD Bus Power for VDD1\n When set to 1, the VDD1 voltage is supplied to card/device. The state of this bit directly drives \textit{pad_mem_ctrl_1} pad.\n Setting bit to 0 cause that host stops driving SDCLK, CMD/DAT lines. If the device is connected to the host, lines go low before disabling VDD1.\n The host will set this bit automatically to 0 when card is removed from the slot (i.e. after high to low transition on pad_mem_ctrl_0 pin). This is to provide the hot removal support.
+#define SD4HC_SRS_SRS10__BP
+#define SD4HC_SRS_SRS10__BP_MASK 0x00000100U
+#define SD4HC_SRS_SRS10__BP_SHIFT 8U
+//! Slice: SRS10__BVS:
+//! BVS - SD Bus Voltage Select\n This field is used to configure VDD1 voltage level.The state of this field directly drives pad_bv port.\n [list] [*] 000b-100b - Reserved [*] 101b - 1.8V (typical) for embedded [*] 110b - 3.0V (typical) [*] 111b - 3.3V (typical) [*] others - Reserved [/list]
+#define SD4HC_SRS_SRS10__BVS
+#define SD4HC_SRS_SRS10__BVS_MASK 0x00000E00U
+#define SD4HC_SRS_SRS10__BVS_SHIFT 9U
+//! Slice: SRS10__SBGR:
+//! SBGR - Stop At Block Gap Request\n When set to 1, orders the stop executing read and write transaction at the next possible block gap for non-DMA, SDMA and ADMA transfers. The software will maintain SBGR=1 until the current transfer is complete (typically by waiting for - Transfer Complete bit). After Transfer Complete event, the software will set SBGR back to 0.\n In case of the read transfer, the host stops after the next data block received from the card. This uses the Read-Wait mechanism if it is enabled by SRS10.RWC, or stops the card clock (\textit{pad_mem_webar_t}) if Read-Wait is disabled. \n In the case of the write transfer, host stops after the last block written to the data buffer. The host sends all data already written to the internal data buffer before stopping the transfer.\n In case of stopping non-DMA write transfer, the software will set this bit only at block gap (block unit (SD mode)).
+#define SD4HC_SRS_SRS10__SBGR
+#define SD4HC_SRS_SRS10__SBGR_MASK 0x00010000U
+#define SD4HC_SRS_SRS10__SBGR_SHIFT 16U
+//! Slice: SRS10__CREQ:
+//! CR - Continue Request\n When set to 1, restarts the transfer previously stopped using the Stop At Block Gap.\n The software will set SRS10.SBGR (Stop At Block Gap) bit to 0 before setting the (CR) Continue Request.\n When SRS10.SBGR=1, then all write operations to Continue Request are ignored. Clearing SRS10.SBGR can be done before or simultaneously with writing the CR. Continue Request bit is cleared automatically by the host when SRS09.DLA (Dat Line Active) changes from 0 to 1, indicating the actual restart of the transfer.
+#define SD4HC_SRS_SRS10__CREQ
+#define SD4HC_SRS_SRS10__CREQ_MASK 0x00020000U
+#define SD4HC_SRS_SRS10__CREQ_SHIFT 17U
+//! Slice: SRS10__RWC:
+//! RWC - Read-Wait Control\n When set to 1, enables Read Wait control. The Read Wait function is optional for SDIO cards.\n If the card does not support read wait, this bit would never be set to 1; otherwise, DAT line conflict may occur.
+#define SD4HC_SRS_SRS10__RWC
+#define SD4HC_SRS_SRS10__RWC_MASK 0x00040000U
+#define SD4HC_SRS_SRS10__RWC_SHIFT 18U
+//! Slice: SRS10__IBG:
+//! IBG - Interrupt At Block Gap\n When set to 1, enables interrupt detection at the block gap for a multiple block transfer.\n This bit is valid only in SD4 mode.\n If the SD card cannot signal an interrupt during a multiple block transfer, this bit should be set to 0.\n
+#define SD4HC_SRS_SRS10__IBG
+#define SD4HC_SRS_SRS10__IBG_MASK 0x00080000U
+#define SD4HC_SRS_SRS10__IBG_SHIFT 19U
+//! Slice: SRS10__WOIQ:
+//! WOIQ - Wakeup Event Enable On Card Interrupt\n When set to 1, enables wake-up event via Card Interrupt assertion in the SRS12.CINT
+#define SD4HC_SRS_SRS10__WOIQ
+#define SD4HC_SRS_SRS10__WOIQ_MASK 0x01000000U
+#define SD4HC_SRS_SRS10__WOIQ_SHIFT 24U
+//! Slice: SRS10__WOIS:
+//! WOIS - Wake-Up Event Enable On Card Inserted\n When set to 1, enables wake-up event via Card Insertion assertion in the SRS12.CIN register.
+#define SD4HC_SRS_SRS10__WOIS
+#define SD4HC_SRS_SRS10__WOIS_MASK 0x02000000U
+#define SD4HC_SRS_SRS10__WOIS_SHIFT 25U
+//! Slice: SRS10__WORM:
+//! WORM - Wakeup Event Enable On SD Card Removal\n When set to 1, enables wake-up event via Card Removal assertion in the SRS12.CR register.
+#define SD4HC_SRS_SRS10__WORM
+#define SD4HC_SRS_SRS10__WORM_MASK 0x04000000U
+#define SD4HC_SRS_SRS10__WORM_SHIFT 26U
+
+//! Register: srs11: SRS11 (SD4HC_SRS_BASE + 0x0000002c)
+//! Slice: SRS11__ICE:
+//! ICE - Internal Clock Enable\n This field is designated to controls (enable/disable) external clock generator (e.g. PLL). The ICE bits of every slot are logically OR-ed together and then drive the ice pin. It means, the ice pin is 0 only when ICE in 0 for every slot implemented inside the host.\n The ice pin is 1 if at least one of the ICE bits is set to 1.\n When set to 0, the clock on sdmclk pin can be stopped externally.\n If the sdmclk is stopped, then host goes to a very low power state. The hosts registers are still operable (read and written operation are valid) even if the clock on sdmclk is stopped.\n Setting of the ICE bit does not affect card detection. It means, the card detection works even if the clock on sdmclk is stopped.
+#define SD4HC_SRS_SRS11__ICE
+#define SD4HC_SRS_SRS11__ICE_MASK 0x00000001U
+#define SD4HC_SRS_SRS11__ICE_SHIFT 0U
+//! Slice: SRS11__ICS:
+//! ICS - Internal Clock Stable\n When read as 1, indicates that the clock on sdmclk pin of the host is stable after setting ICE to 1.\n When read as 0, indicates that the clock is not stable yet (for example the external PLL that generates the clock is not yet locked).\n The value of ICS is equal to the actual signal level on ics pin of the host. The user will connect ics to the external PLL if required. Otherwise, ics should be connected directly to the ice output of the host.
+#define SD4HC_SRS_SRS11__ICS
+#define SD4HC_SRS_SRS11__ICS_MASK 0x00000002U
+#define SD4HC_SRS_SRS11__ICS_SHIFT 1U
+//! Slice: SRS11__SDCE:
+//! SDCE - SD Clock Enable\n When set to 1, SDCLK clock is enabled.\n When cleared to 0, SDCLK clock is stopped.\n The host clears SDCE automatically when card is removed from the slot (i.e. after the high to low transition on \textit{pad_mem_ctrl_0} pad).\n The SDCLK clock should be stopped by the software when changing the clock divider (i.e. SDCE bit will be cleared before writing SRS11.SDCFSL, SRS11.SDCFSH).
+#define SD4HC_SRS_SRS11__SDCE
+#define SD4HC_SRS_SRS11__SDCE_MASK 0x00000004U
+#define SD4HC_SRS_SRS11__SDCE_SHIFT 2U
+//! Slice: SRS11__SDCFSH:
+//! SDCFSH - SDCLK Frequency Select (higher part)\n This register is an extension to SDCFSL.
+#define SD4HC_SRS_SRS11__SDCFSH
+#define SD4HC_SRS_SRS11__SDCFSH_MASK 0x000000C0U
+#define SD4HC_SRS_SRS11__SDCFSH_SHIFT 6U
+//! Slice: SRS11__SDCFSL:
+//! SDCFSL - SDCLK Frequency Select (lower part)\n This register and SRS11.SDCFSH are used to calculate frequency of SDCLK clock.\n The SDCLK frequency is calculated with following expressions:\n - sdclk = sdmclk; when (N=0)\n - sdclk = sdmclk/2N; when (N>0)\n Variable N is concatenation of SRS11.SDCFSH and SRS11.SDCFSL.\n The value of SDCFSL, SDCFSH registers can be changed only when SRS11.SDCE (SD Clock Enable)=0.
+#define SD4HC_SRS_SRS11__SDCFSL
+#define SD4HC_SRS_SRS11__SDCFSL_MASK 0x0000FF00U
+#define SD4HC_SRS_SRS11__SDCFSL_SHIFT 8U
+//! Slice: SRS11__DTCV:
+//! DTCV - Data Timeout Counter Value\n This value determines the interval by which DAT line timeouts are detected.\n The interval can be computed as below: [list] [*] 1111b - Reserved [*] 1110b - t_sdmclk*2^(27+2) [*] 1101b - t_sdmclk*2^(26+2) [*] ... [*] 0001b - t_sdmclk*2^(14+2) [*] 0000b - t_sdmclk*2^(13+2) [/list] Where t_sdmclk is the sdmclk clock periodRefer to the Data Timeout Error (SRS12.EDT) register for information on factors which generate data timeouts.
+#define SD4HC_SRS_SRS11__DTCV
+#define SD4HC_SRS_SRS11__DTCV_MASK 0x000F0000U
+#define SD4HC_SRS_SRS11__DTCV_SHIFT 16U
+//! Slice: SRS11__SRFA:
+//! SRFA - Software Reset For All\n When set to 1, the entire slot is reset.After completing the reset operation, SRFA bit is automatically cleared. It takes some time to complete the reset operation, so the software will wait until SRFA=0, and continue the other operations only when SRFA=0.\n Additionally, after SRFA, software should reset and reinitialize card inserted to the slot.\n SD Card Power may be enabled 1 ms after this bit is cleared to ensure SD Card has been reset properly.
+#define SD4HC_SRS_SRS11__SRFA
+#define SD4HC_SRS_SRS11__SRFA_MASK 0x01000000U
+#define SD4HC_SRS_SRS11__SRFA_SHIFT 24U
+//! Slice: SRS11__SRCMD:
+//! SRCMD - Software Reset For CMD Line\n When set to 1, resets the logic related to the command generation and response checking.\n The following registers and bits are cleared: [list] [*] SRS09 register: Command Inhibit CMD [*] SRS12 register: Command Complete [/list] After completing the reset operation, SRS11.SRCMD bit is automatically cleared. It takes some time to complete the reset operation, so the software will wait until SRCMD=0, and continue the other operations only when SRS11.SRCMD=0.
+#define SD4HC_SRS_SRS11__SRCMD
+#define SD4HC_SRS_SRS11__SRCMD_MASK 0x02000000U
+#define SD4HC_SRS_SRS11__SRCMD_SHIFT 25U
+//! Slice: SRS11__SRDAT:
+//! SRDAT - Software Reset For DAT Line\n When set to 1, resets the logic related to the data path, including data buffers and the DMA logic.\n The following registers and bits are cleared:\n SRS08 register: [list] [*] Buffer [/list] SRS09 register: [list] [*] Buffer Read Enable [*] Buffer Write Enable [*] Read Transfer Active [*] Write Transfer Active [*] DAT Line Active [*] Command Inhibit [/list] DATSRS10 register: [list] [*] Continue Request [*] Stop At Block Gap Request [/list] SRS12 register: [list] [*] Buffer Read Ready [*] Buffer Write Ready [*] DMA Interrupt [*] Block Gap Event [*] Transfer Complete [/list] After completing the reset operation, SRS11.SRDAT bit is automatically cleared. It takes some time to complete the reset operation, so the software will wait until SRS11.SRDAT=0, and continue the other operations only when SRS11.SRDAT=0.
+#define SD4HC_SRS_SRS11__SRDAT
+#define SD4HC_SRS_SRS11__SRDAT_MASK 0x04000000U
+#define SD4HC_SRS_SRS11__SRDAT_SHIFT 26U
+
+//! Register: srs12: SRS12 (SD4HC_SRS_BASE + 0x00000030)
+//! Slice: SRS12__CC:
+//! CC - Command Complete\n Generated when the end bit of the response is received, except the response for Auto-CMD12 command. Auto-CMD12 command does not generate CC.
+#define SD4HC_SRS_SRS12__CC
+#define SD4HC_SRS_SRS12__CC_MASK 0x00000001U
+#define SD4HC_SRS_SRS12__CC_SHIFT 0U
+//! Slice: SRS12__TC:
+//! TC - Transfer Complete\n SD Mode:\n Generated when the transfer which uses the DAT line is complete. Transfers which use the DAT line include the read/write transfers and commands with a busy response.\n In case of the read transfer, TC indicates that the entire data was transferred from the card to the host system (i.e. the host FIFO is empty after reading the last data block).\n In case of the write transfer, TC indicates that the entire data was transferred from the host to the card (i.e. the host FIFO is empty after writing the last data block), and the card accepted the data (busy signal released after the last block). In the case of the command with a busy response, TC indicates that the busy signal is released after the response.
+#define SD4HC_SRS_SRS12__TC
+#define SD4HC_SRS_SRS12__TC_MASK 0x00000002U
+#define SD4HC_SRS_SRS12__TC_SHIFT 1U
+//! Slice: SRS12__BGE:
+//! BGE - Block Gap Event\n Generated when the read/write transaction is stopped at a block gap as the result of setting SRS10.SBGR to 1.
+#define SD4HC_SRS_SRS12__BGE
+#define SD4HC_SRS_SRS12__BGE_MASK 0x00000004U
+#define SD4HC_SRS_SRS12__BGE_SHIFT 2U
+//! Slice: SRS12__DMAINT:
+//! DMAINT - DMA Interrupt\n In SDMA mode, DMA interrupt is generated when the host controller detects the Host SDMA Buffer boundary.\n In ADMA mode, DMA interrupt is generated when the INT flag is set in a currently serviced ADMA descriptor.
+#define SD4HC_SRS_SRS12__DMAINT
+#define SD4HC_SRS_SRS12__DMAINT_MASK 0x00000008U
+#define SD4HC_SRS_SRS12__DMAINT_SHIFT 3U
+//! Slice: SRS12__BWR:
+//! BWR - Buffer Write Ready\n Generated when the BWE changes from 0 to 1, indicating that the data buffer can be written by the software.
+#define SD4HC_SRS_SRS12__BWR
+#define SD4HC_SRS_SRS12__BWR_MASK 0x00000010U
+#define SD4HC_SRS_SRS12__BWR_SHIFT 4U
+//! Slice: SRS12__BRR:
+//! BRR - Buffer Read Ready\n Generated when the BRE changes from 0 to 1, indicating that the data buffer can be read by the software.\n This field works differently in the SD Tuning Sequence, i.e. when Sampling Clock Select (SRS15.SCS) equals 1. It is set to 1 on the tune step completion despite of the step's result. As per the Standard, during the SD tuning, none of the interrupts is notified except Buffer Read Ready.
+#define SD4HC_SRS_SRS12__BRR
+#define SD4HC_SRS_SRS12__BRR_MASK 0x00000020U
+#define SD4HC_SRS_SRS12__BRR_SHIFT 5U
+//! Slice: SRS12__CIN:
+//! CIN - Card Insertion\n Generated when the SRS09.CI bit changes from 0 to 1, indicating card insertion.\n When read as 1, indicates that the card was inserted to the slot.\n When read as 0, indicates that the card state is stable (still inserted or removed) or that the debouncing is in progress.
+#define SD4HC_SRS_SRS12__CIN
+#define SD4HC_SRS_SRS12__CIN_MASK 0x00000040U
+#define SD4HC_SRS_SRS12__CIN_SHIFT 6U
+//! Slice: SRS12__CR:
+//! CR - Card Removal\n Generated when the SRS09.CI bit changes from 1 to 0, indicating card removal event.\n When read as 1, indicates that the card was removed from the slot.\n When read as 0, indicates that the card state is stable (still inserted or removed) or that the debouncing is in progress.
+#define SD4HC_SRS_SRS12__CR
+#define SD4HC_SRS_SRS12__CR_MASK 0x00000080U
+#define SD4HC_SRS_SRS12__CR_SHIFT 7U
+//! Slice: SRS12__CINT:
+//! CINT - Card Interrupt\n Indicates the card interrupt. CINT is not sampled by the card clock, so the interrupt can be detected even with SD clock stopped (SRS11.SDCE=0). Also, CINT is not cleared by writing 1. Instead, the software will clear the source of an interrupt inside the card.After detecting the Card Interrupt, the software will stop further interrupt detection by clearing SRS13.CINT_SE to 0. Then, the software will clear the interrupt source inside the card by using the appropriate commands. For the details, please refer to the SDIO Card Specification.\n After clearing the interrupt source, the card will stop to drive the interrupt signal to the host. Finally, when the interrupt service routine is finished, the interrupt detection can be enabled by setting SRS13.CINT_SE back to 1.
+#define SD4HC_SRS_SRS12__CINT
+#define SD4HC_SRS_SRS12__CINT_MASK 0x00000100U
+#define SD4HC_SRS_SRS12__CINT_SHIFT 8U
+//! Slice: SRS12__FXE:
+//! FXE - FX Event\n If SRS03.RECE is set to 1, and SRS03.RECT is set to 0 this interrupt indicates that 14th bit of response stored as 6th bit of SRS04 register is set to 1.\n If SRS03.RECE is set to 1 only next response with type R1 containing card status bit 14th equal 0 can clean this interrupt.\n If SRS03.RECE is set to 0, this interrupt indicates that 14th bit of response stored as 6th bit of SRS04 register is set to 1 except cases:\n 1. Argument of CMD13 bit 15 is equal 1 - then response won't change value of this interrupt.\n 2. Issued command does not have a response - then value of this interrupt won't change.\n
+#define SD4HC_SRS_SRS12__FXE
+#define SD4HC_SRS_SRS12__FXE_MASK 0x00002000U
+#define SD4HC_SRS_SRS12__FXE_SHIFT 13U
+//! Slice: SRS12__CQINT:
+//! CQINT - Command Queuing Interrupt\n This interrupt is asserted when at least one of the bits in CQIS register is set. This interrupt is cleared only by clearing the source interrupt in CQIS register.
+#define SD4HC_SRS_SRS12__CQINT
+#define SD4HC_SRS_SRS12__CQINT_MASK 0x00004000U
+#define SD4HC_SRS_SRS12__CQINT_SHIFT 14U
+//! Slice: SRS12__EINT:
+//! EINT - Error Interrupt\n This bit is set if any of bits in range SRS12[31:16] is set; The software can check for an error by reading this single bit first.
+#define SD4HC_SRS_SRS12__EINT
+#define SD4HC_SRS_SRS12__EINT_MASK 0x00008000U
+#define SD4HC_SRS_SRS12__EINT_SHIFT 15U
+//! Slice: SRS12__ECT:
+//! ECT - Command Timeout Error\n When set to 1, indicates that no response was returned within 64 SDCLK cycles from the end bit of the command.
+#define SD4HC_SRS_SRS12__ECT
+#define SD4HC_SRS_SRS12__ECT_MASK 0x00010000U
+#define SD4HC_SRS_SRS12__ECT_SHIFT 16U
+//! Slice: SRS12__ECCRC:
+//! ECCRC - Command CRC Error (SD mode only)\n When set to 1, indicates that command CRC error has occurred.
+#define SD4HC_SRS_SRS12__ECCRC
+#define SD4HC_SRS_SRS12__ECCRC_MASK 0x00020000U
+#define SD4HC_SRS_SRS12__ECCRC_SHIFT 17U
+//! Slice: SRS12__ECEB:
+//! ECEB - Command End Bit Error (SD mode only)\n When set to 1, indicates detecting that the end bit of a command response is 0.
+#define SD4HC_SRS_SRS12__ECEB
+#define SD4HC_SRS_SRS12__ECEB_MASK 0x00040000U
+#define SD4HC_SRS_SRS12__ECEB_SHIFT 18U
+//! Slice: SRS12__ECI:
+//! ECI - Command Index Error (SD mode only)\n When set to 1, indicates that Index error occurs in the command response.
+#define SD4HC_SRS_SRS12__ECI
+#define SD4HC_SRS_SRS12__ECI_MASK 0x00080000U
+#define SD4HC_SRS_SRS12__ECI_SHIFT 19U
+//! Slice: SRS12__EDT:
+//! EDT - Data Timeout Error (SD mode only)\n When set to 1, indicates detecting one of the following timeout conditions:\n 1. Busy timeout for the response with busy.\n 2. Busy timeout after Write CRC status.\n 3. Write CRC Status timeout.\n 4. Read data timeout.\n This bit will be set to 1 immediately when conflict on CMD line conflict detected.
+#define SD4HC_SRS_SRS12__EDT
+#define SD4HC_SRS_SRS12__EDT_MASK 0x00100000U
+#define SD4HC_SRS_SRS12__EDT_SHIFT 20U
+//! Slice: SRS12__EDCRC:
+//! EDCRC - Data CRC Error (SD mode only)\n When set to 1, indicates detecting CRC error when transferring read data which uses the DAT line, or when detecting the Write CRC status having a value of other than 010.\n This bit will be set to 1 immediately when conflict on CMD line detected.\n The conflict is signalized by setting this bit and SRS12.EDT to 1.
+#define SD4HC_SRS_SRS12__EDCRC
+#define SD4HC_SRS_SRS12__EDCRC_MASK 0x00200000U
+#define SD4HC_SRS_SRS12__EDCRC_SHIFT 21U
+//! Slice: SRS12__EDEB:
+//! EDEB - Data End Bit Error (SD mode only)\n When set to 1, indicates detecting 0 at the end bit position of read data transfer which uses the DAT line, or at the end bit position of the Write CRC Status.
+#define SD4HC_SRS_SRS12__EDEB
+#define SD4HC_SRS_SRS12__EDEB_MASK 0x00400000U
+#define SD4HC_SRS_SRS12__EDEB_SHIFT 22U
+//! Slice: SRS12__ECL:
+//! ECL - Current Limit Error\n This fields carries an error/failure reported on the \textit{pad_cle} input pad of the Host Controller. The error/failure generation is located outside of this soft IP.\n\n Note: If the external power supply for SD/eMMC device does not monitor and report this type of error, connect the Current Limit Error (\textit{sdphy_dfi_cle} input of the Host Controller core) to 0.
+#define SD4HC_SRS_SRS12__ECL
+#define SD4HC_SRS_SRS12__ECL_MASK 0x00800000U
+#define SD4HC_SRS_SRS12__ECL_SHIFT 23U
+//! Slice: SRS12__EAC:
+//! EAC - Auto CMD Error (SD mode only)\n Generated when an error occurs during Auto CMD12/Auto CMD23 command transmission.\n It indicates one of the following conditions:\n - one of the bits in SRS15 register has changed from 0 to 1,\n - Auto CMD12 is not executed due to the previous command error.
+#define SD4HC_SRS_SRS12__EAC
+#define SD4HC_SRS_SRS12__EAC_MASK 0x01000000U
+#define SD4HC_SRS_SRS12__EAC_SHIFT 24U
+//! Slice: SRS12__EADMA:
+//! EADMA - ADMA Error\n Generated when an error occurs during ADMA read or write transfer.\n To resolve the cause of the error, the state of the ADMA engine at error occurrence is saved in ADMA Error Status register, and the address of the descriptor processed at error occurrence is provided in ADMA System Address register.
+#define SD4HC_SRS_SRS12__EADMA
+#define SD4HC_SRS_SRS12__EADMA_MASK 0x02000000U
+#define SD4HC_SRS_SRS12__EADMA_SHIFT 25U
+//! Slice: SRS12__ERSP:
+//! ERSP - Response Error\n Generated on error detection inside R1 or R5 response.\n Errors will be checked only if RECE is set 1.
+#define SD4HC_SRS_SRS12__ERSP
+#define SD4HC_SRS_SRS12__ERSP_MASK 0x08000000U
+#define SD4HC_SRS_SRS12__ERSP_SHIFT 27U
+
+//! Register: srs13: SRS13 (SD4HC_SRS_BASE + 0x00000034)
+//! Slice: SRS13__CC_SE:
+//! CC_SE - Command Complete Status Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__CC_SE
+#define SD4HC_SRS_SRS13__CC_SE_MASK 0x00000001U
+#define SD4HC_SRS_SRS13__CC_SE_SHIFT 0U
+//! Slice: SRS13__TC_SE:
+//! TC_SE - Transfer Complete Status Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__TC_SE
+#define SD4HC_SRS_SRS13__TC_SE_MASK 0x00000002U
+#define SD4HC_SRS_SRS13__TC_SE_SHIFT 1U
+//! Slice: SRS13__BGE_SE:
+//! BGE_SE - Block Gap Event Status Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__BGE_SE
+#define SD4HC_SRS_SRS13__BGE_SE_MASK 0x00000004U
+#define SD4HC_SRS_SRS13__BGE_SE_SHIFT 2U
+//! Slice: SRS13__DMAINT_SE:
+//! DMAINT_SE - DMA Interrupt Status Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__DMAINT_SE
+#define SD4HC_SRS_SRS13__DMAINT_SE_MASK 0x00000008U
+#define SD4HC_SRS_SRS13__DMAINT_SE_SHIFT 3U
+//! Slice: SRS13__BWR_SE:
+//! BWR_SE - Buffer Write Ready Status Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__BWR_SE
+#define SD4HC_SRS_SRS13__BWR_SE_MASK 0x00000010U
+#define SD4HC_SRS_SRS13__BWR_SE_SHIFT 4U
+//! Slice: SRS13__BRR_SE:
+//! BRR_SE - Buffer Read Ready Status Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__BRR_SE
+#define SD4HC_SRS_SRS13__BRR_SE_MASK 0x00000020U
+#define SD4HC_SRS_SRS13__BRR_SE_SHIFT 5U
+//! Slice: SRS13__CIN_SE:
+//! CIN_SE -Card Insertion Status Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__CIN_SE
+#define SD4HC_SRS_SRS13__CIN_SE_MASK 0x00000040U
+#define SD4HC_SRS_SRS13__CIN_SE_SHIFT 6U
+//! Slice: SRS13__CR_SE:
+//! CR_SE - Card Removal Status Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__CR_SE
+#define SD4HC_SRS_SRS13__CR_SE_MASK 0x00000080U
+#define SD4HC_SRS_SRS13__CR_SE_SHIFT 7U
+//! Slice: SRS13__CINT_SE:
+//! CINT_SE - Card Interrupt Status Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__CINT_SE
+#define SD4HC_SRS_SRS13__CINT_SE_MASK 0x00000100U
+#define SD4HC_SRS_SRS13__CINT_SE_SHIFT 8U
+//! Slice: SRS13__FXE_SE:
+//! FXE_SE - FX Event Status Enable \n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__FXE_SE
+#define SD4HC_SRS_SRS13__FXE_SE_MASK 0x00002000U
+#define SD4HC_SRS_SRS13__FXE_SE_SHIFT 13U
+//! Slice: SRS13__CQINT_SE:
+//! CQINT_SE - Command Queuing Status Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__CQINT_SE
+#define SD4HC_SRS_SRS13__CQINT_SE_MASK 0x00004000U
+#define SD4HC_SRS_SRS13__CQINT_SE_SHIFT 14U
+//! Slice: SRS13__ECT_SE:
+//! ECT_SE - Command Timeout Error Status Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__ECT_SE
+#define SD4HC_SRS_SRS13__ECT_SE_MASK 0x00010000U
+#define SD4HC_SRS_SRS13__ECT_SE_SHIFT 16U
+//! Slice: SRS13__ECCRC_SE:
+//! ECCRC_SE - Command CRC Error Status Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__ECCRC_SE
+#define SD4HC_SRS_SRS13__ECCRC_SE_MASK 0x00020000U
+#define SD4HC_SRS_SRS13__ECCRC_SE_SHIFT 17U
+//! Slice: SRS13__ECEB_SE:
+//! ECEB_SE - Command End Bit Error Status Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__ECEB_SE
+#define SD4HC_SRS_SRS13__ECEB_SE_MASK 0x00040000U
+#define SD4HC_SRS_SRS13__ECEB_SE_SHIFT 18U
+//! Slice: SRS13__ECI_SE:
+//! ECI_SE - Command Index Error Status Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__ECI_SE
+#define SD4HC_SRS_SRS13__ECI_SE_MASK 0x00080000U
+#define SD4HC_SRS_SRS13__ECI_SE_SHIFT 19U
+//! Slice: SRS13__EDT_SE:
+//! EDT_SE - Data Timeout Error Status Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__EDT_SE
+#define SD4HC_SRS_SRS13__EDT_SE_MASK 0x00100000U
+#define SD4HC_SRS_SRS13__EDT_SE_SHIFT 20U
+//! Slice: SRS13__EDCRC_SE:
+//! EDCRC_SE - Data CRC Error Status Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__EDCRC_SE
+#define SD4HC_SRS_SRS13__EDCRC_SE_MASK 0x00200000U
+#define SD4HC_SRS_SRS13__EDCRC_SE_SHIFT 21U
+//! Slice: SRS13__EDEB_SE:
+//! EDEB_SE - Data End Bit Error Status Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__EDEB_SE
+#define SD4HC_SRS_SRS13__EDEB_SE_MASK 0x00400000U
+#define SD4HC_SRS_SRS13__EDEB_SE_SHIFT 22U
+//! Slice: SRS13__ECL_SE:
+//! ECL_SE - Current Limit Error Status Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__ECL_SE
+#define SD4HC_SRS_SRS13__ECL_SE_MASK 0x00800000U
+#define SD4HC_SRS_SRS13__ECL_SE_SHIFT 23U
+//! Slice: SRS13__EAC_SE:
+//! EAC_SE - Auto CMD Error Status Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__EAC_SE
+#define SD4HC_SRS_SRS13__EAC_SE_MASK 0x01000000U
+#define SD4HC_SRS_SRS13__EAC_SE_SHIFT 24U
+//! Slice: SRS13__EADMA_SE:
+//! EADMA_SE - ADMA Error Status Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__EADMA_SE
+#define SD4HC_SRS_SRS13__EADMA_SE_MASK 0x02000000U
+#define SD4HC_SRS_SRS13__EADMA_SE_SHIFT 25U
+//! Slice: SRS13__ERSP_SE:
+//! ERSP_SE - Response Error Status Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS13__ERSP_SE
+#define SD4HC_SRS_SRS13__ERSP_SE_MASK 0x08000000U
+#define SD4HC_SRS_SRS13__ERSP_SE_SHIFT 27U
+
+//! Register: srs14: SRS14 (SD4HC_SRS_BASE + 0x00000038)
+//! Slice: SRS14__CC_IE:
+//! CC_IE - Command Complete Interrupt Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__CC_IE
+#define SD4HC_SRS_SRS14__CC_IE_MASK 0x00000001U
+#define SD4HC_SRS_SRS14__CC_IE_SHIFT 0U
+//! Slice: SRS14__TC_IE:
+//! TC_IE - Transfer Complete Interrupt Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__TC_IE
+#define SD4HC_SRS_SRS14__TC_IE_MASK 0x00000002U
+#define SD4HC_SRS_SRS14__TC_IE_SHIFT 1U
+//! Slice: SRS14__BGE_IE:
+//! BGE_IE - Block Gap Event Interrupt Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__BGE_IE
+#define SD4HC_SRS_SRS14__BGE_IE_MASK 0x00000004U
+#define SD4HC_SRS_SRS14__BGE_IE_SHIFT 2U
+//! Slice: SRS14__DMAINT_IE:
+//! DMAINT_IE - DMA Interrupt Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__DMAINT_IE
+#define SD4HC_SRS_SRS14__DMAINT_IE_MASK 0x00000008U
+#define SD4HC_SRS_SRS14__DMAINT_IE_SHIFT 3U
+//! Slice: SRS14__BWR_IE:
+//! BWR_IE - Buffer Write Ready Interrupt Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__BWR_IE
+#define SD4HC_SRS_SRS14__BWR_IE_MASK 0x00000010U
+#define SD4HC_SRS_SRS14__BWR_IE_SHIFT 4U
+//! Slice: SRS14__BRR_IE:
+//! BRR_IE - Buffer Read Ready Interrupt Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__BRR_IE
+#define SD4HC_SRS_SRS14__BRR_IE_MASK 0x00000020U
+#define SD4HC_SRS_SRS14__BRR_IE_SHIFT 5U
+//! Slice: SRS14__CIN_IE:
+//! CIN_IE - Card Insertion Interrupt Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__CIN_IE
+#define SD4HC_SRS_SRS14__CIN_IE_MASK 0x00000040U
+#define SD4HC_SRS_SRS14__CIN_IE_SHIFT 6U
+//! Slice: SRS14__CR_IE:
+//! CR_IE - Card Removal Interrupt Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__CR_IE
+#define SD4HC_SRS_SRS14__CR_IE_MASK 0x00000080U
+#define SD4HC_SRS_SRS14__CR_IE_SHIFT 7U
+//! Slice: SRS14__CINT_IE:
+//! CINT_IE - Card Interrupt - Interrupt Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__CINT_IE
+#define SD4HC_SRS_SRS14__CINT_IE_MASK 0x00000100U
+#define SD4HC_SRS_SRS14__CINT_IE_SHIFT 8U
+//! Slice: SRS14__FXE_IE:
+//! FXE_IE - FX Event Interrupt Enable \n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__FXE_IE
+#define SD4HC_SRS_SRS14__FXE_IE_MASK 0x00002000U
+#define SD4HC_SRS_SRS14__FXE_IE_SHIFT 13U
+//! Slice: SRS14__CQINT_IE:
+//! CQINT_IE - Command Queuing - Interrupt Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__CQINT_IE
+#define SD4HC_SRS_SRS14__CQINT_IE_MASK 0x00004000U
+#define SD4HC_SRS_SRS14__CQINT_IE_SHIFT 14U
+//! Slice: SRS14__ECT_IE:
+//! ECT_IE - Command Timeout Error Interrupt Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__ECT_IE
+#define SD4HC_SRS_SRS14__ECT_IE_MASK 0x00010000U
+#define SD4HC_SRS_SRS14__ECT_IE_SHIFT 16U
+//! Slice: SRS14__ECCRC_IE:
+//! ECCRC_IE - Command CRC Error Interrupt Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__ECCRC_IE
+#define SD4HC_SRS_SRS14__ECCRC_IE_MASK 0x00020000U
+#define SD4HC_SRS_SRS14__ECCRC_IE_SHIFT 17U
+//! Slice: SRS14__ECEB_IE:
+//! ECEB_IE - Command End Bit Error Interrupt Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__ECEB_IE
+#define SD4HC_SRS_SRS14__ECEB_IE_MASK 0x00040000U
+#define SD4HC_SRS_SRS14__ECEB_IE_SHIFT 18U
+//! Slice: SRS14__ECI_IE:
+//! ECI_IE - Command Index Error Interrupt Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__ECI_IE
+#define SD4HC_SRS_SRS14__ECI_IE_MASK 0x00080000U
+#define SD4HC_SRS_SRS14__ECI_IE_SHIFT 19U
+//! Slice: SRS14__EDT_IE:
+//! EDT_IE - ata Timeout Error Interrupt Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__EDT_IE
+#define SD4HC_SRS_SRS14__EDT_IE_MASK 0x00100000U
+#define SD4HC_SRS_SRS14__EDT_IE_SHIFT 20U
+//! Slice: SRS14__EDCRC_IE:
+//! EDCRC_IE - Data CRC Error Interrupt Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__EDCRC_IE
+#define SD4HC_SRS_SRS14__EDCRC_IE_MASK 0x00200000U
+#define SD4HC_SRS_SRS14__EDCRC_IE_SHIFT 21U
+//! Slice: SRS14__EDEB_IE:
+//! EDEB_IE - Data End Bit Error Interrupt Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__EDEB_IE
+#define SD4HC_SRS_SRS14__EDEB_IE_MASK 0x00400000U
+#define SD4HC_SRS_SRS14__EDEB_IE_SHIFT 22U
+//! Slice: SRS14__ECL_IE:
+//! ECL_IE - Current Limit Error Interrupt Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__ECL_IE
+#define SD4HC_SRS_SRS14__ECL_IE_MASK 0x00800000U
+#define SD4HC_SRS_SRS14__ECL_IE_SHIFT 23U
+//! Slice: SRS14__EAC_IE:
+//! EAC_IE - Auto CMD Error Interrupt Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__EAC_IE
+#define SD4HC_SRS_SRS14__EAC_IE_MASK 0x01000000U
+#define SD4HC_SRS_SRS14__EAC_IE_SHIFT 24U
+//! Slice: SRS14__EADMA_IE:
+//! EADMA_IE - ADMA Error Interrupt Enable (SD mode only)\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__EADMA_IE
+#define SD4HC_SRS_SRS14__EADMA_IE_MASK 0x02000000U
+#define SD4HC_SRS_SRS14__EADMA_IE_SHIFT 25U
+//! Slice: SRS14__ERSP_IE:
+//! ERSP_IE - Response Error Interrupt Enable\n 1 - enabled\n 0 - masked
+#define SD4HC_SRS_SRS14__ERSP_IE
+#define SD4HC_SRS_SRS14__ERSP_IE_MASK 0x08000000U
+#define SD4HC_SRS_SRS14__ERSP_IE_SHIFT 27U
+
+//! Register: srs15: SRS15 (SD4HC_SRS_BASE + 0x0000003c)
+//! Slice: SRS15__ACNE:
+//! ACNE - Auto CMD12 Not Executed\n When set to 1, means the host cannot issue Auto CMD12 due to some error. If this bit is set to 1, other error status bits (SRS15[4:1]) are meaningless.\n Bit is updated with 0, when Auto CMD23 Error is detected (any of bits SRS15[4:1] is set).
+#define SD4HC_SRS_SRS15__ACNE
+#define SD4HC_SRS_SRS15__ACNE_MASK 0x00000001U
+#define SD4HC_SRS_SRS15__ACNE_SHIFT 0U
+//! Slice: SRS15__ACTE:
+//! ACTE - Auto CMD Timeout Error\n When read as 1, indicates that there was no response within 64 SDCLK clock cycles from the end bit of the Auto CMD or conflict on the CMD lines is detected (see table in SRS15.ACCE field description).\n If this bit is set to 1, the other error status bits (SRS15[4:2]) are meaningless.
+#define SD4HC_SRS_SRS15__ACTE
+#define SD4HC_SRS_SRS15__ACTE_MASK 0x00000002U
+#define SD4HC_SRS_SRS15__ACTE_SHIFT 1U
+//! Slice: SRS15__ACCE:
+//! ACCE - Auto CMD CRC Error\n When read as 1, indicates a CRC error was detected in the Auto CMD response or conflict on the CMD lines is detected:\n ACCE(SRS15.2) = 0, ACTE(SRS15.1) = 0 - No error\n ACCE(SRS15.2) = 0, ACTE(SRS15.1) = 1 - Auto CMD Timeout error detected\n ACCE(SRS15.2) = 1, ACTE(SRS15.1) = 0 - Auto CMD CRC error detected\n ACCE(SRS15.2) = 1, ACTE(SRS15.1) = 1 - Conflict on the CMD line detected
+#define SD4HC_SRS_SRS15__ACCE
+#define SD4HC_SRS_SRS15__ACCE_MASK 0x00000004U
+#define SD4HC_SRS_SRS15__ACCE_SHIFT 2U
+//! Slice: SRS15__ACEBE:
+//! ACEBE - Auto CMD End Bit Error\n When read as 1, indicates that the end bit of the Auto-CMD response is 0.
+#define SD4HC_SRS_SRS15__ACEBE
+#define SD4HC_SRS_SRS15__ACEBE_MASK 0x00000008U
+#define SD4HC_SRS_SRS15__ACEBE_SHIFT 3U
+//! Slice: SRS15__ACIE:
+//! ACIE - Auto CMD Index Error\n When read as 1, means that Command Index error occurred in the Auto CMD response.
+#define SD4HC_SRS_SRS15__ACIE
+#define SD4HC_SRS_SRS15__ACIE_MASK 0x00000010U
+#define SD4HC_SRS_SRS15__ACIE_SHIFT 4U
+//! Slice: SRS15__ACRE:
+//! ACRE - Auto CMD Response Error\n When read as 1, means an error is detected in response to Auto Command.
+#define SD4HC_SRS_SRS15__ACRE
+#define SD4HC_SRS_SRS15__ACRE_MASK 0x00000020U
+#define SD4HC_SRS_SRS15__ACRE_SHIFT 5U
+//! Slice: SRS15__CNIACE:
+//! CNIACE - Command Not Issued By Auto CMD12 Error\n When read as 1, the command was not executed by the Host due to the previous Auto CMD12 error.\n When Host detects any error during Auto-CMD12, then all further command generation attempts are blocked. The software reset sequence is needed for recovery.\n Bit is set to 0, when Auto CMD23 Error is detected (any of bits SRS15[4:1] is set).
+#define SD4HC_SRS_SRS15__CNIACE
+#define SD4HC_SRS_SRS15__CNIACE_MASK 0x00000080U
+#define SD4HC_SRS_SRS15__CNIACE_SHIFT 7U
+//! Slice: SRS15__UMS:
+//! UMS - UHS Mode Select\n Used to select one of UHS-I modes.\n 000b - SDR12\n 001b - SDR25\n 010b - SDR50\n 011b - SDR104\n 100b - DDR50\n 101b - Reserved\n 110b - Reserved\n 111b - Reserved\n The selected UHS-I mode (when value is in range 000b-100b) will be ignored when V18SE is 0.
+#define SD4HC_SRS_SRS15__UMS
+#define SD4HC_SRS_SRS15__UMS_MASK 0x00070000U
+#define SD4HC_SRS_SRS15__UMS_SHIFT 16U
+//! Slice: SRS15__V18SE:
+//! V18SE - 1.8V Signaling Enable\n This bit controls I/O signaling voltage level.\n If the bit is 0 or 1, the I/O uses the 3.3V or 1.8V signaling, respectively.\n The SW driver will set this bit 1 when UHS-I mode.\n Depend on the selected SD interface mode, the software will set this field as follows:\n - 0 - for Default Speed, High Speed mode\n - 1 - for UHS-I mode
+#define SD4HC_SRS_SRS15__V18SE
+#define SD4HC_SRS_SRS15__V18SE_MASK 0x00080000U
+#define SD4HC_SRS_SRS15__V18SE_SHIFT 19U
+//! Slice: SRS15__DSS:
+//! DSS - Driver Strength Select\n This bit controls the electric parameters of I/O driver via \textit{sdphy_dfi_drvss} output of the SD/eMMC Host Controller core). Up to 4 configurations of I/O driver settings can be implemented: [list] [*] 00 - Driver Type B (default) [*] 01 - Driver Type A [*] 10 - Driver Type C [*] 11 - Driver Type D [/list] The bit is ignored when the V18SE is cleared.
+#define SD4HC_SRS_SRS15__DSS
+#define SD4HC_SRS_SRS15__DSS_MASK 0x00300000U
+#define SD4HC_SRS_SRS15__DSS_SHIFT 20U
+//! Slice: SRS15__EXTNG:
+//! EXTNG - Execute Tuning\n This register controls tuning procedure.\n The procedure starts when the bit is set 1.\n The procedure can be aborted when the bit is cleared.\n The bit is read 1 while the procedure is in progress, and 0 when the procedure is finished.\n SCS = 0, EXTNG = 0 - Reset and disable clock tuning logic\n SCS = 0, EXTNG = 1 - Reset and restart tuning process\n SCS = 1, EXTNG = 0 - Stop tuning procedure\n SCS = 1, EXTNG = 1 - Start retuning (without clock tuning logic reset)
+#define SD4HC_SRS_SRS15__EXTNG
+#define SD4HC_SRS_SRS15__EXTNG_MASK 0x00400000U
+#define SD4HC_SRS_SRS15__EXTNG_SHIFT 22U
+//! Slice: SRS15__SCS:
+//! SCS - Sampling Clock Select\n The host updates this bit when the tuning procedure is finished. If this bit is set to 1, this means that the tuning procedure is successfully completed.\n Otherwise it means that procedure failed and clock tuning logic is disabled.\n This bit is valid only after the procedure is finished.Writing 1 will be ignored.\n Writing 0 will reset and disable tuning block.
+#define SD4HC_SRS_SRS15__SCS
+#define SD4HC_SRS_SRS15__SCS_MASK 0x00800000U
+#define SD4HC_SRS_SRS15__SCS_SHIFT 23U
+//! Slice: SRS15__LVSIEXEC:
+//! LVSIEXEC - LVS Identification Execution\n Setting this field to 1, generates one pulse on SDCLK output.\n This bit does not change while DAT[2] stays LOW. After detecting DAT[2] is HIGH, this field automatically changes its value to 0 confirming end of the Low Voltage Sequence.
+#define SD4HC_SRS_SRS15__LVSIEXEC
+#define SD4HC_SRS_SRS15__LVSIEXEC_MASK 0x01000000U
+#define SD4HC_SRS_SRS15__LVSIEXEC_SHIFT 24U
+//! Slice: SRS15__ADMA2LM:
+//! ADMA2LM - ADMA2 Length Mode\n This bit selects one of ADMA2 Length Modes either 16-bit or 26-bit.\n 0 - 16-bit Data Length Mode\n 1 - 26-bit Data Length Mode
+#define SD4HC_SRS_SRS15__ADMA2LM
+#define SD4HC_SRS_SRS15__ADMA2LM_MASK 0x04000000U
+#define SD4HC_SRS_SRS15__ADMA2LM_SHIFT 26U
+//! Slice: SRS15__CMD23E:
+//! CMD23E - CMD23 Enable\n In result of Card Identification process, Host Driver set this bit to 1 if Card supports CMD23 (SCR[33]==1). \n
+#define SD4HC_SRS_SRS15__CMD23E
+#define SD4HC_SRS_SRS15__CMD23E_MASK 0x08000000U
+#define SD4HC_SRS_SRS15__CMD23E_SHIFT 27U
+//! Slice: SRS15__HV4E:
+//! HV4E - Host Version 4.00 Enable\n Selects backward (SD Host 3.00 Version) compatibility mode or SD Host 4.00 Version mode.\n 0 - Version 3.00\n 1 - Version 4.00\n The software can select system address register SRS00 (when this bit is 0) or SRS23 / SRS22 (when this bit is 1) for the SDMA engine.
+#define SD4HC_SRS_SRS15__HV4E
+#define SD4HC_SRS_SRS15__HV4E_MASK 0x10000000U
+#define SD4HC_SRS_SRS15__HV4E_SHIFT 28U
+//! Slice: SRS15__A64B:
+//! A64B - 64-bit Addressing\n Specifies the addressing mode for DMA ending. This field is ignored when SRS15.HV4E=0.\n 0 - 32-bit addressing\n 1 - 64-bit addressing
+#define SD4HC_SRS_SRS15__A64B
+#define SD4HC_SRS_SRS15__A64B_MASK 0x20000000U
+#define SD4HC_SRS_SRS15__A64B_SHIFT 29U
+//! Slice: SRS15__PVE:
+//! PVE - Preset Value Enable\n Setting this bit to 1 triggers an automatically update of SRS11.SDCFSL, SRS11.SDCFSH, SRS11.CGS, SRS15.DSS registers by the host. Values for an update are taken from SRS24 - SRS27 and depends on SRS15.UMS.
+#define SD4HC_SRS_SRS15__PVE
+#define SD4HC_SRS_SRS15__PVE_MASK 0x80000000U
+#define SD4HC_SRS_SRS15__PVE_SHIFT 31U
+
+//! Register: srs16: SRS16 (SD4HC_SRS_BASE + 0x00000040)
+//! Slice: SRS16__TCF:
+//! TCF - Timeout Clock Frequency\n Defines the base clock frequency used to detect Data Timeout Error. The SRS16.TCU bit determines the unit used.\n 111111b - 63kHz(SRS16.TCU=0) or 63MHz(SRS16.TCU=1)\n 111110b - 63kHz(SRS16.TCU=0) or 63MHz(SRS16.TCU=1)\n ...\n 000001b - 1kHz(SRS16.TCU=0) or 1MHz(SRS16.TCU=1)\n 000000b - Host System has to obtain the clock information via another method (i.e. not defined by the spec).
+#define SD4HC_SRS_SRS16__TCF
+#define SD4HC_SRS_SRS16__TCF_MASK 0x0000003FU
+#define SD4HC_SRS_SRS16__TCF_SHIFT 0U
+//! Slice: SRS16__TCU:
+//! TCU - Timeout Clock Unit\n Field defines the frequency unit for the SRS16.TCF.\n 0 - kHz\n 1 - MHz
+#define SD4HC_SRS_SRS16__TCU
+#define SD4HC_SRS_SRS16__TCU_MASK 0x00000080U
+#define SD4HC_SRS_SRS16__TCU_SHIFT 7U
+//! Slice: SRS16__BCSDCLK:
+//! BCSDCLK - Base Clock Frequency for SD Clock\n Field defines the base clock frequency for the SD Clock in 1MHz units. The base clock is the clock sourced to sdmclk pin of the host. The maximum clock frequency supported is between 10MHz to 255MHz.\n If BCSDCLK = 0, the Host System has to obtain the clock information via another method (i.e. not defined by the specification).
+#define SD4HC_SRS_SRS16__BCSDCLK
+#define SD4HC_SRS_SRS16__BCSDCLK_MASK 0x0000FF00U
+#define SD4HC_SRS_SRS16__BCSDCLK_SHIFT 8U
+//! Slice: SRS16__MBL:
+//! SRS16.MBL - Max Block Length\n This value indicates the maximum block size that can be transferred by the host. Three sizes can be defined as indicated below: [list] [*] 00b - 512 Bytes [*] 01b - 1024 Bytes [*] 10b - 2048 Bytes [*] 11b - Reserved [/list] The physical FIFO buffer size is defined by the separate FIFODEPTH generic parameter, and the physical buffer size is equal to 2^FIFODEPTH * 8 bytes. Therefore, the Maximum Block Size defined by MBL will always be less or equal to the physical buffer size.
+#define SD4HC_SRS_SRS16__MBL
+#define SD4HC_SRS_SRS16__MBL_MASK 0x00030000U
+#define SD4HC_SRS_SRS16__MBL_SHIFT 16U
+//! Slice: SRS16__EDS8:
+//! 8EDS - 8-bit Embedded Device Support\n 0 - not supported\n 1 - supported\n If this bit is 0, the SRS10.EDTW register is not implemented.
+#define SD4HC_SRS_SRS16__EDS8
+#define SD4HC_SRS_SRS16__EDS8_MASK 0x00040000U
+#define SD4HC_SRS_SRS16__EDS8_SHIFT 18U
+//! Slice: SRS16__ADMA2S:
+//! ADMA2S - ADMA2 Support\n 0 - not supported\n 1 - supported
+#define SD4HC_SRS_SRS16__ADMA2S
+#define SD4HC_SRS_SRS16__ADMA2S_MASK 0x00080000U
+#define SD4HC_SRS_SRS16__ADMA2S_SHIFT 19U
+//! Slice: SRS16__ADMA1S:
+//! ADMA1S - ADMA1 Support\n 0 - not supported\n 1 - supported
+#define SD4HC_SRS_SRS16__ADMA1S
+#define SD4HC_SRS_SRS16__ADMA1S_MASK 0x00100000U
+#define SD4HC_SRS_SRS16__ADMA1S_SHIFT 20U
+//! Slice: SRS16__HSS:
+//! HSS - High Speed Support\n 0 - not supported\n 1 - supported
+#define SD4HC_SRS_SRS16__HSS
+#define SD4HC_SRS_SRS16__HSS_MASK 0x00200000U
+#define SD4HC_SRS_SRS16__HSS_SHIFT 21U
+//! Slice: SRS16__DMAS:
+//! DMAS - SDMA Support\n 0 - not supported\n 1 - supported\n This bit defines whether the SDMA is supported.
+#define SD4HC_SRS_SRS16__DMAS
+#define SD4HC_SRS_SRS16__DMAS_MASK 0x00400000U
+#define SD4HC_SRS_SRS16__DMAS_SHIFT 22U
+//! Slice: SRS16__SRS:
+//! SRS - Suspend / Resume Support\n 0 - not supported\n 1 - supported\n The host controller does not support Suspend / Resume mechanism.
+#define SD4HC_SRS_SRS16__SRS
+#define SD4HC_SRS_SRS16__SRS_MASK 0x00800000U
+#define SD4HC_SRS_SRS16__SRS_SHIFT 23U
+//! Slice: SRS16__VS33:
+//! VS33 - Voltage Support 3.3V\n 0 - not supported\n 1 - supported
+#define SD4HC_SRS_SRS16__VS33
+#define SD4HC_SRS_SRS16__VS33_MASK 0x01000000U
+#define SD4HC_SRS_SRS16__VS33_SHIFT 24U
+//! Slice: SRS16__VS30:
+//! VS30 - Voltage Support 3.0V\n 0 - not supported\n 1 - supported
+#define SD4HC_SRS_SRS16__VS30
+#define SD4HC_SRS_SRS16__VS30_MASK 0x02000000U
+#define SD4HC_SRS_SRS16__VS30_SHIFT 25U
+//! Slice: SRS16__VS18:
+//! VS18 - Voltage Support 1.8V\n 0 - not supported\n 1 - supported
+#define SD4HC_SRS_SRS16__VS18
+#define SD4HC_SRS_SRS16__VS18_MASK 0x04000000U
+#define SD4HC_SRS_SRS16__VS18_SHIFT 26U
+//! Slice: SRS16__A64SV4:
+//! A64SV4 - 64-bit System Addressing Support for V4\n 0 - 64-bit Addressing for V4 is not supported\n 1 - 64-bit Addressing for V4 is supported
+#define SD4HC_SRS_SRS16__A64SV4
+#define SD4HC_SRS_SRS16__A64SV4_MASK 0x08000000U
+#define SD4HC_SRS_SRS16__A64SV4_SHIFT 27U
+//! Slice: SRS16__A64SV3:
+//! A64SV3 - 64-bit System Addressing Support\n 0 - 64-bit Addressing for V3 is not supported\n 1 - 64-bit Addressing for V3 is supported
+#define SD4HC_SRS_SRS16__A64SV3
+#define SD4HC_SRS_SRS16__A64SV3_MASK 0x10000000U
+#define SD4HC_SRS_SRS16__A64SV3_SHIFT 28U
+//! Slice: SRS16__AIS:
+//! AIS - Asynchronous Interrupt Support\n 0 - not supported\n
+#define SD4HC_SRS_SRS16__AIS
+#define SD4HC_SRS_SRS16__AIS_MASK 0x20000000U
+#define SD4HC_SRS_SRS16__AIS_SHIFT 29U
+//! Slice: SRS16__SLT:
+//! SLT - Slot Type\n These bits inform what type of slot is provided.\n [list] [*] 00 - Removable Card Slot [*] 01 - Embedded Slot for One Device [*] 10 - Shared Bus Slot [*] 11 - Reserved [/list]
+#define SD4HC_SRS_SRS16__SLT
+#define SD4HC_SRS_SRS16__SLT_MASK 0xC0000000U
+#define SD4HC_SRS_SRS16__SLT_SHIFT 30U
+
+//! Register: srs17: SRS17 (SD4HC_SRS_BASE + 0x00000044)
+//! Slice: SRS17__SDR50:
+//! SDR50 - SDR50 Supported\n [list] [*] 1 - SDR50 mode supported [*] 0 - SDR50 mode not supported [/list]
+#define SD4HC_SRS_SRS17__SDR50
+#define SD4HC_SRS_SRS17__SDR50_MASK 0x00000001U
+#define SD4HC_SRS_SRS17__SDR50_SHIFT 0U
+//! Slice: SRS17__SDR104:
+//! SDR104 - SDR104 Supported\n [list] [*] 1 - SDR104 mode supported [*] 0 - SDR104 mode not supported [/list]
+#define SD4HC_SRS_SRS17__SDR104
+#define SD4HC_SRS_SRS17__SDR104_MASK 0x00000002U
+#define SD4HC_SRS_SRS17__SDR104_SHIFT 1U
+//! Slice: SRS17__DDR50:
+//! DDR50 - DDR50 Supported\n [list] [*] 1 - DDR50 mode supported [*] 0 - DDR50 mode not supported [/list]
+#define SD4HC_SRS_SRS17__DDR50
+#define SD4HC_SRS_SRS17__DDR50_MASK 0x00000004U
+#define SD4HC_SRS_SRS17__DDR50_SHIFT 2U
+//! Slice: SRS17__UHSII:
+//! UHSII - UHS-II / UHS-III Supported\n 0 - UHS-II not supported
+#define SD4HC_SRS_SRS17__UHSII
+#define SD4HC_SRS_SRS17__UHSII_MASK 0x00000008U
+#define SD4HC_SRS_SRS17__UHSII_SHIFT 3U
+//! Slice: SRS17__DRVA:
+//! DRVA - 1.8V Line Driver Type A Supported\n [list] [*] 1 - Driver Type A supported [*] 0 - Driver Type A not supported [/list]
+#define SD4HC_SRS_SRS17__DRVA
+#define SD4HC_SRS_SRS17__DRVA_MASK 0x00000010U
+#define SD4HC_SRS_SRS17__DRVA_SHIFT 4U
+//! Slice: SRS17__DRVC:
+//! DRVC - 1.8V Line Driver Type C Supported\n [list] [*] 1 - Driver Type C supported [*] 0 - Driver Type C not supported [/list]
+#define SD4HC_SRS_SRS17__DRVC
+#define SD4HC_SRS_SRS17__DRVC_MASK 0x00000020U
+#define SD4HC_SRS_SRS17__DRVC_SHIFT 5U
+//! Slice: SRS17__DRVD:
+//! DRVD - 1.8V Line Driver Type D Supported\n [list] [*] 1 - Driver Type D supported [*] 0 - Driver Type D not supported [/list]
+#define SD4HC_SRS_SRS17__DRVD
+#define SD4HC_SRS_SRS17__DRVD_MASK 0x00000040U
+#define SD4HC_SRS_SRS17__DRVD_SHIFT 6U
+//! Slice: SRS17__RTNGCNT:
+//! RTNGCNT - Timer Count for Re-Tuning\n These bits contain initial value for timer used to starting periodically Re-Tuning Operation.\n [list] [*] 0h - Re-Tuning Timer disabled [*] 1h - 1 second [*] ... [*] n - 2^(n-1) seconds [*] ... [*] Bh - 1024 seconds [*] Eh-Ch - Reserved [*] Fh - Obtain this info in other way [/list]
+#define SD4HC_SRS_SRS17__RTNGCNT
+#define SD4HC_SRS_SRS17__RTNGCNT_MASK 0x00000F00U
+#define SD4HC_SRS_SRS17__RTNGCNT_SHIFT 8U
+//! Slice: SRS17__UTSM50:
+//! UTSM50 - Use Tuning for SDR50\n [list] [*] 1 - tuning operation is necessary in SDR50 mode [*] 0 - tuning operation is not necessary in SDR50 mode [/list]
+#define SD4HC_SRS_SRS17__UTSM50
+#define SD4HC_SRS_SRS17__UTSM50_MASK 0x00002000U
+#define SD4HC_SRS_SRS17__UTSM50_SHIFT 13U
+//! Slice: SRS17__RTNGM:
+//! RTNGM - Re-Tuning Modes\n Depending on the retuning method, the some restrictions are assumed for the data length between re-tunings.\n The core can work with supporting one of the three method:\n [list] [*] 0 - Mode1: The software driver will use timer to calculate when the re-tuning is to be rerun. The data length between operations is limited to the 4MB. [*] 1 - Mode2: The driver will use either the re-tuning request (external input pin uhsi_retune_req is used for this purpose) or timer to predict when next retuning should be performed. The data length between operations is limited to the 4MB. [*] 2 - Mode3: This mode is similar to the mode2 with one exception. The core is able to perform auto retuning during the transmission, so data length limitation is not exists. [/list] Mode 3 is currently not supported.The driver can configure the timer by getting the RTNGCNT.This field is to be 0 or 1, because the mode 3 is not supported.
+#define SD4HC_SRS_SRS17__RTNGM
+#define SD4HC_SRS_SRS17__RTNGM_MASK 0x0000C000U
+#define SD4HC_SRS_SRS17__RTNGM_SHIFT 14U
+//! Slice: SRS17__CLKMPR:
+//! CLKMPR - Clock Multiplier\n This field is to be 0 (fixed), as the Clock Multiplier is not supported.
+#define SD4HC_SRS_SRS17__CLKMPR
+#define SD4HC_SRS_SRS17__CLKMPR_MASK 0x00FF0000U
+#define SD4HC_SRS_SRS17__CLKMPR_SHIFT 16U
+//! Slice: SRS17__ADMA3SUP:
+//! ADMA3SUP - ADMA3 Supported.\n [list] [*] 1 - ADMA3 supported [*] 0 - ADMA3 not supported [/list]
+#define SD4HC_SRS_SRS17__ADMA3SUP
+#define SD4HC_SRS_SRS17__ADMA3SUP_MASK 0x08000000U
+#define SD4HC_SRS_SRS17__ADMA3SUP_SHIFT 27U
+//! Slice: SRS17__VDD2S:
+//! VDD2S - VDD2 Supported\n [list] [*] 1 - VDD2 supported [*] 0 - VDD2 not supported [/list]
+#define SD4HC_SRS_SRS17__VDD2S
+#define SD4HC_SRS_SRS17__VDD2S_MASK 0x10000000U
+#define SD4HC_SRS_SRS17__VDD2S_SHIFT 28U
+//! Slice: SRS17__LVSH:
+//! LVSH - Low Voltage Signaling Host\n [list] [*] 1 - LVS Host [*] 0 - Not LVS Host [/list]
+#define SD4HC_SRS_SRS17__LVSH
+#define SD4HC_SRS_SRS17__LVSH_MASK 0x80000000U
+#define SD4HC_SRS_SRS17__LVSH_SHIFT 31U
+
+//! Register: srs18: SRS18 (SD4HC_SRS_BASE + 0x00000048)
+//! Slice: SRS18__MC33:
+//! MC33 - Maximum Current for 3.3V\n [list] [*] 0 - Host System has to obtain the current value via another method [*] 1 - 4 mA [*] 2 - 8 mA [*] 3 - 12 mA [*] ... [*] 255 - 1020 mA [/list]
+#define SD4HC_SRS_SRS18__MC33
+#define SD4HC_SRS_SRS18__MC33_MASK 0x000000FFU
+#define SD4HC_SRS_SRS18__MC33_SHIFT 0U
+//! Slice: SRS18__MC30:
+//! MC30 - Maximum Current for 3.0V\n [list] [*] 0 - Host System has to obtain the current value via another method [*] 1 - 4 mA [*] 2 - 8 mA [*] 3 - 12 mA [*] ... [*] 255 - 1020 mA [/list]
+#define SD4HC_SRS_SRS18__MC30
+#define SD4HC_SRS_SRS18__MC30_MASK 0x0000FF00U
+#define SD4HC_SRS_SRS18__MC30_SHIFT 8U
+//! Slice: SRS18__MC18:
+//! MC18 - Maximum Current for 1.8V\n [list] [*] 0 - Host System has to obtain the current value via another method [*] 1 - 4 mA [*] 2 - 8 mA [*] 3 - 12 mA [*] ... [*] 255 - 1020 mA [/list]
+#define SD4HC_SRS_SRS18__MC18
+#define SD4HC_SRS_SRS18__MC18_MASK 0x00FF0000U
+#define SD4HC_SRS_SRS18__MC18_SHIFT 16U
+
+//! Register: srs19: SRS19 (SD4HC_SRS_BASE + 0x0000004c)
+//! Slice: SRS19__MC18V2:
+//! MC18V2 - Maximum Current for 1.8V VDD2\n [list] [*] 0 - Host System has to obtain the current value via another method [*] 1 - 4 mA [*] 2 - 8 mA [*] 3 - 12 mA [*] ... [*] 255 - 1020 mA [/list]
+#define SD4HC_SRS_SRS19__MC18V2
+#define SD4HC_SRS_SRS19__MC18V2_MASK 0x000000FFU
+#define SD4HC_SRS_SRS19__MC18V2_SHIFT 0U
+
+//! Register: srs20: SRS20 (SD4HC_SRS_BASE + 0x00000050)
+//! Slice: SRS20__ACNE_FE:
+//! ACNE_FE - Force Auto CMD12 Not Executed Event
+#define SD4HC_SRS_SRS20__ACNE_FE
+#define SD4HC_SRS_SRS20__ACNE_FE_MASK 0x00000001U
+#define SD4HC_SRS_SRS20__ACNE_FE_SHIFT 0U
+//! Slice: SRS20__ACTE_FE:
+//! ACTE_FE - Force Auto CMD Timeout Error Event
+#define SD4HC_SRS_SRS20__ACTE_FE
+#define SD4HC_SRS_SRS20__ACTE_FE_MASK 0x00000002U
+#define SD4HC_SRS_SRS20__ACTE_FE_SHIFT 1U
+//! Slice: SRS20__ACCE_FE:
+//! ACCE_FE - Force Auto CMD CRC Error Event
+#define SD4HC_SRS_SRS20__ACCE_FE
+#define SD4HC_SRS_SRS20__ACCE_FE_MASK 0x00000004U
+#define SD4HC_SRS_SRS20__ACCE_FE_SHIFT 2U
+//! Slice: SRS20__ACEBE_FE:
+//! ACEBE_FE - Force Auto CMD End Bit Error Event
+#define SD4HC_SRS_SRS20__ACEBE_FE
+#define SD4HC_SRS_SRS20__ACEBE_FE_MASK 0x00000008U
+#define SD4HC_SRS_SRS20__ACEBE_FE_SHIFT 3U
+//! Slice: SRS20__ACIE_FE:
+//! ACIE_FE - Force Auto CMD Index Error Event
+#define SD4HC_SRS_SRS20__ACIE_FE
+#define SD4HC_SRS_SRS20__ACIE_FE_MASK 0x00000010U
+#define SD4HC_SRS_SRS20__ACIE_FE_SHIFT 4U
+//! Slice: SRS20__CNIACE_FE:
+//! CNIACE_FE - Force Command Not Issued By Auto CMD12 Error Event
+#define SD4HC_SRS_SRS20__CNIACE_FE
+#define SD4HC_SRS_SRS20__CNIACE_FE_MASK 0x00000080U
+#define SD4HC_SRS_SRS20__CNIACE_FE_SHIFT 7U
+//! Slice: SRS20__ECT_FE:
+//! ECT_FE - Force Command Timeout Error Event
+#define SD4HC_SRS_SRS20__ECT_FE
+#define SD4HC_SRS_SRS20__ECT_FE_MASK 0x00010000U
+#define SD4HC_SRS_SRS20__ECT_FE_SHIFT 16U
+//! Slice: SRS20__ECCRC_FE:
+//! ECCRC_FE - Force Command CRC Error Event
+#define SD4HC_SRS_SRS20__ECCRC_FE
+#define SD4HC_SRS_SRS20__ECCRC_FE_MASK 0x00020000U
+#define SD4HC_SRS_SRS20__ECCRC_FE_SHIFT 17U
+//! Slice: SRS20__ECEB_FE:
+//! ECEB_FE - Force Command End Bit Error Event
+#define SD4HC_SRS_SRS20__ECEB_FE
+#define SD4HC_SRS_SRS20__ECEB_FE_MASK 0x00040000U
+#define SD4HC_SRS_SRS20__ECEB_FE_SHIFT 18U
+//! Slice: SRS20__ECI_FE:
+//! ECI_FE - Force Command Index Error Event
+#define SD4HC_SRS_SRS20__ECI_FE
+#define SD4HC_SRS_SRS20__ECI_FE_MASK 0x00080000U
+#define SD4HC_SRS_SRS20__ECI_FE_SHIFT 19U
+//! Slice: SRS20__EDT_FE:
+//! EDT_FE - Force Data Timeout Error Event
+#define SD4HC_SRS_SRS20__EDT_FE
+#define SD4HC_SRS_SRS20__EDT_FE_MASK 0x00100000U
+#define SD4HC_SRS_SRS20__EDT_FE_SHIFT 20U
+//! Slice: SRS20__EDCRC_FE:
+//! EDCRC_FE - Force Data CRC Error Event
+#define SD4HC_SRS_SRS20__EDCRC_FE
+#define SD4HC_SRS_SRS20__EDCRC_FE_MASK 0x00200000U
+#define SD4HC_SRS_SRS20__EDCRC_FE_SHIFT 21U
+//! Slice: SRS20__EDEB_FE:
+//! EDEB_FE - Force Data End Bit Error Event
+#define SD4HC_SRS_SRS20__EDEB_FE
+#define SD4HC_SRS_SRS20__EDEB_FE_MASK 0x00400000U
+#define SD4HC_SRS_SRS20__EDEB_FE_SHIFT 22U
+//! Slice: SRS20__ECL_FE:
+//! ECL_FE - Force Current Limit Error Event
+#define SD4HC_SRS_SRS20__ECL_FE
+#define SD4HC_SRS_SRS20__ECL_FE_MASK 0x00800000U
+#define SD4HC_SRS_SRS20__ECL_FE_SHIFT 23U
+//! Slice: SRS20__EAC_FE:
+//! EAC_FE - Force Auto CMD Error Event
+#define SD4HC_SRS_SRS20__EAC_FE
+#define SD4HC_SRS_SRS20__EAC_FE_MASK 0x01000000U
+#define SD4HC_SRS_SRS20__EAC_FE_SHIFT 24U
+//! Slice: SRS20__EADMA_FE:
+//! EADMA_FE - Force ADMA Error Event
+#define SD4HC_SRS_SRS20__EADMA_FE
+#define SD4HC_SRS_SRS20__EADMA_FE_MASK 0x02000000U
+#define SD4HC_SRS_SRS20__EADMA_FE_SHIFT 25U
+//! Slice: SRS20__ETUNE_FE:
+//! ETUNE_FE - Force Tuning Error Event
+#define SD4HC_SRS_SRS20__ETUNE_FE
+#define SD4HC_SRS_SRS20__ETUNE_FE_MASK 0x04000000U
+#define SD4HC_SRS_SRS20__ETUNE_FE_SHIFT 26U
+//! Slice: SRS20__ERESP_FE:
+//! ERESP_FE - Force Response Error Event
+#define SD4HC_SRS_SRS20__ERESP_FE
+#define SD4HC_SRS_SRS20__ERESP_FE_MASK 0x08000000U
+#define SD4HC_SRS_SRS20__ERESP_FE_SHIFT 27U
+
+//! Register: srs21: SRS21 (SD4HC_SRS_BASE + 0x00000054)
+//! Slice: SRS21__EADMAS:
+//! EADMAS - ADMA Error State\n The value of this field reflects the state of the ADMA state machine. The possible values are:\n 00b - ST_STOP (ADMA Stopped)\n 01b - ST_FDS (Fetching descriptor)\n 10b - not used\n 11b - ST_TRF (Transfer data)
+#define SD4HC_SRS_SRS21__EADMAS
+#define SD4HC_SRS_SRS21__EADMAS_MASK 0x00000003U
+#define SD4HC_SRS_SRS21__EADMAS_SHIFT 0U
+//! Slice: SRS21__EADMAL:
+//! EADMAL - ADMA Length Mismatch Error\n This bit is set when:\n - total data length specified in ADMA descriptors is different from that specified by the Block Count and Block Length fields (if Block Count Enable is set).\n - total data length cannot be divided into complete blocks of specified length (if Block Count Enable is not set).
+#define SD4HC_SRS_SRS21__EADMAL
+#define SD4HC_SRS_SRS21__EADMAL_MASK 0x00000004U
+#define SD4HC_SRS_SRS21__EADMAL_SHIFT 2U
+
+//! Register: srs22: SRS22 (SD4HC_SRS_BASE + 0x00000058)
+//! Slice: SRS22__DMASA1:
+//! DMASA1 - ADMA System Address\n This field contains the physical address of the currently processed ADMA descriptor or SDMA system address. The Host Driver will set this register with the descriptors table base address before it starts the ADMA transfers. The Host Driver should not write this register while the data transfer is active.\n While the ADMA engine is processing the descriptors list, the ADMASA value is always incremented to point the next descriptor to be fetched.\n If the ADMA Error occurs, the register holds the descriptor address depending on the ADMA Error State (SRS21.EADMAS) register value, as listed in the table below:\n 00b - Points next of the error descriptor\n 01b - Points the error descriptor\n 10b - not used\n 11b - Points next of the error descriptor\n The host ADMA engine ignores 2 or 3 least significant bits in this register when the 32-bit or 64-bit addressing is active, respectively.\n If SRS15.HV4E is set 1 and SDMA engine is selected, this field is used instead of SRS00 to define system memory address. This register incremented and points to the next memory location that will be accessed.
+#define SD4HC_SRS_SRS22__DMASA1
+#define SD4HC_SRS_SRS22__DMASA1_MASK 0xFFFFFFFFU
+#define SD4HC_SRS_SRS22__DMASA1_SHIFT 0U
+
+//! Register: srs23: SRS23 (SD4HC_SRS_BASE + 0x0000005c)
+//! Slice: SRS23__DMASA2:
+//! DMASA2 - ADMA System Address #2\n In ADMA mode, if 64-bit addressing is enabled (SRS15.A64B=1), this field holds bits 63-32 of the physical address pointing on ADMA descriptor table.\n In SDMA mode, if host compatibility with version 4.x and 64-bit addressing are enabled (SRS15.HV4E=1 and SRS15.A64B=1), this field holds bits 63-32 of system address.
+#define SD4HC_SRS_SRS23__DMASA2
+#define SD4HC_SRS_SRS23__DMASA2_MASK 0xFFFFFFFFU
+#define SD4HC_SRS_SRS23__DMASA2_SHIFT 0U
+
+//! Register: srs24: SRS24 (SD4HC_SRS_BASE + 0x00000060)
+//! Slice: SRS24__SRS24_SDCFSPV_25_16:
+//! SDCFSPV## - SDCLK Clock Frequency Select - Preset Value\n This field can be used by the software to update SRS11.SDCFSH and SRS11.SDCFSL.
+#define SD4HC_SRS_SRS24__SRS24_SDCFSPV_25_16
+#define SD4HC_SRS_SRS24__SRS24_SDCFSPV_25_16_MASK 0x03FF0000U
+#define SD4HC_SRS_SRS24__SRS24_SDCFSPV_25_16_SHIFT 16U
+//! Slice: SRS24__SRS24_DSSPV_31_30:
+//! DSSPV## - Driver Strength Select - Preset Value\n This field can be used by the software to update SRS15.DSS.
+#define SD4HC_SRS_SRS24__SRS24_DSSPV_31_30
+#define SD4HC_SRS_SRS24__SRS24_DSSPV_31_30_MASK 0xC0000000U
+#define SD4HC_SRS_SRS24__SRS24_DSSPV_31_30_SHIFT 30U
+
+//! Register: srs25: SRS25 (SD4HC_SRS_BASE + 0x00000064)
+//! Slice: SRS25__SRS25_SDCFSPV_09_00:
+//! SDCFSPV## - SDCLK Clock Frequency Select - Preset Value\n This field can be used by the software to update SRS11.SDCFSH and SRS11.SDCFSL.
+#define SD4HC_SRS_SRS25__SRS25_SDCFSPV_09_00
+#define SD4HC_SRS_SRS25__SRS25_SDCFSPV_09_00_MASK 0x000003FFU
+#define SD4HC_SRS_SRS25__SRS25_SDCFSPV_09_00_SHIFT 0U
+//! Slice: SRS25__SRS25_DSSPV_15_14:
+//! DSSPV## - Driver Strength Select - Preset Value\n This field can be used by the software to update SRS15.DSS.
+#define SD4HC_SRS_SRS25__SRS25_DSSPV_15_14
+#define SD4HC_SRS_SRS25__SRS25_DSSPV_15_14_MASK 0x0000C000U
+#define SD4HC_SRS_SRS25__SRS25_DSSPV_15_14_SHIFT 14U
+//! Slice: SRS25__SRS25_SDCFSPV_25_16:
+//! SDCFSPV## - SDCLK Clock Frequency Select - Preset Value\n This field can be used by the software to update SRS11.SDCFSH and SRS11.SDCFSL.
+#define SD4HC_SRS_SRS25__SRS25_SDCFSPV_25_16
+#define SD4HC_SRS_SRS25__SRS25_SDCFSPV_25_16_MASK 0x03FF0000U
+#define SD4HC_SRS_SRS25__SRS25_SDCFSPV_25_16_SHIFT 16U
+//! Slice: SRS25__SRS25_DSSPV_31_30:
+//! DSSPV## - Driver Strength Select - Preset Value\n This field can be used by the software to update SRS15.DSS.
+#define SD4HC_SRS_SRS25__SRS25_DSSPV_31_30
+#define SD4HC_SRS_SRS25__SRS25_DSSPV_31_30_MASK 0xC0000000U
+#define SD4HC_SRS_SRS25__SRS25_DSSPV_31_30_SHIFT 30U
+
+//! Register: srs26: SRS26 (SD4HC_SRS_BASE + 0x00000068)
+//! Slice: SRS26__SRS26_SDCFSPV_09_00:
+//! SDCFSPV## - SDCLK Clock Frequency Select - Preset Value\n This field can be used by the software to update SRS11.SDCFSH and SRS11.SDCFSL.
+#define SD4HC_SRS_SRS26__SRS26_SDCFSPV_09_00
+#define SD4HC_SRS_SRS26__SRS26_SDCFSPV_09_00_MASK 0x000003FFU
+#define SD4HC_SRS_SRS26__SRS26_SDCFSPV_09_00_SHIFT 0U
+//! Slice: SRS26__SRS26_CGSPV_10:
+//! CGSPV## - Clock Generator Select - Preset Value\n This field can be used by the software to update SRS11.CGS.
+#define SD4HC_SRS_SRS26__SRS26_CGSPV_10
+#define SD4HC_SRS_SRS26__SRS26_CGSPV_10_MASK 0x00000400U
+#define SD4HC_SRS_SRS26__SRS26_CGSPV_10_SHIFT 10U
+//! Slice: SRS26__SRS26_DSSPV_15_14:
+//! DSSPV## - Driver Strength Select - Preset Value\n This field can be used by the software to update SRS15.DSS.
+#define SD4HC_SRS_SRS26__SRS26_DSSPV_15_14
+#define SD4HC_SRS_SRS26__SRS26_DSSPV_15_14_MASK 0x0000C000U
+#define SD4HC_SRS_SRS26__SRS26_DSSPV_15_14_SHIFT 14U
+//! Slice: SRS26__SRS26_SDCFSPV_25_16:
+//! SDCFSPV## - SDCLK Clock Frequency Select - Preset Value\n This field can be used by the software to update SRS11.SDCFSH and SRS11.SDCFSL.
+#define SD4HC_SRS_SRS26__SRS26_SDCFSPV_25_16
+#define SD4HC_SRS_SRS26__SRS26_SDCFSPV_25_16_MASK 0x03FF0000U
+#define SD4HC_SRS_SRS26__SRS26_SDCFSPV_25_16_SHIFT 16U
+//! Slice: SRS26__SRS26_DSSPV_31_30:
+//! DSSPV## - Driver Strength Select - Preset Value\n This field can be used by the software to update SRS15.DSS.
+#define SD4HC_SRS_SRS26__SRS26_DSSPV_31_30
+#define SD4HC_SRS_SRS26__SRS26_DSSPV_31_30_MASK 0xC0000000U
+#define SD4HC_SRS_SRS26__SRS26_DSSPV_31_30_SHIFT 30U
+
+//! Register: srs27: SRS27 (SD4HC_SRS_BASE + 0x0000006c)
+//! Slice: SRS27__SRS27_SDCFSPV_09_00:
+//! SDCFSPV## - SDCLK Clock Frequency Select - Preset Value\n This field can be used by the software to update SRS11.SDCFSH and SRS11.SDCFSL.
+#define SD4HC_SRS_SRS27__SRS27_SDCFSPV_09_00
+#define SD4HC_SRS_SRS27__SRS27_SDCFSPV_09_00_MASK 0x000003FFU
+#define SD4HC_SRS_SRS27__SRS27_SDCFSPV_09_00_SHIFT 0U
+//! Slice: SRS27__SRS27_DSSPV_15_14:
+//! DSSPV## - Driver Strength Select - Preset Value\n This field can be used by the software to update SRS15.DSS.
+#define SD4HC_SRS_SRS27__SRS27_DSSPV_15_14
+#define SD4HC_SRS_SRS27__SRS27_DSSPV_15_14_MASK 0x0000C000U
+#define SD4HC_SRS_SRS27__SRS27_DSSPV_15_14_SHIFT 14U
+//! Slice: SRS27__SRS27_SDCFSPV_25_16:
+//! SDCFSPV## - SDCLK Clock Frequency Select - Preset Value\n This field can be used by the software to update SRS11.SDCFSH and SRS11.SDCFSL.
+#define SD4HC_SRS_SRS27__SRS27_SDCFSPV_25_16
+#define SD4HC_SRS_SRS27__SRS27_SDCFSPV_25_16_MASK 0x03FF0000U
+#define SD4HC_SRS_SRS27__SRS27_SDCFSPV_25_16_SHIFT 16U
+//! Slice: SRS27__SRS27_DSSPV_31_30:
+//! DSSPV## - Driver Strength Select - Preset Value\n This field can be used by the software to update SRS15.DSS.
+#define SD4HC_SRS_SRS27__SRS27_DSSPV_31_30
+#define SD4HC_SRS_SRS27__SRS27_DSSPV_31_30_MASK 0xC0000000U
+#define SD4HC_SRS_SRS27__SRS27_DSSPV_31_30_SHIFT 30U
+
+//! Register: srs30: SRS30 (SD4HC_SRS_BASE + 0x00000078)
+//! Slice: SRS30__ADMA3ID1:
+//! ADMA3 Integrated Descriptor Address #1\n This field contains the physical address of the currently processed ADMA3 Integrated Descriptor address. The Host Driver will set this register with the ID table base address before it starts the ADMA3 transfers. The Host Driver should not write this register while the data transfer is active. While the ADMA3 engine is processing the descriptors list, the ADMA3ID value is always incremented to point the next ID to be fetched. The host ADMA3 engine ignores 2 or 3 least significant bits in this register when the 32-bit or 64-bit addressing is active, respectively.\n \n When ADMA3 uses 32-bit addressing mode, write to this register starts ADMA3.
+#define SD4HC_SRS_SRS30__ADMA3ID1
+#define SD4HC_SRS_SRS30__ADMA3ID1_MASK 0xFFFFFFFFU
+#define SD4HC_SRS_SRS30__ADMA3ID1_SHIFT 0U
+
+//! Register: srs31: SRS31 (SD4HC_SRS_BASE + 0x0000007c)
+//! Slice: SRS31__ADMA3ID2:
+//! ADMA3 Integrated Descriptor Address #2\n If 64-bit addressing is enabled (SRS15.A64B=1), this field holds bits 63-32 of the physical address pointing on ADMA3 Integrated Descriptor table.\n \n When ADMA3 uses 64-bit addressing mode, write to this register starts ADMA3.
+#define SD4HC_SRS_SRS31__ADMA3ID2
+#define SD4HC_SRS_SRS31__ADMA3ID2_MASK 0xFFFFFFFFU
+#define SD4HC_SRS_SRS31__ADMA3ID2_SHIFT 0U
+
+#endif /* __SD4HC_SRS_REGS_H__ */
+/*************************** EOF **************************************/
diff --git a/include/dct/sd4phy_ctb_regs.h b/include/dct/sd4phy_ctb_regs.h
new file mode 100644
index 0000000000..ce13c65fd0
--- /dev/null
+++ b/include/dct/sd4phy_ctb_regs.h
@@ -0,0 +1,100 @@
+ /*
+ * (C) Copyright 2023,
+ * Dream Chip Technologies
+ * Axel Ludszuweit, <Axel.ludszuweit@dreamchip.de>
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#ifndef __SD4PHY_CTB_REGS_H__
+#define __SD4PHY_CTB_REGS_H__
+
+#include <stdint.h>
+
+//! Sd4phyCtb Register layout
+typedef struct
+{
+  //! Register Group: sd4phy_ctb
+  uint32_t _notused_0 [2080]; // gap in address space
+  uint32_t phy_ctrl_reg; //!< phy_ctrl_reg (slice) SD4PHY_CTB_BASE + 0x00000000
+  uint32_t phy_tsel_reg; //!< phy_tsel_reg (slice) SD4PHY_CTB_BASE + 0x00000004
+  uint32_t phy_gpio_ctrl_0; //!< phy_gpio_ctrl_0 (slice) SD4PHY_CTB_BASE + 0x00000008
+  uint32_t phy_gpio_ctrl_1; //!< phy_gpio_ctrl_1 (slice) SD4PHY_CTB_BASE + 0x0000000c
+  uint32_t phy_gpio_status_0; //!< phy_gpio_status_0 (slice) SD4PHY_CTB_BASE + 0x00000010
+  uint32_t phy_gpio_status_1; //!< phy_gpio_status_1 (slice) SD4PHY_CTB_BASE + 0x00000014
+} Sd4phyCtbRegister_t;
+
+
+// - MASK AND SHIFT MACROS ----------------------------------------------------------
+
+//! Register Group: sd4phy_ctb
+
+//! Register: phy_ctrl_reg: phy_ctrl_reg (SD4PHY_CTB_BASE + 0x00000000)
+//! Slice: phy_ctrl_reg__ctrl_clkperiod_delay:
+//! Defines additional latency on the control signals WE/RE/CE/WP.
+#define SD4PHY_CTB_PHY_CTRL_REG__CTRL_CLKPERIOD_DELAY
+#define SD4PHY_CTB_PHY_CTRL_REG__CTRL_CLKPERIOD_DELAY_MASK 0x00000001U
+#define SD4PHY_CTB_PHY_CTRL_REG__CTRL_CLKPERIOD_DELAY_SHIFT 0U
+//! Slice: phy_ctrl_reg__phony_dqs_timing:
+//! The timing of assertion of phony DQS to the data slices. If the extended_read_mode is disabled the value should be zero. If the extended_read_mode is enabled the value should match the width of the rebar pulse in terms of clock PHY clock cycles reduced by 1. e.g. if rebar pulse width is 4 clock cycles the value of this field should be 3.
+#define SD4PHY_CTB_PHY_CTRL_REG__PHONY_DQS_TIMING
+#define SD4PHY_CTB_PHY_CTRL_REG__PHONY_DQS_TIMING_MASK 0x000001F0U
+#define SD4PHY_CTB_PHY_CTRL_REG__PHONY_DQS_TIMING_SHIFT 4U
+//! Slice: phy_ctrl_reg__pu_pd_polarity:
+//! Defines the polarity of the ALE port that in SD works as pull-up/pull-down signal for bit 2 of the DATA. [list] [*]0 - ALE port is a copy of dfi_ale.[*]1 - ALE port is inverted version of dfi_ale.[/list]
+#define SD4PHY_CTB_PHY_CTRL_REG__PU_PD_POLARITY
+#define SD4PHY_CTB_PHY_CTRL_REG__PU_PD_POLARITY_MASK 0x00200000U
+#define SD4PHY_CTB_PHY_CTRL_REG__PU_PD_POLARITY_SHIFT 21U
+
+//! Register: phy_tsel_reg: phy_tsel_reg (SD4PHY_CTB_BASE + 0x00000004)
+//! Slice: phy_tsel_reg__tsel_rd_value_dqs:
+//! Termination select read value for the data strobe.
+#define SD4PHY_CTB_PHY_TSEL_REG__TSEL_RD_VALUE_DQS
+#define SD4PHY_CTB_PHY_TSEL_REG__TSEL_RD_VALUE_DQS_MASK 0x00000F00U
+#define SD4PHY_CTB_PHY_TSEL_REG__TSEL_RD_VALUE_DQS_SHIFT 8U
+//! Slice: phy_tsel_reg__tsel_off_value_dqs:
+//! Termination select off value for the data strobe.
+#define SD4PHY_CTB_PHY_TSEL_REG__TSEL_OFF_VALUE_DQS
+#define SD4PHY_CTB_PHY_TSEL_REG__TSEL_OFF_VALUE_DQS_MASK 0x0000F000U
+#define SD4PHY_CTB_PHY_TSEL_REG__TSEL_OFF_VALUE_DQS_SHIFT 12U
+//! Slice: phy_tsel_reg__tsel_rd_value_data:
+//! Termination select read value for the data.
+#define SD4PHY_CTB_PHY_TSEL_REG__TSEL_RD_VALUE_DATA
+#define SD4PHY_CTB_PHY_TSEL_REG__TSEL_RD_VALUE_DATA_MASK 0x000F0000U
+#define SD4PHY_CTB_PHY_TSEL_REG__TSEL_RD_VALUE_DATA_SHIFT 16U
+//! Slice: phy_tsel_reg__tsel_off_value_data:
+//! Termination select off value for the data.
+#define SD4PHY_CTB_PHY_TSEL_REG__TSEL_OFF_VALUE_DATA
+#define SD4PHY_CTB_PHY_TSEL_REG__TSEL_OFF_VALUE_DATA_MASK 0x00F00000U
+#define SD4PHY_CTB_PHY_TSEL_REG__TSEL_OFF_VALUE_DATA_SHIFT 20U
+
+//! Register: phy_gpio_ctrl_0: phy_gpio_ctrl_0 (SD4PHY_CTB_BASE + 0x00000008)
+//! Slice: phy_gpio_ctrl_0__phy_gpio_ctrl_0_value:
+//! General purpose register field. The [31:0] vector is brought to the PHY I/Os. User may choose to use these pins to control any static settings that may be required for the connected I/O pads.
+#define SD4PHY_CTB_PHY_GPIO_CTRL_0__PHY_GPIO_CTRL_0_VALUE
+#define SD4PHY_CTB_PHY_GPIO_CTRL_0__PHY_GPIO_CTRL_0_VALUE_MASK 0xFFFFFFFFU
+#define SD4PHY_CTB_PHY_GPIO_CTRL_0__PHY_GPIO_CTRL_0_VALUE_SHIFT 0U
+
+//! Register: phy_gpio_ctrl_1: phy_gpio_ctrl_1 (SD4PHY_CTB_BASE + 0x0000000c)
+//! Slice: phy_gpio_ctrl_1__phy_gpio_ctrl_1_value:
+//! General purpose register field. The [31:0] vector is brought to the PHY IOs. User may choose to use these pins to control any static settings that may be required for the connected IO pads.
+#define SD4PHY_CTB_PHY_GPIO_CTRL_1__PHY_GPIO_CTRL_1_VALUE
+#define SD4PHY_CTB_PHY_GPIO_CTRL_1__PHY_GPIO_CTRL_1_VALUE_MASK 0xFFFFFFFFU
+#define SD4PHY_CTB_PHY_GPIO_CTRL_1__PHY_GPIO_CTRL_1_VALUE_SHIFT 0U
+
+//! Register: phy_gpio_status_0: phy_gpio_status_0 (SD4PHY_CTB_BASE + 0x00000010)
+//! Slice: phy_gpio_status_0__phy_gpio_status_0_value:
+//! This register is a general purpose register. A [31:0] vector is brought from the PHY IOs to this register. User may choose to use this as a status register.
+#define SD4PHY_CTB_PHY_GPIO_STATUS_0__PHY_GPIO_STATUS_0_VALUE
+#define SD4PHY_CTB_PHY_GPIO_STATUS_0__PHY_GPIO_STATUS_0_VALUE_MASK 0xFFFFFFFFU
+#define SD4PHY_CTB_PHY_GPIO_STATUS_0__PHY_GPIO_STATUS_0_VALUE_SHIFT 0U
+
+//! Register: phy_gpio_status_1: phy_gpio_status_1 (SD4PHY_CTB_BASE + 0x00000014)
+//! Slice: phy_gpio_status_1__phy_gpio_status_1_value:
+//! This register is a general purpose register. A [31:0] vector is brought from the PHY I/Os to this register. User may choose to use this as a status register.
+#define SD4PHY_CTB_PHY_GPIO_STATUS_1__PHY_GPIO_STATUS_1_VALUE
+#define SD4PHY_CTB_PHY_GPIO_STATUS_1__PHY_GPIO_STATUS_1_VALUE_MASK 0xFFFFFFFFU
+#define SD4PHY_CTB_PHY_GPIO_STATUS_1__PHY_GPIO_STATUS_1_VALUE_SHIFT 0U
+
+#endif /* __SD4PHY_CTB_REGS_H__ */
+/*************************** EOF **************************************/
diff --git a/include/dct/sd4phy_dllphy_regs.h b/include/dct/sd4phy_dllphy_regs.h
new file mode 100644
index 0000000000..6b77e96431
--- /dev/null
+++ b/include/dct/sd4phy_dllphy_regs.h
@@ -0,0 +1,469 @@
+ /*
+ * (C) Copyright 2023,
+ * Dream Chip Technologies
+ * Axel Ludszuweit, <Axel.ludszuweit@dreamchip.de>
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#ifndef __SD4PHY_DLLPHY_REGS_H__
+#define __SD4PHY_DLLPHY_REGS_H__
+
+#include <stdint.h>
+
+//! Sd4phyDllphy Register layout
+typedef struct
+{
+  //! Register Group: sd4phy_dllphy
+  uint32_t _notused_0 [2048]; // gap in address space
+  uint32_t phy_dq_timing_reg; //!< phy_dq_timing_reg (slice) SD4PHY_DLLPHY_BASE + 0x00000000
+  uint32_t phy_dqs_timing_reg; //!< phy_dqs_timing_reg (slice) SD4PHY_DLLPHY_BASE + 0x00000004
+  uint32_t phy_gate_lpbk_ctrl_reg; //!< phy_gate_lpbk_ctrl_reg (slice) SD4PHY_DLLPHY_BASE + 0x00000008
+  uint32_t phy_dll_master_ctrl_reg; //!< phy_dll_master_ctrl_reg (slice) SD4PHY_DLLPHY_BASE + 0x0000000c
+  uint32_t phy_dll_slave_ctrl_reg; //!< phy_dll_slave_ctrl_reg (slice) SD4PHY_DLLPHY_BASE + 0x00000010
+  uint32_t phy_ie_timing_reg; //!< phy_ie_timing_reg (slice) SD4PHY_DLLPHY_BASE + 0x00000014
+  uint32_t phy_obs_reg_0; //!< phy_obs_reg_0 (slice) SD4PHY_DLLPHY_BASE + 0x00000018
+  uint32_t phy_dll_obs_reg_0; //!< phy_dll_obs_reg_0 (slice) SD4PHY_DLLPHY_BASE + 0x0000001c
+  uint32_t phy_dll_obs_reg_1; //!< phy_dll_obs_reg_1 (slice) SD4PHY_DLLPHY_BASE + 0x00000020
+  uint32_t _notused_1 [1]; // gap in address space
+  uint32_t phy_static_togg_reg; //!< phy_static_togg_reg (slice) SD4PHY_DLLPHY_BASE + 0x00000028
+  uint32_t _notused_2 [2]; // gap in address space
+  uint32_t phy_wr_deskew_pd_ctrl_0_reg; //!< phy_wr_deskew_pd_ctrl_0_reg (slice) SD4PHY_DLLPHY_BASE + 0x00000034
+  uint32_t _notused_3 [14]; // gap in address space
+  uint32_t phy_version_reg; //!< phy_version_reg (slice) SD4PHY_DLLPHY_BASE + 0x00000070
+  uint32_t phy_features_reg; //!< phy_features_reg (slice) SD4PHY_DLLPHY_BASE + 0x00000074
+} Sd4phyDllphyRegister_t;
+
+
+// - MASK AND SHIFT MACROS ----------------------------------------------------------
+
+//! Register Group: sd4phy_dllphy
+
+//! Register: phy_dq_timing_reg: phy_dq_timing_reg (SD4PHY_DLLPHY_BASE + 0x00000000)
+//! Slice: phy_dq_timing_reg__data_select_oe_end:
+//! Adjusts the ending point of the DQ pad output enable window. Lower numbers pull the falling edge earlier in time and larger numbers cause the falling edge to be delayed. Each bit changes the output enable time by a 1/2 cycle resolution.
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__DATA_SELECT_OE_END
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__DATA_SELECT_OE_END_MASK 0x00000007U
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__DATA_SELECT_OE_END_SHIFT 0U
+//! Slice: phy_dq_timing_reg__data_select_oe_start:
+//! Adjusts the starting point of the DQ pad output enable window. Lower numbers pull the rising edge earlier in time and larger numbers cause the rising edge to be delayed. Each bit changes the output enable time by a 1/2 cycle resolution.
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__DATA_SELECT_OE_START
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__DATA_SELECT_OE_START_MASK 0x00000070U
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__DATA_SELECT_OE_START_SHIFT 4U
+//! Slice: phy_dq_timing_reg__data_select_tsel_end:
+//! Defines the DQ pad dynamic termination select disable time. Larger values increase the delay to when tsel turns off. Each bit changes the output enable time by a 1/2 cycle resolution.
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__DATA_SELECT_TSEL_END
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__DATA_SELECT_TSEL_END_MASK 0x00000F00U
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__DATA_SELECT_TSEL_END_SHIFT 8U
+//! Slice: phy_dq_timing_reg__data_select_tsel_start:
+//! Defines the DQ pad dynamic termination select enable time. Larger values add greater delay to when tsel turns on. Each bit changes the output enable time by a 1/2 cycle resolution.
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__DATA_SELECT_TSEL_START
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__DATA_SELECT_TSEL_START_MASK 0x0000F000U
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__DATA_SELECT_TSEL_START_SHIFT 12U
+//! Slice: phy_dq_timing_reg__data_clkperiod_delay:
+//! Defines additional latency on the write datapath. It also adds a clock cycle delay for the data OE path which is equivalent of adding 2 to the data_select_oe_end and data_select_oe_start.
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__DATA_CLKPERIOD_DELAY
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__DATA_CLKPERIOD_DELAY_MASK 0x00010000U
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__DATA_CLKPERIOD_DELAY_SHIFT 16U
+//! Slice: phy_dq_timing_reg__io_mask_start:
+//! Adjusts the starting point of the DQ/CMD pad input mask enable. Defines the delay after dfi_wrdata_en/dfi_wrcmd_en goes low when the mask is enabled (data/cmd are passed to PHY).
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__IO_MASK_START
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__IO_MASK_START_MASK 0x07000000U
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__IO_MASK_START_SHIFT 24U
+//! Slice: phy_dq_timing_reg__io_mask_end:
+//! Adjusts the ending point of the DQ/CMD pad input mask enable. Defines the delay after dfi_wrdata_en/dfi_wrcmd_en goes high when the mask is disabled (data/cmd are blocked and 1'b1 are passed to PHY).
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__IO_MASK_END
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__IO_MASK_END_MASK 0x38000000U
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__IO_MASK_END_SHIFT 27U
+//! Slice: phy_dq_timing_reg__io_mask_always_on:
+//! Defines if the IO mask for DATA/CMD is always enabled. [list] [*]0 = disable ie. start/end defines the IO mask functionality.  Recommended setting for SD/eMMC controller. [*]1 = IO mask is always ON. [/list]
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__IO_MASK_ALWAYS_ON
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__IO_MASK_ALWAYS_ON_MASK 0x80000000U
+#define SD4PHY_DLLPHY_PHY_DQ_TIMING_REG__IO_MASK_ALWAYS_ON_SHIFT 31U
+
+//! Register: phy_dqs_timing_reg: phy_dqs_timing_reg (SD4PHY_DLLPHY_BASE + 0x00000004)
+//! Slice: phy_dqs_timing_reg__dqs_select_tsel_end:
+//! Defines the DQ pad dynamic termination select disable time. Larger values increase the delay to when tsel turns off. Each bit changes the output enable time by a 1/2 cycle resolution.
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__DQS_SELECT_TSEL_END
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__DQS_SELECT_TSEL_END_MASK 0x00000F00U
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__DQS_SELECT_TSEL_END_SHIFT 8U
+//! Slice: phy_dqs_timing_reg__dqs_select_tsel_start:
+//! Defines the DQ pad dynamic termination select enable time. Larger values add greater delay to when tsel turns on. Each bit changes the output enable time by a 1/2 cycle resolution.
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__DQS_SELECT_TSEL_START
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__DQS_SELECT_TSEL_START_MASK 0x0000F000U
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__DQS_SELECT_TSEL_START_SHIFT 12U
+//! Slice: phy_dqs_timing_reg__phony_dqs_sel:
+//! If this bit is cleared the phony_dqs is synchronous with rising edge of the clk_phy before sending to the entry flops. If this bit is set high the phony_dqs is synchronous with falling edge of clk_phy before sending to the entry flops.
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__PHONY_DQS_SEL
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__PHONY_DQS_SEL_MASK 0x00010000U
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__PHONY_DQS_SEL_SHIFT 16U
+//! Slice: phy_dqs_timing_reg__use_phony_dqs_cmd:
+//! Bit to choose phony DQS (or lpbk_dqs) from the control slice logic or DQS from the device to capture command data for reads. [list] [*]0 - Use DQS from device for command data capture.[*]1 - Use phony DQS or lpbk_dqs for command data capture.[/list]
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_PHONY_DQS_CMD
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_PHONY_DQS_CMD_MASK 0x00080000U
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_PHONY_DQS_CMD_SHIFT 19U
+//! Slice: phy_dqs_timing_reg__use_phony_dqs:
+//! Bit to choose phony DQS from the control slice logic or DQS from the device to capture data for reads. [list] [*]0 - Use DQS from device for data capture.[*]1 - Use phony DQS for data capture.[/list]
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_PHONY_DQS
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_PHONY_DQS_MASK 0x00100000U
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_PHONY_DQS_SHIFT 20U
+//! Slice: phy_dqs_timing_reg__use_lpbk_dqs:
+//! Bit to choose lpbk_dqs to capture data for reads. It is valid when 'use_phony_dqs' is set high. [list] [*]0 - Use phony DQS for data capture.[*]1 - Use lpbk_dqs for data capture. Recommended setting for SD/eMMC controller. [/list]
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_LPBK_DQS
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_LPBK_DQS_MASK 0x00200000U
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_LPBK_DQS_SHIFT 21U
+//! Slice: phy_dqs_timing_reg__use_ext_lpbk_dqs:
+//! Bit to choose lpbk_dqs to capture data for reads. It is valid when 'use_phony_dqs' and 'use_lpbk_dqs' fields are set high. [list] [*]0 - use internal lpbk_dqs (mem_rebar_ipad) for data capture.[*]1 -  use external lpbk_dqs (lpbk_dqs connected to the lpbk_dqs_IO PAD) for data capture.[/list]
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_EXT_LPBK_DQS
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_EXT_LPBK_DQS_MASK 0x00400000U
+#define SD4PHY_DLLPHY_PHY_DQS_TIMING_REG__USE_EXT_LPBK_DQS_SHIFT 22U
+
+//! Register: phy_gate_lpbk_ctrl_reg: phy_gate_lpbk_ctrl_reg (SD4PHY_DLLPHY_BASE + 0x00000008)
+//! Slice: phy_gate_lpbk_ctrl_reg__gate_cfg:
+//! Coarse adjust of gate open time. This value is the number of cycles to delay the dfi_rddata_en signal prior to opening the gate in full cycle increments. Decreasing this value pulls the gate earlier in time. This field should be programmed such that the gate signal lands in the valid DQS gate window.
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__GATE_CFG
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__GATE_CFG_MASK 0x0000000FU
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__GATE_CFG_SHIFT 0U
+//! Slice: phy_gate_lpbk_ctrl_reg__gate_cfg_close:
+//! Normally the gate is closing when all bits of dfi_cebar are high or when dfi_rd_pre_post_amble and rebar_dfi are high. This parameter allows to extend the closing of the DQS gate. Recommended value is zero.
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__GATE_CFG_CLOSE
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__GATE_CFG_CLOSE_MASK 0x00000030U
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__GATE_CFG_CLOSE_SHIFT 4U
+//! Slice: phy_gate_lpbk_ctrl_reg__gate_cfg_always_on:
+//! This parameter cause the gate to be always on. Recommended setting for SD/eMMC controller is 1.
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__GATE_CFG_ALWAYS_ON
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__GATE_CFG_ALWAYS_ON_MASK 0x00000040U
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__GATE_CFG_ALWAYS_ON_SHIFT 6U
+//! Slice: phy_gate_lpbk_ctrl_reg__lpbk_en:
+//! Controls internal write multiplexer. [list][*]0 = Normal Operation. [*]1 = Enable loopback.[/list]
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__LPBK_EN
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__LPBK_EN_MASK 0x00000100U
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__LPBK_EN_SHIFT 8U
+//! Slice: phy_gate_lpbk_ctrl_reg__loopback_control:
+//! Loopback control. [list][*]0 = Normal Operation Mode. [*]1 = lpbk_start; Enables loopback write mode. [*]2 = lpbk_stop; Stop loopback to check error register. [*]3 = clear; Clear loopback registers.[/list]
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__LOOPBACK_CONTROL
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__LOOPBACK_CONTROL_MASK 0x00000C00U
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__LOOPBACK_CONTROL_SHIFT 10U
+//! Slice: phy_gate_lpbk_ctrl_reg__lpbk_fail_muxsel:
+//! Selects data output type for phy_obs_reg_0[23:8]. [list][*]0 = Return the expected data. [*]1 = Return the actual data.[/list]
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__LPBK_FAIL_MUXSEL
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__LPBK_FAIL_MUXSEL_MASK 0x00001000U
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__LPBK_FAIL_MUXSEL_SHIFT 12U
+//! Slice: phy_gate_lpbk_ctrl_reg__lpbk_err_check_timing:
+//! Sets the cycle delay between the LFSR and loopback error check logic to ensure that the LFSR sourced data and data being looped back arrive at the same clock cycle for comparison. This value is related to the rd_del_sel field, and is equal to 7 - rd_del_sel.
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__LPBK_ERR_CHECK_TIMING
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__LPBK_ERR_CHECK_TIMING_MASK 0x0000E000U
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__LPBK_ERR_CHECK_TIMING_SHIFT 13U
+//! Slice: phy_gate_lpbk_ctrl_reg__rd_del_sel_empty:
+//! Defines the read data delay for the empty signal generated based on the incoming DQS strobes. For zero delay the data are passed from entry flops to the iodatain* flops one clock cycle after the !empty signals is asserted. Normally the zero value of this field is sufficient as the signal is generated based on the gray pointer synchronized with two stage synchronizer on clk_phy clock domain which gives minimum two clock cycle path from entry flop to the iodatain flop. Increasing the value of this field delays the moment of passing the data from entry flops to the iodatain flops. Increased value gives even more time to propagate the data but the bigger value the bigger probability to overflow the FIFO. Recommended value is zero.
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__RD_DEL_SEL_EMPTY
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__RD_DEL_SEL_EMPTY_MASK 0x00010000U
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__RD_DEL_SEL_EMPTY_SHIFT 16U
+//! Slice: phy_gate_lpbk_ctrl_reg__underrun_suppress:
+//! This field turns off the generation of the underrun signal when 'sync_method' is set high.  For Cadence SD/eMMC controller this field need to be set high.
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__UNDERRUN_SUPPRESS
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__UNDERRUN_SUPPRESS_MASK 0x00040000U
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__UNDERRUN_SUPPRESS_SHIFT 18U
+//! Slice: phy_gate_lpbk_ctrl_reg__rd_del_sel:
+//! Defines the read data delay. Holds the number of cycles to delay the dfi_rddata_en signal prior to enabling the read FIFO. After this delay, the read pointers begin incrementing the read FIFO. If 'sync_method' is set high the value of this field must take into account the synchronization time of the pointers in the entry FIFO (adding three clock cycles should be sufficient).
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__RD_DEL_SEL
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__RD_DEL_SEL_MASK 0x00F80000U
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__RD_DEL_SEL_SHIFT 19U
+//! Slice: phy_gate_lpbk_ctrl_reg__sync_method:
+//! Defines the method of transfering the data from DQS domain flops to the clk_phy clock domain. [list] [*]if set low the read pointer advances based upon a programmable delay of the dfi_rddata_en pulse from the DFI interface. [*]if set high the read pointer advances based upon a programmable delay of the empty signal. Recommended setting for SD/eMMC controller. [/list]
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__SYNC_METHOD
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__SYNC_METHOD_MASK 0x80000000U
+#define SD4PHY_DLLPHY_PHY_GATE_LPBK_CTRL_REG__SYNC_METHOD_SHIFT 31U
+
+//! Register: phy_dll_master_ctrl_reg: phy_dll_master_ctrl_reg (SD4PHY_DLLPHY_BASE + 0x0000000c)
+//! Slice: phy_dll_master_ctrl_reg__param_dll_start_point:
+//! This value is the initial delay value for the DLL. This value is also used as the increment value if the initial value is less than a half-clock cycle. This field should be set such that it is not greater than 7/8ths of a clock period given the worst case element delay. For example, if the frequency is 200MHz (5ns cycle time) with a worst case element 80ps delay, this field should be set to = 5 * (7/8) / .080 = 54 elements. This calculation helps determine the start point which achieves the fastest lock. However, a small value such as 0x04 may be used instead to ensure that the DLL does not lock on a harmonic. Note that with a small value like this, the initial lock time will be longer. Value smaller than 0x04 may cause no lock by DLL.
+#define SD4PHY_DLLPHY_PHY_DLL_MASTER_CTRL_REG__PARAM_DLL_START_POINT
+#define SD4PHY_DLLPHY_PHY_DLL_MASTER_CTRL_REG__PARAM_DLL_START_POINT_MASK 0x000000FFU
+#define SD4PHY_DLLPHY_PHY_DLL_MASTER_CTRL_REG__PARAM_DLL_START_POINT_SHIFT 0U
+//! Slice: phy_dll_master_ctrl_reg__param_dll_lock_num:
+//! Holds the number of consecutive increment or decrement indications that will trigger an unlock condition and increment the dll_unlock_cnt field (bits [7:3]) and either the lock_dec_dbg (bits [23:16]) or lock_inc_dbg (bits [31:24]) fields of the phy_dll_obs_reg_0 parameter.
+#define SD4PHY_DLLPHY_PHY_DLL_MASTER_CTRL_REG__PARAM_DLL_LOCK_NUM
+#define SD4PHY_DLLPHY_PHY_DLL_MASTER_CTRL_REG__PARAM_DLL_LOCK_NUM_MASK 0x00070000U
+#define SD4PHY_DLLPHY_PHY_DLL_MASTER_CTRL_REG__PARAM_DLL_LOCK_NUM_SHIFT 16U
+//! Slice: phy_dll_master_ctrl_reg__param_phase_detect_sel:
+//! Selects the number of delay elements to be inserted between the phase detect flip-flops. Defaults to 0x0 although the recommended value is 2 elements but if a lock condition is not detected, the user should increase the number of delay elements. [list] [*]'b000 - One delay element. [*]'b001 - Two delay element. [*]'b010 - Three delay element. [*]'b011 - Four delay element. [*]'b100 - Five delay element. [*]'b101 - Six delay element. [*]'b110 - Seven delay element. [*]'b111 - Eight delay element. [/list]
+#define SD4PHY_DLLPHY_PHY_DLL_MASTER_CTRL_REG__PARAM_PHASE_DETECT_SEL
+#define SD4PHY_DLLPHY_PHY_DLL_MASTER_CTRL_REG__PARAM_PHASE_DETECT_SEL_MASK 0x00700000U
+#define SD4PHY_DLLPHY_PHY_DLL_MASTER_CTRL_REG__PARAM_PHASE_DETECT_SEL_SHIFT 20U
+//! Slice: phy_dll_master_ctrl_reg__param_dll_bypass_mode:
+//! DLL bypass mode control. Controls the bypass mode of the master and slave DLLs. The param_dll_bypass_mode is intended to be used only for debug. [list][*]0 - Normal operational mode. DLL functioning in normal mode of operation where the slave delay line settings are used as fractional delay of the master delay line encoder reading of the number of delays in one cycle. [*]1 - Bypass mode on. Delays are defined in phy_dll_slave_ctrl_reg. Master DLL is disabled with only 1 delay element in its delay line. The slave slave delay lines decode delays in absolute delay elements rather than as fractional delays. The dll_lock field (bit [0]) of the phy_dll_obs_reg_0 parameter will be forced high. [/list]
+#define SD4PHY_DLLPHY_PHY_DLL_MASTER_CTRL_REG__PARAM_DLL_BYPASS_MODE
+#define SD4PHY_DLLPHY_PHY_DLL_MASTER_CTRL_REG__PARAM_DLL_BYPASS_MODE_MASK 0x00800000U
+#define SD4PHY_DLLPHY_PHY_DLL_MASTER_CTRL_REG__PARAM_DLL_BYPASS_MODE_SHIFT 23U
+
+//! Register: phy_dll_slave_ctrl_reg: phy_dll_slave_ctrl_reg (SD4PHY_DLLPHY_BASE + 0x00000010)
+//! Slice: phy_dll_slave_ctrl_reg__read_dqs_delay:
+//! Controls the read DQS delay which adjusts the timing in 1/256th of the clock period when in normal DLL locked mode. In bypass mode, this field directly programs the number of delay elements.
+#define SD4PHY_DLLPHY_PHY_DLL_SLAVE_CTRL_REG__READ_DQS_DELAY
+#define SD4PHY_DLLPHY_PHY_DLL_SLAVE_CTRL_REG__READ_DQS_DELAY_MASK 0x000000FFU
+#define SD4PHY_DLLPHY_PHY_DLL_SLAVE_CTRL_REG__READ_DQS_DELAY_SHIFT 0U
+//! Slice: phy_dll_slave_ctrl_reg__clk_wr_delay:
+//! Controls the clk_wr delay line which adjusts the write DQ and CMD bit timing in 1/256th steps of the clock period in normal DLL locked mode. In bypass mode, this field directly programs the number of delay elements.
+#define SD4PHY_DLLPHY_PHY_DLL_SLAVE_CTRL_REG__CLK_WR_DELAY
+#define SD4PHY_DLLPHY_PHY_DLL_SLAVE_CTRL_REG__CLK_WR_DELAY_MASK 0x0000FF00U
+#define SD4PHY_DLLPHY_PHY_DLL_SLAVE_CTRL_REG__CLK_WR_DELAY_SHIFT 8U
+//! Slice: phy_dll_slave_ctrl_reg__read_dqs_cmd_delay:
+//! Controls the read command DQS delay which adjusts the timing in 1/256th of the clock period when in normal DLL locked mode. In bypass mode, this field directly programs the number of delay elements.
+#define SD4PHY_DLLPHY_PHY_DLL_SLAVE_CTRL_REG__READ_DQS_CMD_DELAY
+#define SD4PHY_DLLPHY_PHY_DLL_SLAVE_CTRL_REG__READ_DQS_CMD_DELAY_MASK 0xFF000000U
+#define SD4PHY_DLLPHY_PHY_DLL_SLAVE_CTRL_REG__READ_DQS_CMD_DELAY_SHIFT 24U
+
+//! Register: phy_ie_timing_reg: phy_ie_timing_reg (SD4PHY_DLLPHY_BASE + 0x00000014)
+//! Slice: phy_ie_timing_reg__rddata_en_ie_dly:
+//! Specifies the number of clocks of delay for the dfi_rddata_en signal to line it up with the true (normal) DFI read data position. The MC must deliver an early version of the read data enable to allow time for the input pads to turn on and this field allows the PHY to create the original timing.
+#define SD4PHY_DLLPHY_PHY_IE_TIMING_REG__RDDATA_EN_IE_DLY
+#define SD4PHY_DLLPHY_PHY_IE_TIMING_REG__RDDATA_EN_IE_DLY_MASK 0x0000000FU
+#define SD4PHY_DLLPHY_PHY_IE_TIMING_REG__RDDATA_EN_IE_DLY_SHIFT 0U
+//! Slice: phy_ie_timing_reg__dqs_ie_stop:
+//! Define the stop position for the DQS input enable.
+#define SD4PHY_DLLPHY_PHY_IE_TIMING_REG__DQS_IE_STOP
+#define SD4PHY_DLLPHY_PHY_IE_TIMING_REG__DQS_IE_STOP_MASK 0x00000070U
+#define SD4PHY_DLLPHY_PHY_IE_TIMING_REG__DQS_IE_STOP_SHIFT 4U
+//! Slice: phy_ie_timing_reg__dqs_ie_start:
+//! Define the start position for the DQS input enable.
+#define SD4PHY_DLLPHY_PHY_IE_TIMING_REG__DQS_IE_START
+#define SD4PHY_DLLPHY_PHY_IE_TIMING_REG__DQS_IE_START_MASK 0x00000700U
+#define SD4PHY_DLLPHY_PHY_IE_TIMING_REG__DQS_IE_START_SHIFT 8U
+//! Slice: phy_ie_timing_reg__dq_ie_stop:
+//! Define the stop position for the DQ input enable.
+#define SD4PHY_DLLPHY_PHY_IE_TIMING_REG__DQ_IE_STOP
+#define SD4PHY_DLLPHY_PHY_IE_TIMING_REG__DQ_IE_STOP_MASK 0x00007000U
+#define SD4PHY_DLLPHY_PHY_IE_TIMING_REG__DQ_IE_STOP_SHIFT 12U
+//! Slice: phy_ie_timing_reg__dq_ie_start:
+//! Define the start position for the DQ input enable.
+#define SD4PHY_DLLPHY_PHY_IE_TIMING_REG__DQ_IE_START
+#define SD4PHY_DLLPHY_PHY_IE_TIMING_REG__DQ_IE_START_MASK 0x00070000U
+#define SD4PHY_DLLPHY_PHY_IE_TIMING_REG__DQ_IE_START_SHIFT 16U
+//! Slice: phy_ie_timing_reg__ie_always_on:
+//! Forces the input enable(s) to be on always.
+#define SD4PHY_DLLPHY_PHY_IE_TIMING_REG__IE_ALWAYS_ON
+#define SD4PHY_DLLPHY_PHY_IE_TIMING_REG__IE_ALWAYS_ON_MASK 0x00100000U
+#define SD4PHY_DLLPHY_PHY_IE_TIMING_REG__IE_ALWAYS_ON_SHIFT 20U
+
+//! Register: phy_obs_reg_0: phy_obs_reg_0 (SD4PHY_DLLPHY_BASE + 0x00000018)
+//! Slice: phy_obs_reg_0__lpbk_status:
+//! Loopback Status [list] [*] Bit0 - lpbk start; Defines the status of the loopback mode. 0 = Not in loopback mode; 1 = In loopback mode. [*] Bit1 - lpbk status; Defines the status of the loopback mode. 0 = Last Loopback test had no errors; 1 = Last loopback test contained data errors. [/list]
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__LPBK_STATUS
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__LPBK_STATUS_MASK 0x00000003U
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__LPBK_STATUS_SHIFT 0U
+//! Slice: phy_obs_reg_0__lpbk_cmd_data:
+//! If errors are encountered in loopback test this field reports the actual data or the expected data of the CMD line, depending on the setting of the phy_gate_lpbk_ctrl_reg [12] parameter bit. This field is not clear by the clear state of the loopback. If there are no errors in loopback test the value is zero (or value from previous state).
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__LPBK_CMD_DATA
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__LPBK_CMD_DATA_MASK 0x00000080U
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__LPBK_CMD_DATA_SHIFT 7U
+//! Slice: phy_obs_reg_0__lpbk_dq_data:
+//! If errors are encountered in loopback test this field reports the actual data or the expected data, depending on the setting of the phy_gate_lpbk_ctrl_reg [12] parameter bit. This field is not clear by the clear state of the loopback. If there are no errors in loopback test the value is zero (or value from previous state).
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__LPBK_DQ_DATA
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__LPBK_DQ_DATA_MASK 0x00FFFF00U
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__LPBK_DQ_DATA_SHIFT 8U
+//! Slice: phy_obs_reg_0__dqs_underrun:
+//! Status signal to indicate that the logic gate had to be forced closed. It indicates that either the DQS strobe did not appear during read or rd_del_sel signal value is too low and dfi_rddata are corrupted. The dll_rst_n or rst_n clears this flag.
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__DQS_UNDERRUN
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__DQS_UNDERRUN_MASK 0x01000000U
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__DQS_UNDERRUN_SHIFT 24U
+//! Slice: phy_obs_reg_0__dqs_overflow:
+//! Status signal to indicate that the logic gate was closed too late ie. the number of DQS strobes exceed the capacity of the entry FIFO. It indicates that rd_del_sel signal value is too high and dfi_rddata are corrupted. It is possible that overflow status is asserted with underrun status - in such case the overflow takes the precedence. The dll_rst_n or rst_n clears this flag.
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__DQS_OVERFLOW
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__DQS_OVERFLOW_MASK 0x02000000U
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__DQS_OVERFLOW_SHIFT 25U
+//! Slice: phy_obs_reg_0__dqs_cmd_underrun:
+//! CMD Status signal to indicate that the logic gate had to be forced closed. It indicates that either the DQS strobe did not appear during read or rd_del_sel signal value is too low and dfi_rddata are corrupted. The dll_rst_n or rst_n clears this flag.
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__DQS_CMD_UNDERRUN
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__DQS_CMD_UNDERRUN_MASK 0x04000000U
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__DQS_CMD_UNDERRUN_SHIFT 26U
+//! Slice: phy_obs_reg_0__dqs_cmd_overflow:
+//! CMD Status signal to indicate that the logic gate was closed too late ie. the number of DQS strobes exceed the capacity of the entry FIFO. It indicates that rd_del_sel signal value is too high and dfi_rddata are corrupted. It is possible that overflow status is asserted with underrun status - in such case the overflow takes the precedence. The dll_rst_n or rst_n clears this flag.
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__DQS_CMD_OVERFLOW
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__DQS_CMD_OVERFLOW_MASK 0x08000000U
+#define SD4PHY_DLLPHY_PHY_OBS_REG_0__DQS_CMD_OVERFLOW_SHIFT 27U
+
+//! Register: phy_dll_obs_reg_0: phy_dll_obs_reg_0 (SD4PHY_DLLPHY_BASE + 0x0000001c)
+//! Slice: phy_dll_obs_reg_0__dll_lock:
+//! Indicates status of DLL. It indicates the DLL locking when the DLL lock logic found (not inc AND not dec) OR (an inc then dec) OR (a dec then inc). When param_dll_start_point is set smaller than half clock period the first found (a dec then inc) isn't the really DLL locking point but dll_lock is asserted. [list][*]0 - DLL has not locked. [*]1 - DLL is locked. [/list]
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_0__DLL_LOCK
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_0__DLL_LOCK_MASK 0x00000001U
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_0__DLL_LOCK_SHIFT 0U
+//! Slice: phy_dll_obs_reg_0__dll_locked_mode:
+//! Indicates status of DLL. Defines the mode in which the DLL has achieved the lock. [list] [*]'b00 -  Full clock mode. The master delay line was long enough to lock on one full clock cycle of delay. In this mode, the dll_lock_value field (bits [15:8]) of this parameter indicates the number of delays in full clock cycles. [*]'b01 - Reserved. [*]'b10 - Half clock mode. The master delay line was not long enough to lock one full cycle of delay but could lock on a half-cycle of delay. In this mode, the dll_lock_value field (bits [15:8]) of this parameter indicates the number of delays in one half clock cycles. [*]'b11 -  Saturation mode. The master delay line was not long enough to lock on a full or a half-clock cycle. In this mode, the encoder value is fixed at the maximum delay line setting and the master DLL will be disabled. The slave delay lines continue to use the fractional delays based upon the fixed saturation value of the delay line. [/list]
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_0__DLL_LOCKED_MODE
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_0__DLL_LOCKED_MODE_MASK 0x00000006U
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_0__DLL_LOCKED_MODE_SHIFT 1U
+//! Slice: phy_dll_obs_reg_0__dll_unlock_cnt:
+//! Reports the number of times that the master DLL consecutive increment or decrement value programmed into the param_dll_lock_num field (bits [18:16]) of the phy_dll_master_ctrl_reg register has been triggered. The dll_unlock_cnt will saturate at a value of 0x1f. Asserting the dll_rst_n signal will reset this counter to 0.
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_0__DLL_UNLOCK_CNT
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_0__DLL_UNLOCK_CNT_MASK 0x000000F8U
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_0__DLL_UNLOCK_CNT_SHIFT 3U
+//! Slice: phy_dll_obs_reg_0__dll_lock_value:
+//! Reports the number of delay elements that the DLL has determined for lock in either full clock or half clock mode. In full clock mode, this value equals the number of delay elements in one cycle. In half clock mode, this value equals the number of delay elements in one half clock cycle. In saturation mode, this value equals the maximum number of delay elements. The slaves use this value to set up their delays for the clk_wr and read DQS signals. This value is valid only when locking mechanism is done.
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_0__DLL_LOCK_VALUE
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_0__DLL_LOCK_VALUE_MASK 0x0000FF00U
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_0__DLL_LOCK_VALUE_SHIFT 8U
+//! Slice: phy_dll_obs_reg_0__lock_dec_dbg:
+//! Holds the state of the cumulative dll_lock_dec register when the dll_unlock_cnt field(bits [7:3]) of this parameter was triggered to decrement or was last saturated at a value of 0x1f.
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_0__LOCK_DEC_DBG
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_0__LOCK_DEC_DBG_MASK 0x00FF0000U
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_0__LOCK_DEC_DBG_SHIFT 16U
+//! Slice: phy_dll_obs_reg_0__lock_inc_dbg:
+//! Holds the state of the cumulative dll_lock_inc register when the dll_unlock_cnt field(bits [7:3]) of this parameter was triggered to increment or was last saturated at a value of 0x1f.
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_0__LOCK_INC_DBG
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_0__LOCK_INC_DBG_MASK 0xFF000000U
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_0__LOCK_INC_DBG_SHIFT 24U
+
+//! Register: phy_dll_obs_reg_1: phy_dll_obs_reg_1 (SD4PHY_DLLPHY_BASE + 0x00000020)
+//! Slice: phy_dll_obs_reg_1__decoder_out_rd:
+//! Holds the encoded value for the read delay line for this slice.
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_1__DECODER_OUT_RD
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_1__DECODER_OUT_RD_MASK 0x000000FFU
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_1__DECODER_OUT_RD_SHIFT 0U
+//! Slice: phy_dll_obs_reg_1__decoder_out_rd_cmd:
+//! Holds the encoded value for the CMD read delay line for this slice.
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_1__DECODER_OUT_RD_CMD
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_1__DECODER_OUT_RD_CMD_MASK 0x0000FF00U
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_1__DECODER_OUT_RD_CMD_SHIFT 8U
+//! Slice: phy_dll_obs_reg_1__decoder_out_wr:
+//! Holds the encoded value for the clk_wr delay line for this slice.
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_1__DECODER_OUT_WR
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_1__DECODER_OUT_WR_MASK 0x00FF0000U
+#define SD4PHY_DLLPHY_PHY_DLL_OBS_REG_1__DECODER_OUT_WR_SHIFT 16U
+
+//! Register: phy_static_togg_reg: phy_static_togg_reg (SD4PHY_DLLPHY_BASE + 0x00000028)
+//! Slice: phy_static_togg_reg__static_tog_clk_div:
+//! Clock divider to create toggle signal.
+#define SD4PHY_DLLPHY_PHY_STATIC_TOGG_REG__STATIC_TOG_CLK_DIV
+#define SD4PHY_DLLPHY_PHY_STATIC_TOGG_REG__STATIC_TOG_CLK_DIV_MASK 0x0000FFFFU
+#define SD4PHY_DLLPHY_PHY_STATIC_TOGG_REG__STATIC_TOG_CLK_DIV_SHIFT 0U
+//! Slice: phy_static_togg_reg__static_togg_global_enable:
+//! Global control to enable the toggle signal during static activity.
+#define SD4PHY_DLLPHY_PHY_STATIC_TOGG_REG__STATIC_TOGG_GLOBAL_ENABLE
+#define SD4PHY_DLLPHY_PHY_STATIC_TOGG_REG__STATIC_TOGG_GLOBAL_ENABLE_MASK 0x00010000U
+#define SD4PHY_DLLPHY_PHY_STATIC_TOGG_REG__STATIC_TOGG_GLOBAL_ENABLE_SHIFT 16U
+//! Slice: phy_static_togg_reg__static_togg_enable:
+//! Control to enable the toggle signal during static activity. When low the feature is disabled. [list][*]bit 0 - master delay line enable. [*]bit 1 - read path delay line enable. [*]bit 2 - write path delay line enable. [/list]
+#define SD4PHY_DLLPHY_PHY_STATIC_TOGG_REG__STATIC_TOGG_ENABLE
+#define SD4PHY_DLLPHY_PHY_STATIC_TOGG_REG__STATIC_TOGG_ENABLE_MASK 0x00700000U
+#define SD4PHY_DLLPHY_PHY_STATIC_TOGG_REG__STATIC_TOGG_ENABLE_SHIFT 20U
+
+//! Register: phy_wr_deskew_pd_ctrl_0_reg: phy_wr_deskew_pd_ctrl_0_reg (SD4PHY_DLLPHY_BASE + 0x00000034)
+//! Slice: phy_wr_deskew_pd_ctrl_0_reg__dq_phase_detect_sel:
+//! DLL Phase Detect Selector for DQ generation to handle the clock domain crossing between the clock and clk_wr signal. Selects the number of delay elements to be inserted between the phase detect flip-flops. Defaults to 0x0. [list] [*]'b000 - One delay element. [*]'b001 - Two delay element. [*]'b010 - Three delay element. [*]'b011 - Four delay element. [*]'b100 - Five delay element. [*]'b101 - Six delay element. [*]'b110 - Seven delay element. [*]'b111 - Eight delay element. [/list]
+#define SD4PHY_DLLPHY_PHY_WR_DESKEW_PD_CTRL_0_REG__DQ_PHASE_DETECT_SEL
+#define SD4PHY_DLLPHY_PHY_WR_DESKEW_PD_CTRL_0_REG__DQ_PHASE_DETECT_SEL_MASK 0x00000007U
+#define SD4PHY_DLLPHY_PHY_WR_DESKEW_PD_CTRL_0_REG__DQ_PHASE_DETECT_SEL_SHIFT 0U
+//! Slice: phy_wr_deskew_pd_ctrl_0_reg__dq_sw_half_cycle_shift:
+//! [list] [*]'b0 - No effect. [*]'b1 - Adds a half clock delay to the write data path.[/list]
+#define SD4PHY_DLLPHY_PHY_WR_DESKEW_PD_CTRL_0_REG__DQ_SW_HALF_CYCLE_SHIFT
+#define SD4PHY_DLLPHY_PHY_WR_DESKEW_PD_CTRL_0_REG__DQ_SW_HALF_CYCLE_SHIFT_MASK 0x00000010U
+#define SD4PHY_DLLPHY_PHY_WR_DESKEW_PD_CTRL_0_REG__DQ_SW_HALF_CYCLE_SHIFT_SHIFT 4U
+//! Slice: phy_wr_deskew_pd_ctrl_0_reg__dq_en_sw_half_cycle:
+//! Enables the software half cycle shift. This determines if write data is transferred to the clk_wr domain on the positive or negative edge of the PHY clock. This field is valid when dq_sw_dq_phase_bypass is low. [list] [*]'b0 - Hardware automatically controls any shifting needed for the write level delay line. [*]'b1 - The setting in the dq0_sw_half_cycle_shift field this reg defines the shift. Note: If the user chooses to control the half cycle shift manually, it is important that the dq_sw_half_cycle_shift field (bit [4]) of the phy_wr_deskew_pd_ctrl_reg parameter be cleared to 'b0 if the delay is less than a 1/2 cycle and set to 'b1 if the delay is greater than a 1/2 cycle. It is recommended to allow the hardware to control this automatically. [/list]
+#define SD4PHY_DLLPHY_PHY_WR_DESKEW_PD_CTRL_0_REG__DQ_EN_SW_HALF_CYCLE
+#define SD4PHY_DLLPHY_PHY_WR_DESKEW_PD_CTRL_0_REG__DQ_EN_SW_HALF_CYCLE_MASK 0x00000020U
+#define SD4PHY_DLLPHY_PHY_WR_DESKEW_PD_CTRL_0_REG__DQ_EN_SW_HALF_CYCLE_SHIFT 5U
+//! Slice: phy_wr_deskew_pd_ctrl_0_reg__dq_sw_dq_phase_bypass:
+//! [list] [*]'b0 - Use phase detect circuit to determine the half_cycle_shift. [*]'b1 - Use the clk_wr_delay delay line setting to determine the half_cycle_shift. A delay line setting of 0x00-0x7f means half_cycle_shift = 0 and a delay line setting of 0x80-0xff means half_cycle_shift = 1. [/list]
+#define SD4PHY_DLLPHY_PHY_WR_DESKEW_PD_CTRL_0_REG__DQ_SW_DQ_PHASE_BYPASS
+#define SD4PHY_DLLPHY_PHY_WR_DESKEW_PD_CTRL_0_REG__DQ_SW_DQ_PHASE_BYPASS_MASK 0x00000040U
+#define SD4PHY_DLLPHY_PHY_WR_DESKEW_PD_CTRL_0_REG__DQ_SW_DQ_PHASE_BYPASS_SHIFT 6U
+
+//! Register: phy_version_reg: phy_version_reg (SD4PHY_DLLPHY_BASE + 0x00000070)
+//! Slice: phy_version_reg__phy_rev:
+//! PHY revision number.
+#define SD4PHY_DLLPHY_PHY_VERSION_REG__PHY_REV
+#define SD4PHY_DLLPHY_PHY_VERSION_REG__PHY_REV_MASK 0x000000FFU
+#define SD4PHY_DLLPHY_PHY_VERSION_REG__PHY_REV_SHIFT 0U
+//! Slice: phy_version_reg__phy_fix:
+//! Fixed number (minor revision number).
+#define SD4PHY_DLLPHY_PHY_VERSION_REG__PHY_FIX
+#define SD4PHY_DLLPHY_PHY_VERSION_REG__PHY_FIX_MASK 0x0000FF00U
+#define SD4PHY_DLLPHY_PHY_VERSION_REG__PHY_FIX_SHIFT 8U
+//! Slice: phy_version_reg__combo_phy_magic_number:
+//! Magic number.
+#define SD4PHY_DLLPHY_PHY_VERSION_REG__COMBO_PHY_MAGIC_NUMBER
+#define SD4PHY_DLLPHY_PHY_VERSION_REG__COMBO_PHY_MAGIC_NUMBER_MASK 0xFFFF0000U
+#define SD4PHY_DLLPHY_PHY_VERSION_REG__COMBO_PHY_MAGIC_NUMBER_SHIFT 16U
+
+//! Register: phy_features_reg: phy_features_reg (SD4PHY_DLLPHY_BASE + 0x00000074)
+//! Slice: phy_features_reg__onfi_40:
+//! Support for ONFI4.0 - NAND Flash.
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__ONFI_40
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__ONFI_40_MASK 0x00000001U
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__ONFI_40_SHIFT 0U
+//! Slice: phy_features_reg__onfi_41:
+//! Support for ONFI4.1 - NAND Flash.
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__ONFI_41
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__ONFI_41_MASK 0x00000002U
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__ONFI_41_SHIFT 1U
+//! Slice: phy_features_reg__sdr_16bit:
+//! Support for 16bit in ONFI SDR work mode.
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__SDR_16BIT
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__SDR_16BIT_MASK 0x00000004U
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__SDR_16BIT_SHIFT 2U
+//! Slice: phy_features_reg__xspi:
+//! Support for XSPI.
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__XSPI
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__XSPI_MASK 0x00000008U
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__XSPI_SHIFT 3U
+//! Slice: phy_features_reg__sd_emmc:
+//! Support for SD/eMMC.
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__SD_EMMC
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__SD_EMMC_MASK 0x00000010U
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__SD_EMMC_SHIFT 4U
+//! Slice: phy_features_reg__bank_num:
+//! Maximum number of banks supported by hardware. This is an encoded value. [list][*]0 - One bank. [*]1 - Two banks. [*]2 - Four banks. [*]3 - Eight banks.[/list]
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__BANK_NUM
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__BANK_NUM_MASK 0x00000060U
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__BANK_NUM_SHIFT 5U
+//! Slice: phy_features_reg__dll_tap_num:
+//! Number of taps in delay line. This is an encoded value. [list][*]0 - 128. [*]1 - 256. [/list]
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__DLL_TAP_NUM
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__DLL_TAP_NUM_MASK 0x00000080U
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__DLL_TAP_NUM_SHIFT 7U
+//! Slice: phy_features_reg__aging:
+//! Support for aging in delay lines.
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__AGING
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__AGING_MASK 0x00000100U
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__AGING_SHIFT 8U
+//! Slice: phy_features_reg__dfi_clock_ratio:
+//! Support for clock ratio on DFI interface. This is an encoded value. [list][*]0 - 1:1 [*]1 - 1:2 [/list]
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__DFI_CLOCK_RATIO
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__DFI_CLOCK_RATIO_MASK 0x00000200U
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__DFI_CLOCK_RATIO_SHIFT 9U
+//! Slice: phy_features_reg__per_bit_deskew:
+//! Support for per-bit deskew.
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__PER_BIT_DESKEW
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__PER_BIT_DESKEW_MASK 0x00000400U
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__PER_BIT_DESKEW_SHIFT 10U
+//! Slice: phy_features_reg__reg_intf:
+//! SFR interface type.  This is an encoded value. [list][*]0 - DFI. [*]1 - APB.[/list]
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__REG_INTF
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__REG_INTF_MASK 0x00000800U
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__REG_INTF_SHIFT 11U
+//! Slice: phy_features_reg__ext_lpbk_dqs:
+//! Support for external LPBK_DQS io pad.
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__EXT_LPBK_DQS
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__EXT_LPBK_DQS_MASK 0x00001000U
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__EXT_LPBK_DQS_SHIFT 12U
+//! Slice: phy_features_reg__jtag_sup:
+//! Support for JTAG muxes.
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__JTAG_SUP
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__JTAG_SUP_MASK 0x00002000U
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__JTAG_SUP_SHIFT 13U
+//! Slice: phy_features_reg__pll_sup:
+//! Support for PLL.
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__PLL_SUP
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__PLL_SUP_MASK 0x00004000U
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__PLL_SUP_SHIFT 14U
+//! Slice: phy_features_reg__asf_sup:
+//! Support for Automotive Safety Feature.
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__ASF_SUP
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__ASF_SUP_MASK 0x00008000U
+#define SD4PHY_DLLPHY_PHY_FEATURES_REG__ASF_SUP_SHIFT 15U
+
+#endif /* __SD4PHY_DLLPHY_REGS_H__ */
+/*************************** EOF **************************************/
-- 
2.34.1

